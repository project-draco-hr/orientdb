{
  if (iCurrentRID.equals(iOtherRID)) {
    for (int retry=0; retry < MAX_RETRIES; ++retry) {
      ODistributedServerLog.debug(this,cluster.getLocalNodeName(),iRemoteNode,DIRECTION.IN,"Resolved conflict automatically between versions on CREATE record %s/%s v.%d (other RID=%s v.%d). Current record version will be overwritten",database.getName(),iCurrentRID,iCurrentVersion,iOtherRID,iOtherVersion);
      final ORecord record=iCurrentRID.getRecord();
      ORecordInternal.setVersion(record,iOtherVersion - 1);
      record.setDirty();
      try {
        record.save();
        return;
      }
 catch (      OConcurrentModificationException e) {
      }
    }
  }
  ODistributedServerLog.warn(this,cluster.getLocalNodeName(),iRemoteNode,DIRECTION.IN,"Conflict on CREATE record %s/%s v.%d (other RID=%s v.%d)...",database.getName(),iCurrentRID,iCurrentVersion,iOtherRID,iOtherVersion);
  if (!existConflictsForRecord(iCurrentRID)) {
    final ODocument doc=createConflictDocument(ORecordOperation.CREATED,iCurrentRID,iRemoteNode);
    try {
      doc.field(FIELD_OTHER_RID,iOtherRID);
      doc.save();
    }
 catch (    Exception e) {
      errorOnWriteConflict(iRemoteNode,doc);
    }
  }
}
