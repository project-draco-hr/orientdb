{
  ODocument replaced=null;
  Deque<TreeMap<OIndex<?>,List<Object>>> indexKeysMapQueue=lockedKeys.get();
  if (indexKeysMapQueue == null) {
    indexKeysMapQueue=new ArrayDeque<TreeMap<OIndex<?>,List<Object>>>();
    lockedKeys.set(indexKeysMapQueue);
  }
  final TreeMap<OIndex<?>,List<Object>> indexKeysMap=new TreeMap<OIndex<?>,List<Object>>();
  for (  final OIndex<?> index : indexes) {
    final List<Object> keys=new ArrayList<Object>();
    final OIndexDefinition indexDefinition=index.getDefinition();
    final Object key=index.getDefinition().getDocumentValueToIndex(record);
    if (key instanceof Collection) {
      for (      final Object keyItem : (Collection<?>)key) {
        if (!indexDefinition.isNullValuesIgnored() || keyItem != null) {
          keys.add(copyKeyIfNeeded(keyItem));
        }
      }
    }
 else {
      if (!indexDefinition.isNullValuesIgnored() || key != null) {
        keys.add(copyKeyIfNeeded(key));
      }
    }
    indexKeysMap.put(index,keys);
  }
  for (  Map.Entry<OIndex<?>,List<Object>> entry : indexKeysMap.entrySet()) {
    final OIndexInternal<?> index=entry.getKey().getInternal();
    index.lockKeysForUpdate(entry.getValue());
  }
  indexKeysMapQueue.push(indexKeysMap);
  for (  Map.Entry<OIndex<?>,List<Object>> entry : indexKeysMap.entrySet()) {
    final OIndex<?> index=entry.getKey();
    for (    Object keyItem : entry.getValue()) {
      final ODocument r=index.checkEntry(record,keyItem);
      if (r != null)       if (replaced == null)       replaced=r;
 else {
        throw new OIndexException("Cannot merge record from multiple indexes. Use this strategy when you have only one index");
      }
    }
  }
  return replaced;
}
