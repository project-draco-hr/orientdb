{
  acquireExclusiveLock();
  try {
    lockTillAtomicOperationCompletes();
    startAtomicOperation();
    BucketSearchResult bucketSearchResult=findBucket(key);
    OBonsaiBucketPointer bucketPointer=bucketSearchResult.getLastPathItem();
    OCacheEntry keyBucketCacheEntry=diskCache.load(fileId,bucketPointer.getPageIndex(),false);
    OCachePointer keyBucketPointer=keyBucketCacheEntry.getCachePointer();
    keyBucketPointer.acquireExclusiveLock();
    OSBTreeBonsaiBucket<K,V> keyBucket=new OSBTreeBonsaiBucket<K,V>(keyBucketPointer.getDataPointer(),bucketPointer.getPageOffset(),keySerializer,valueSerializer,getTrackMode());
    final boolean itemFound=bucketSearchResult.itemIndex >= 0;
    if (itemFound) {
      keyBucket.updateValue(bucketSearchResult.itemIndex,value);
      logPageChanges(keyBucket,fileId,bucketSearchResult.getLastPathItem().getPageIndex(),false);
    }
 else {
      int insertionIndex=-bucketSearchResult.itemIndex - 1;
      while (!keyBucket.addEntry(insertionIndex,new OSBTreeBonsaiBucket.SBTreeEntry<K,V>(OBonsaiBucketPointer.NULL,OBonsaiBucketPointer.NULL,key,value),true)) {
        keyBucketPointer.releaseExclusiveLock();
        diskCache.release(keyBucketCacheEntry);
        bucketSearchResult=splitBucket(bucketSearchResult.path,insertionIndex,key);
        bucketPointer=bucketSearchResult.getLastPathItem();
        insertionIndex=bucketSearchResult.itemIndex;
        keyBucketCacheEntry=diskCache.load(fileId,bucketSearchResult.getLastPathItem().getPageIndex(),false);
        keyBucketPointer=keyBucketCacheEntry.getCachePointer();
        keyBucketPointer.acquireExclusiveLock();
        keyBucket=new OSBTreeBonsaiBucket<K,V>(keyBucketPointer.getDataPointer(),bucketPointer.getPageOffset(),keySerializer,valueSerializer,getTrackMode());
      }
      logPageChanges(keyBucket,fileId,bucketPointer.getPageIndex(),false);
    }
    keyBucketCacheEntry.markDirty();
    keyBucketPointer.releaseExclusiveLock();
    diskCache.release(keyBucketCacheEntry);
    if (!itemFound)     setSize(size() + 1);
    endAtomicOperation(false);
  }
 catch (  IOException e) {
    rollback();
    throw new OSBTreeException("Error during index update with key " + key + " and value "+ value,e);
  }
 finally {
    releaseExclusiveLock();
  }
}
