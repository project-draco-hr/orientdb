{
  acquireSharedLock();
  try {
    OAtomicOperation atomicOperation=storage.getAtomicOperationsManager().getCurrentOperation();
    BucketSearchResult bucketSearchResult=findBucket(key,atomicOperation);
    OBonsaiBucketPointer bucketPointer=bucketSearchResult.getLastPathItem();
    int index;
    if (bucketSearchResult.itemIndex >= 0) {
      index=inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex - 1;
    }
 else {
      index=-bucketSearchResult.itemIndex - 2;
    }
    boolean firstBucket=true;
    do {
      OCacheEntry cacheEntry=loadPage(atomicOperation,fileId,bucketPointer.getPageIndex(),false,diskCache);
      try {
        OSBTreeBonsaiBucket<K,V> bucket=new OSBTreeBonsaiBucket<K,V>(cacheEntry,bucketPointer.getPageOffset(),keySerializer,valueSerializer,getChangesTree(atomicOperation,cacheEntry));
        if (!firstBucket)         index=bucket.size() - 1;
        for (int i=index; i >= 0; i--) {
          if (!listener.addResult(bucket.getEntry(i)))           return;
        }
        bucketPointer=bucket.getLeftSibling();
        firstBucket=false;
      }
  finally {
        releasePage(atomicOperation,cacheEntry,diskCache);
      }
    }
 while (bucketPointer.getPageIndex() >= 0);
  }
 catch (  IOException ioe) {
    throw new OSBTreeException("Error during fetch of minor values for key " + key + " in sbtree "+ name);
  }
 finally {
    releaseSharedLock();
  }
}
