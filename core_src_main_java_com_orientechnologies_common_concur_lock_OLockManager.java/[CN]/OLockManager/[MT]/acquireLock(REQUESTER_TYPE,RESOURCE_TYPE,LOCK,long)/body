{
  if (!enabled)   return;
  final RESOURCE_TYPE immutableResource=getImmutableResourceId(iResourceId);
  CountableLock lock;
  while (true) {
    lock=new CountableLock();
    CountableLock oldLock=map.putIfAbsent(immutableResource,lock);
    if (oldLock == null)     break;
    lock=oldLock;
    final int oldValue=lock.countLocks.get();
    if (oldValue > 0) {
      if (lock.countLocks.compareAndSet(oldValue,oldValue + 1)) {
        if (map.get(immutableResource) == lock)         break;
      }
    }
  }
  try {
    if (iTimeout <= 0) {
      if (iLockType == LOCK.SHARED)       lock.readWriteLock.readLock().lock();
 else       lock.readWriteLock.writeLock().lock();
    }
 else {
      try {
        if (iLockType == LOCK.SHARED) {
          if (!lock.readWriteLock.readLock().tryLock(iTimeout,TimeUnit.MILLISECONDS))           throw new OLockException("Timeout (" + iTimeout + "ms) on acquiring resource '"+ iResourceId+ "' because is locked from another thread");
        }
 else {
          if (!lock.readWriteLock.writeLock().tryLock(iTimeout,TimeUnit.MILLISECONDS))           throw new OLockException("Timeout (" + iTimeout + "ms) on acquiring resource '"+ iResourceId+ "' because is locked from another thread");
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new OLockException("Thread interrupted while waiting for resource '" + iResourceId + "'");
      }
    }
  }
 catch (  RuntimeException e) {
    lock.countLocks.decrementAndGet();
    if (lock.countLocks.get() == 0)     map.remove(iResourceId);
    throw e;
  }
}
