{
  try {
    final ORawBuffer buffer=storage.readRecord(iClusterSegment,iRid,true,false,OStorage.LOCKING_STRATEGY.DEFAULT);
    if (buffer == null)     if (OFastConcurrentModificationException.enabled())     throw OFastConcurrentModificationException.instance();
 else     throw new OConcurrentModificationException(iRid,new OSimpleVersion(),iVersion,ORecordOperation.UPDATED);
    txSegment.addLog(OTxSegment.OPERATION_UPDATE,iTxId,iRid.clusterId,iRid.clusterPosition,iRecordType,buffer.version,buffer.buffer,-1);
    final OPhysicalPosition ppos=storage.updateRecord(iClusterSegment,iRid,iContent,iVersion,iRecordType);
    if (ppos != null)     return ppos.recordVersion;
    return OVersionFactory.instance().createUntrackedVersion();
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"Error on updating entry #" + iRid + " in log segment: "+ iClusterSegment,e,OTransactionException.class);
  }
  return OVersionFactory.instance().createUntrackedVersion();
}
