{
  checkTransaction();
  status=TXSTATUS.COMMITTING;
  if (database.getStorage() instanceof OStorageProxy)   database.getStorage().commit(this);
 else {
    final List<String> involvedIndexes=getInvolvedIndexes();
    if (involvedIndexes != null)     Collections.sort(involvedIndexes);
    List<OIndexMVRBTreeAbstract<?>> lockedIndexes=null;
    try {
      if (involvedIndexes != null)       for (      String indexName : involvedIndexes) {
        final OIndexMVRBTreeAbstract<?> index=(OIndexMVRBTreeAbstract<?>)database.getMetadata().getIndexManager().getIndexInternal(indexName);
        if (lockedIndexes == null)         lockedIndexes=new ArrayList<OIndexMVRBTreeAbstract<?>>();
        index.acquireModificationLock();
        lockedIndexes.add(index);
      }
      final Collection<? extends OIndex<?>> indexes=database.getMetadata().getIndexManager().getIndexes();
      List<? extends OIndex<?>> indexesToLock=null;
      if (indexes != null) {
        indexesToLock=new ArrayList<OIndex<?>>(indexes);
        Collections.sort(indexesToLock,new Comparator<OIndex<?>>(){
          public int compare(          final OIndex<?> indexOne,          final OIndex<?> indexTwo){
            return indexOne.getName().compareTo(indexTwo.getName());
          }
        }
);
      }
      if (indexesToLock != null && !indexesToLock.isEmpty())       if (lockedIndexes == null)       lockedIndexes=new ArrayList<OIndexMVRBTreeAbstract<?>>();
      for (      OIndex<?> index : indexesToLock) {
        for (        Entry<ORID,ORecordOperation> entry : recordEntries.entrySet()) {
          final ORecord<?> record=entry.getValue().record.getRecord();
          if (record instanceof ODocument) {
            ODocument doc=(ODocument)record;
            if (!lockedIndexes.contains(index.getInternal()) && doc.getSchemaClass() != null && index.getDefinition() != null && doc.getSchemaClass().isSubClassOf(index.getDefinition().getClassName())) {
              index.getInternal().acquireModificationLock();
              lockedIndexes.add((OIndexMVRBTreeAbstract<?>)index.getInternal());
            }
          }
        }
      }
      for (      OIndexMVRBTreeAbstract<?> index : lockedIndexes)       index.acquireExclusiveLock();
      database.getStorage().callInLock(new Callable<Void>(){
        public Void call() throws Exception {
          database.getStorage().commit(OTransactionOptimistic.this);
          final ODocument indexEntries=getIndexChanges();
          if (indexEntries != null) {
            for (            Entry<String,Object> indexEntry : indexEntries) {
              final OIndex<?> index=database.getMetadata().getIndexManager().getIndexInternal(indexEntry.getKey());
              index.commit((ODocument)indexEntry.getValue());
            }
          }
          return null;
        }
      }
,true);
    }
  finally {
      if (lockedIndexes != null) {
        for (        OIndexMVRBTreeAbstract<?> index : lockedIndexes)         index.releaseExclusiveLock();
        for (        OIndexMVRBTreeAbstract<?> index : lockedIndexes)         index.releaseModificationLock();
      }
    }
  }
}
