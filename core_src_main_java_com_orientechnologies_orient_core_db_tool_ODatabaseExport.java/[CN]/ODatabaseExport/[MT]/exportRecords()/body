{
  long totalRecords=0;
  int level=1;
  listener.onMessage("\nExporting records...");
  writer.beginCollection(level,true,"records");
  int exportedClusters=0;
  int maxClusterId=getMaxClusterId();
  for (int i=0; exportedClusters <= maxClusterId; ++i) {
    String clusterName=database.getClusterNameById(i);
    exportedClusters++;
    final long recordTot;
    if (clusterName != null) {
      if (includeClusters != null) {
        if (!includeClusters.contains(clusterName))         continue;
      }
 else       if (excludeClusters != null) {
        if (excludeClusters.contains(clusterName))         continue;
      }
      if (excludeClusters != null && excludeClusters.contains(clusterName))       continue;
      recordTot=database.countClusterElements(clusterName);
    }
 else     recordTot=0;
    listener.onMessage("\n- Cluster " + (clusterName != null ? "'" + clusterName + "'" : "NULL") + " (id="+ i+ ")...");
    long recordNum=0;
    if (clusterName != null) {
      ORecordInternal<?> rec=null;
      try {
        for (ORecordIteratorCluster<ORecordInternal<?>> it=database.browseCluster(clusterName); it.hasNext(); ) {
          rec=it.next();
          if (rec instanceof ODocument) {
            ODocument doc=(ODocument)rec;
            if (includeClasses != null) {
              if (!includeClasses.contains(doc.getClassName()))               continue;
            }
 else             if (excludeClasses != null) {
              if (excludeClasses.contains(doc.getClassName()))               continue;
            }
          }
          exportRecord(recordTot,recordNum++,rec);
        }
      }
 catch (      IOException e) {
        OLogManager.instance().error(this,"\nError on exporting record %s because of I/O problems",e,rec.getIdentity());
        throw e;
      }
catch (      OIOException e) {
        OLogManager.instance().error(this,"\nError on exporting record %s because of I/O problems",e,rec.getIdentity());
        throw e;
      }
catch (      Throwable t) {
        if (rec != null) {
          final byte[] buffer=rec.toStream();
          OLogManager.instance().error(this,"\nError on exporting record %s. It seems corrupted; size: %d bytes, raw content (as string):\n==========\n%s\n==========",t,rec.getIdentity(),buffer.length,new String(buffer));
        }
      }
    }
    listener.onMessage("OK (records=" + recordTot + ")");
    totalRecords+=recordTot;
  }
  writer.endCollection(level,true);
  listener.onMessage("\n\nDone. Exported " + totalRecords + " records\n");
  return totalRecords;
}
