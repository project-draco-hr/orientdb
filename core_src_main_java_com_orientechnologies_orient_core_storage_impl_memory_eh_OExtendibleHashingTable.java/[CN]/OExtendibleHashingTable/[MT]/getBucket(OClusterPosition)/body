{
  final long hash=key.longValueHigh();
  int localNodeDepth=nodesMetadata[0].getNodeLocalDepth();
  int nodeDepth=localNodeDepth;
  NodePath parentNode=null;
  int nodeIndex=0;
  int offset=0;
  int index=(int)((hash >>> (64 - nodeDepth)) & (levelMask >>> (maxLevelDepth - localNodeDepth)));
  NodePath currentNode=new NodePath(parentNode,0,index,0,localNodeDepth,nodeDepth);
  do {
    final long position=hashTree[nodeIndex][index + offset];
    if (position >= 0)     return currentNode;
    nodeIndex=(int)((position & Long.MAX_VALUE) >>> 8);
    offset=(int)(position & 0xFF);
    localNodeDepth=nodesMetadata[nodeIndex].getNodeLocalDepth();
    nodeDepth+=localNodeDepth;
    index=(int)((hash >>> (64 - nodeDepth)) & (levelMask >>> (maxLevelDepth - localNodeDepth)));
    parentNode=currentNode;
    currentNode=new NodePath(parentNode,offset,index,nodeIndex,localNodeDepth,nodeDepth);
  }
 while (nodeDepth <= 64);
  throw new IllegalStateException("Extendible hashing tree in corrupted state.");
}
