{
  super.begin();
  try {
    setUsingLog(channel.readByte() == 1);
    byte lastTxStatus;
    for (lastTxStatus=channel.readByte(); lastTxStatus == 1; lastTxStatus=channel.readByte()) {
      final byte recordStatus=channel.readByte();
      final ORecordId rid=channel.readRID();
      final OTransactionEntryProxy entry=new OTransactionEntryProxy(channel.readByte());
      entry.type=recordStatus;
switch (entry.type) {
case ORecordOperation.CREATED:
        entry.getRecord().fill(rid,0,channel.readBytes(),true);
      createdRecords.put(rid.copy(),entry.getRecord());
    break;
case ORecordOperation.UPDATED:
  entry.getRecord().fill(rid,channel.readInt(),channel.readBytes(),true);
updatedRecords.put(rid,entry.getRecord());
break;
case ORecordOperation.DELETED:
entry.getRecord().fill(rid,channel.readInt(),null,false);
break;
default :
throw new OTransactionException("Unrecognized tx command: " + entry.type);
}
recordEntries.put((ORecordId)entry.getRecord().getIdentity(),entry);
}
if (lastTxStatus == -1) throw new OTransactionException("Transaction aborted by the client");
remoteIndexEntries=new ODocument(channel.readBytes());
for (ORecord<?> record : createdRecords.values()) unmarshallRecord(record);
for (ORecord<?> record : updatedRecords.values()) unmarshallRecord(record);
}
 catch (IOException e) {
rollback();
throw new OSerializationException("Cannot read transaction record from the network. Transaction aborted",e);
}
}
