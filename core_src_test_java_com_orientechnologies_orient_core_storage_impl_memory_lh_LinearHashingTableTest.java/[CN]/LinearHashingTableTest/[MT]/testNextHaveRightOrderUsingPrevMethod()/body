{
  OLinearHashingTable<OClusterPosition,OPhysicalPosition> linearHashingTable;
  MersenneTwisterFast random;
  List<Long> keys=new ArrayList<Long>();
  long i=0;
  while (i < MAX_SEED) {
    linearHashingTable=new OLinearHashingTable<OClusterPosition,OPhysicalPosition>();
    random=new MersenneTwisterFast(i);
    keys.clear();
    while (keys.size() < KEYS_COUNT) {
      long key=random.nextLong(Long.MAX_VALUE);
      OPhysicalPosition position=new OPhysicalPosition(new OClusterPositionLong(key));
      if (linearHashingTable.put(position)) {
        keys.add(key);
        Assert.assertTrue(linearHashingTable.contains(position.clusterPosition),"key " + key);
      }
    }
    Collections.sort(keys,new Comparator<Long>(){
      public int compare(      Long o1,      Long o2){
        return -o1.compareTo(o2);
      }
    }
);
    for (    Long key : keys) {
      OLinearHashingTable.Entry<OClusterPosition,OPhysicalPosition>[] prevRecords=linearHashingTable.lowerEntries(new OClusterPositionLong(key + 1));
      OClusterPosition lhKey=prevRecords[prevRecords.length - 1].key;
      Assert.assertEquals(new OClusterPositionLong(key),lhKey,"" + key);
    }
    for (int j=0, keysSize=keys.size() - 1; j < keysSize; j++) {
      Long key=keys.get(j);
      OLinearHashingTable.Entry<OClusterPosition,OPhysicalPosition>[] prevRecords=linearHashingTable.lowerEntries(new OClusterPositionLong(key));
      OClusterPosition lhKey=prevRecords[prevRecords.length - 1].key;
      Assert.assertEquals(new OClusterPositionLong(keys.get(j + 1)),lhKey,"" + key);
    }
    i++;
  }
}
