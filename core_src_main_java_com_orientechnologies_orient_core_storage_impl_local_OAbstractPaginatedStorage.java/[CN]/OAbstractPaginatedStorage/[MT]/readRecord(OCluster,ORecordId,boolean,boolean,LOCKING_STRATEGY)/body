{
  checkOpeness();
  if (!rid.isPersistent())   throw new IllegalArgumentException("Cannot read record " + rid + " since the position is invalid in database '"+ name+ '\'');
  final long timer=Orient.instance().getProfiler().startChrono();
  clusterSegment.getExternalModificationLock().requestModificationLock();
  try {
    try {
switch (iLockingStrategy) {
case DEFAULT:
case KEEP_SHARED_LOCK:
        rid.lock(false);
      break;
case NONE:
    break;
case KEEP_EXCLUSIVE_LOCK:
  rid.lock(true);
}
ORawBuffer buff;
if (atomicLock) lock.acquireSharedLock();
try {
buff=clusterSegment.readRecord(rid.clusterPosition);
}
  finally {
if (atomicLock) lock.releaseSharedLock();
}
switch (iLockingStrategy) {
case DEFAULT:
rid.unlock();
break;
case KEEP_EXCLUSIVE_LOCK:
case NONE:
case KEEP_SHARED_LOCK:
break;
}
return buff;
}
 catch (IOException e) {
OLogManager.instance().error(this,"Error on reading record " + rid + " (cluster: "+ clusterSegment+ ')',e);
rid.unlock();
return null;
}
catch (RuntimeException e) {
rid.unlock();
throw e;
}
}
  finally {
clusterSegment.getExternalModificationLock().releaseModificationLock();
Orient.instance().getProfiler().stopChrono(PROFILER_READ_RECORD,"Read a record from database",timer,"db.*.readRecord");
}
}
