{
  this.maxRecordsCacheSize=maxRecordsCacheSize;
  this.commitDelay=commitDelay;
  this.maxSegmentSize=maxSegmentSize;
  this.maxLogSize=maxLogSize;
  this.paginatedStorage=storage;
  try {
    this.walLocation=new File(calculateWalPath(paginatedStorage));
    File[] walFiles=this.walLocation.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File dir,      String name){
        return validateName(name);
      }
    }
);
    boolean errorsWereFound=false;
    if (walFiles.length == 0) {
      LogSegment logSegment=new LogSegment(new File(this.walLocation,getSegmentName(0)),maxRecordsCacheSize);
      logSegment.open();
      logSegments.add(logSegment);
      logSize=0;
      flushedLsn=null;
    }
 else {
      for (      File walFile : walFiles) {
        LogSegment logSegment=new LogSegment(walFile,maxRecordsCacheSize);
        boolean checkError=logSegment.open();
        errorsWereFound=errorsWereFound || checkError;
        logSegments.add(logSegment);
        logSize+=logSegment.filledUpTo();
      }
      Collections.sort(logSegments);
      flushedLsn=readFlushedLSN();
    }
    masterRecordFile=new File(walLocation,paginatedStorage.getName() + ".wmr");
    masterRecordLSNHolder=new RandomAccessFile(masterRecordFile,"rwd");
    if (masterRecordLSNHolder.length() > 0) {
      firstMasterRecord=readMasterRecord(paginatedStorage.getName(),0);
      secondMasterRecord=readMasterRecord(paginatedStorage.getName(),1);
      if (firstMasterRecord == null) {
        useFirstMasterRecord=true;
        lastCheckpoint=secondMasterRecord;
      }
 else       if (secondMasterRecord == null) {
        useFirstMasterRecord=false;
        lastCheckpoint=firstMasterRecord;
      }
 else {
        if (firstMasterRecord.compareTo(secondMasterRecord) >= 0) {
          lastCheckpoint=firstMasterRecord;
          useFirstMasterRecord=false;
        }
 else {
          lastCheckpoint=secondMasterRecord;
          useFirstMasterRecord=true;
        }
      }
    }
    if (errorsWereFound)     fixMasterRecords();
    if (commitDelay > 0)     commitExecutor.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        try {
          flush();
        }
 catch (        Throwable e) {
          OLogManager.instance().error(this,"Error during WAL background flush",e);
        }
      }
    }
,commitDelay,commitDelay,TimeUnit.MILLISECONDS);
  }
 catch (  FileNotFoundException e) {
    OLogManager.instance().error(this,"Error during file initialization for storage %s",e,paginatedStorage.getName());
    throw new IllegalStateException("Error during file initialization for storage " + paginatedStorage.getName(),e);
  }
}
