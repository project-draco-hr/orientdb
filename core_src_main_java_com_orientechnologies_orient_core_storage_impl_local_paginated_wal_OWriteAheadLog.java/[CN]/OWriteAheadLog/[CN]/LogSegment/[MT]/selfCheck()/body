{
  if (!pagesCache.isEmpty())   throw new IllegalStateException("WAL cache is not empty, we can not verify WAL after it was started to be used");
synchronized (rndFile) {
    long pagesCount=rndFile.length() / OWALPage.PAGE_SIZE;
    if (rndFile.length() % OWALPage.PAGE_SIZE > 0) {
      OLogManager.instance().error(this,"Last WAL page was written partially, auto fix.");
      rndFile.setLength(OWALPage.PAGE_SIZE * pagesCount);
    }
    long currentPage=pagesCount - 1;
    CRC32 crc32=new CRC32();
    while (currentPage >= 0) {
      crc32.reset();
      byte[] content=new byte[OWALPage.PAGE_SIZE];
      rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
      rndFile.readFully(content);
      int pageCRC=OIntegerSerializer.INSTANCE.deserializeNative(content,0);
      crc32.update(content,OIntegerSerializer.INT_SIZE,OWALPage.PAGE_SIZE - OIntegerSerializer.INT_SIZE);
      int calculatedCRC=(int)crc32.getValue();
      if (pageCRC != calculatedCRC) {
        OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage);
        currentPage--;
        pagesCount=currentPage + 1;
        rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
      }
 else {
        long pointer=directMemory.allocate(content);
        try {
          OWALPage page=new OWALPage(pointer,false);
          int pageOffset=findLastRecord(page,false);
          if (pageOffset >= 0) {
            if (page.mergeWithNextPage(pageOffset)) {
              page.truncateTill(pageOffset);
              rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
              content=directMemory.get(pointer,OWALPage.PAGE_SIZE);
              rndFile.write(content);
              if (page.isEmpty()) {
                OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage);
                currentPage--;
                pagesCount=currentPage + 1;
                rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
              }
 else               break;
            }
 else             break;
          }
 else           break;
        }
  finally {
          directMemory.free(pointer);
        }
      }
    }
    rndFile.getFD().sync();
  }
}
