{
  if (!iRid.isPersistent())   throw new IllegalArgumentException("Cannot read record " + iRid + " since the position is invalid in database '"+ name+ '\'');
  final long timer=Orient.instance().getProfiler().startChrono();
  if (iAtomicLock)   lock.acquireSharedLock();
  try {
switch (iLockingStrategy) {
case DEFAULT:
case KEEP_SHARED_LOCK:
      lockManager.acquireLock(Thread.currentThread(),iRid,LOCK.SHARED);
    break;
case NONE:
  break;
case KEEP_EXCLUSIVE_LOCK:
throw new IllegalStateException("Exclusive locking not supported on read() in 'local' storage. Use plocal instead.");
}
try {
final OPhysicalPosition ppos=iClusterSegment.getPhysicalPosition(new OPhysicalPosition(iRid.clusterPosition));
if (ppos != null && loadTombstones && ppos.recordVersion.isTombstone()) return new ORawBuffer(null,ppos.recordVersion,ppos.recordType);
if (ppos == null || !checkForRecordValidity(ppos)) return null;
final ODataLocal data=getDataSegmentById(ppos.dataSegmentId);
return new ORawBuffer(data.getRecord(ppos.dataSegmentPos),ppos.recordVersion,ppos.recordType);
}
  finally {
switch (iLockingStrategy) {
case DEFAULT:
lockManager.releaseLock(Thread.currentThread(),iRid,OLockManager.LOCK.SHARED);
break;
case NONE:
case KEEP_SHARED_LOCK:
case KEEP_EXCLUSIVE_LOCK:
break;
}
}
}
 catch (IOException e) {
OLogManager.instance().error(this,"Error on reading record " + iRid + " (cluster: "+ iClusterSegment+ ')',e);
return null;
}
 finally {
if (iAtomicLock) lock.releaseSharedLock();
Orient.instance().getProfiler().stopChrono(PROFILER_READ_RECORD,"Read a record from database",timer,"db.*.readRecord");
}
}
