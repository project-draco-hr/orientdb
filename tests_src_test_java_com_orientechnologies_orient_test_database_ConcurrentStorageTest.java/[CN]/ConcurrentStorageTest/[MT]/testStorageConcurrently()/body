{
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicBoolean test=new AtomicBoolean(true);
  final Deque<ODocument> data=new ConcurrentLinkedDeque<ODocument>();
  final List<Thread> testThreads=new ArrayList<Thread>();
  testThreads.add(new Thread(new Runnable(){
    @Override public void run(){
      final ODatabaseDocumentTx connection=createConnection();
      try {
        final int testClusterId=connection.getClusterIdByName("test_class");
        assertTrue(testClusterId != -1);
        latch.await();
        for (int i=0; i < 1000; i++) {
          if (url.startsWith("remote")) {
            new OServerAdmin(url).connect("admin","admin").freezeCluster(testClusterId);
          }
 else {
            connection.freezeCluster(testClusterId);
          }
          System.out.println("frozen " + System.currentTimeMillis());
          final long startRecords=countInsertedRecords(connection);
          TimeUnit.MILLISECONDS.sleep(500);
          final long endRecords=countInsertedRecords(connection);
          assertEquals(startRecords,endRecords);
          System.out.println("released " + System.currentTimeMillis());
          if (url.startsWith("remote")) {
            new OServerAdmin(url).connect("admin","admin").releaseCluster(testClusterId);
          }
 else {
            connection.releaseCluster(testClusterId);
          }
          TimeUnit.MILLISECONDS.sleep(500);
        }
      }
 catch (      Throwable e) {
        throw new RuntimeException(e);
      }
 finally {
        test.set(false);
        connection.close();
      }
    }
  }
));
  for (int i=0; i < 5; i++) {
    testThreads.add(new Thread(new Runnable(){
      @Override public void run(){
        final ODatabaseDocumentTx connection=createConnection();
        try {
          final Random random=new Random();
          final String name=Thread.currentThread().getName();
          latch.await();
          while (test.get()) {
            final long time=System.currentTimeMillis();
            ODocument doc=connection.newInstance("test_class").field("thread",name).field("time",time);
            doc=connection.save(doc);
            if (random.nextBoolean())             data.addFirst(doc);
 else             data.addLast(doc);
            System.out.println("create " + name + " "+ time);
            TimeUnit.MILLISECONDS.sleep(25);
          }
        }
 catch (        Throwable e) {
          test.set(false);
          throw new RuntimeException(e);
        }
 finally {
          test.set(false);
          connection.close();
        }
      }
    }
));
  }
  testThreads.add(new Thread(new Runnable(){
    @Override public void run(){
      final ODatabaseDocumentTx connection=createConnection();
      try {
        final Random random=new Random();
        final String name=Thread.currentThread().getName();
        latch.await();
        while (test.get()) {
          final long time=System.currentTimeMillis();
          ODocument doc;
          if (random.nextBoolean())           doc=data.pollFirst();
 else           doc=data.pollLast();
          if (doc != null) {
            connection.delete(doc);
            System.out.println("delete " + name + " "+ time);
          }
          TimeUnit.MILLISECONDS.sleep(25);
        }
      }
 catch (      Throwable e) {
        test.set(false);
        throw new RuntimeException(e);
      }
 finally {
        test.set(false);
        connection.close();
      }
    }
  }
));
  for (int i=0; i < 5; i++) {
    testThreads.add(new Thread(new Runnable(){
      @Override public void run(){
        final ODatabaseDocumentTx connection=createConnection();
        try {
          final String name=Thread.currentThread().getName();
          latch.await();
          while (test.get()) {
            final long time=System.currentTimeMillis();
            for (            ODocument doc : data) {
              connection.load(doc);
              System.out.println("read " + name + " "+ time);
              TimeUnit.MILLISECONDS.sleep(25);
            }
          }
        }
 catch (        Throwable e) {
          test.set(false);
          throw new RuntimeException(e);
        }
 finally {
          test.set(false);
          connection.close();
        }
      }
    }
));
  }
  for (  Thread testThread : testThreads) {
    testThread.start();
  }
  latch.countDown();
  for (  Thread testThread : testThreads) {
    testThread.join();
  }
}
