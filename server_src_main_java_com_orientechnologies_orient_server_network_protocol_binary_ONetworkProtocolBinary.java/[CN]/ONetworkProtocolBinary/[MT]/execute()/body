{
  commandType=-1;
  long clock=0;
  try {
    commandType=channel.readByte();
    clock=System.currentTimeMillis();
switch (commandType) {
case OChannelBinaryProtocol.CONNECT:
{
        user=channel.readString();
        passwd=channel.readString();
        sendOk();
        channel.writeString(connection.id);
        break;
      }
case OChannelBinaryProtocol.DB_OPEN:
{
      String dbURL=channel.readString();
      String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
      user=channel.readString();
      passwd=channel.readString();
      connection.database=(ODatabaseDocumentTx)OServerMain.server().getMemoryDatabases().get(dbName);
      if (connection.database == null)       connection.database=new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));
      if (connection.database.isClosed())       if (connection.database.getStorage() instanceof OStorageMemory)       connection.database.create();
 else       connection.database.open(user,passwd);
      underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
      if (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user,passwd)) {
        sendError(new OSecurityAccessException("Access denied to database '" + connection.database.getName() + "' for user: "+ user));
      }
 else {
        sendOk();
        channel.writeString(connection.id);
        channel.writeInt(connection.database.getClusterNames().size());
        for (        OCluster c : ((OStorage)connection.database.getStorage()).getClusters()) {
          channel.writeString(c.getName());
          channel.writeInt(c.getId());
        }
      }
      break;
    }
case OChannelBinaryProtocol.DB_CREATE:
{
    String dbName=channel.readString();
    String storageMode=channel.readString();
    final String path;
    final String realPath;
    if (storageMode.equals(OEngineLocal.NAME)) {
      if (OServerMain.server().existsStoragePath(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":${ORIENT_HOME}/databases/" + dbName+ "/"+ dbName;
      realPath=OSystemVariableResolver.resolveSystemVariables(path);
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      if (OServerMain.server().getMemoryDatabases().containsKey(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":" + dbName;
      realPath=path;
    }
 else     throw new IllegalArgumentException("Can't create databse: storage mode '" + storageMode + "' is not supported.");
    connection.database=new ODatabaseDocumentTx(realPath);
    connection.database.create();
    if (storageMode.equals(OEngineLocal.NAME)) {
      connection.database.close();
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      OServerMain.server().getMemoryDatabases().put(dbName,connection.database);
    }
    underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
    sendOk();
    break;
  }
case OChannelBinaryProtocol.DB_CLOSE:
break;
case OChannelBinaryProtocol.DB_EXIST:
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk();
break;
case OChannelBinaryProtocol.CLUSTER_COUNT:
int[] ids=new int[channel.readShort()];
for (int i=0; i < ids.length; ++i) ids[i]=channel.readShort();
long count=connection.database.countClusterElements(ids);
sendOk();
channel.writeLong(count);
break;
case OChannelBinaryProtocol.CLUSTER_PHYSICAL_ADD:
{
final int num=connection.database.addPhysicalCluster(channel.readString(),channel.readString(),channel.readInt());
sendOk();
channel.writeShort((short)num);
break;
}
case OChannelBinaryProtocol.CLUSTER_LOGICAL_ADD:
{
final int num=connection.database.addLogicalCluster(channel.readString(),connection.database.getDefaultClusterId());
sendOk();
OClusterLogical cluster=(OClusterLogical)connection.database.getStorage().getClusterById(num);
channel.writeShort((short)num);
channel.writeString(cluster.getRID().toString());
break;
}
case OChannelBinaryProtocol.RECORD_LOAD:
final ORawBuffer record=underlyingDatabase.read(channel.readShort(),channel.readLong());
sendOk();
if (record != null) {
channel.writeByte((byte)1);
channel.writeBytes(record.buffer);
channel.writeInt(record.version);
channel.writeByte(record.recordType);
}
 else channel.writeByte((byte)0);
break;
case OChannelBinaryProtocol.RECORD_CREATE:
final long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1,channel.readByte());
sendOk();
channel.writeLong(location);
break;
case OChannelBinaryProtocol.RECORD_UPDATE:
final int clusterId=channel.readShort();
final long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt(),channel.readByte());
if (clusterId == connection.database.getMetadata().getSchemaClusterId()) if (position == OSchema.CLASSES_RECORD_NUM) connection.database.getMetadata().loadSchema();
 else if (position == OSecurity.SECURITY_RECORD_NUM) connection.database.getMetadata().loadSecurity();
sendOk();
channel.writeInt((int)newVersion);
break;
case OChannelBinaryProtocol.RECORD_DELETE:
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk();
break;
case OChannelBinaryProtocol.COUNT:
{
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
sendOk();
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.COMMAND:
{
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestAbstract command=(OCommandRequestAbstract)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
if (asynch) {
final StringBuilder empty=new StringBuilder();
command.setResultListener(new OCommandResultListener(){
private int items=0;
public boolean result(final Object iRecord){
if (items == 0) try {
sendOk();
empty.append("-");
}
 catch (IOException e1) {
}
if (command.getLimit() > -1 && items > command.getLimit()) return false;
try {
channel.writeByte((byte)1);
items++;
writeRecord((ORecordInternal<?>)iRecord);
channel.flush();
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
((OCommandRequestInternal<ODatabaseRecord<?>>)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk();
}
 catch (IOException e1) {
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal<ODatabaseRecord<?>>)connection.database.command(command)).execute();
sendOk();
if (result == null) {
channel.writeByte((byte)'n');
channel.writeBytes(null);
}
 else if (result instanceof ORecord<?>) {
channel.writeByte((byte)'r');
writeRecord((ORecordInternal<?>)result);
}
 else {
channel.writeByte((byte)'a');
channel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(result));
}
}
break;
}
case OChannelBinaryProtocol.DICTIONARY_LOOKUP:
{
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().get(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_PUT:
{
String key=channel.readString();
ORecordInternal<?> value=ORecordFactory.getRecord(channel.readByte());
final ORecordId rid=new ORecordId(channel.readString());
value.setIdentity(rid.clusterId,rid.clusterPosition);
value.setDatabase(connection.database);
value=connection.database.getDictionary().putRecord(key,value);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_REMOVE:
{
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().remove(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_SIZE:
{
sendOk();
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.DICTIONARY_KEYS:
{
sendOk();
channel.writeCollectionString(connection.database.getDictionary().keySet());
break;
}
case OChannelBinaryProtocol.TX_COMMIT:
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),new OTransactionOptimisticProxy((ODatabaseRecordTx)connection.database.getUnderlying(),channel));
sendOk();
break;
default :
OLogManager.instance().error(this,"Request not supported. Code: " + commandType);
channel.clearInput();
sendError(null);
}
}
 catch (EOFException eof) {
shutdown();
}
catch (SocketException e) {
shutdown();
}
catch (OException e) {
sendError(e);
}
catch (Throwable t) {
OLogManager.instance().error(this,"Error on executing request",t);
sendError(t);
}
 finally {
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
OSerializationThreadLocal.INSTANCE.get().clear();
lastCommandExecutionTime=System.currentTimeMillis() - clock;
totalCommandExecutionTime+=lastCommandExecutionTime;
lastCommandType=commandType;
}
}
