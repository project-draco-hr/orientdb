{
switch (lastRequestType) {
case OChannelBinaryProtocol.REQUEST_SHUTDOWN:
{
      data.commandInfo="Shutdowning";
      OLogManager.instance().info(this,"Received shutdown command from the remote client %s:%d",channel.socket.getInetAddress(),channel.socket.getPort());
      user=channel.readString();
      passwd=channel.readString();
      if (OServerMain.server().authenticate(user,passwd,"shutdown")) {
        OLogManager.instance().info(this,"Remote client %s:%d authenticated. Starting shutdown of server...",channel.socket.getInetAddress(),channel.socket.getPort());
        sendOk(lastClientTxId);
        channel.flush();
        channel.close();
        OServerMain.server().shutdown();
        System.exit(0);
        return;
      }
      OLogManager.instance().error(this,"Authentication error of remote client %s:%d: shutdown is aborted.",channel.socket.getInetAddress(),channel.socket.getPort());
      sendError(lastClientTxId,new OSecurityAccessException("Invalid user/password to shutdown the server"));
      break;
    }
case OChannelBinaryProtocol.REQUEST_CONNECT:
{
    data.commandInfo="Connect";
    serverLogin(channel.readString(),channel.readString());
    sendOk(lastClientTxId);
    channel.writeInt(connection.id);
    break;
  }
case OChannelBinaryProtocol.REQUEST_DB_OPEN:
{
  data.commandInfo="Open database";
  String dbURL=channel.readString();
  String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
  user=channel.readString();
  passwd=channel.readString();
  connection.database=openDatabase(dbName,user,passwd);
  if (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user,passwd)) {
    sendError(lastClientTxId,new OSecurityAccessException(connection.database.getName(),"Access denied to database '" + connection.database.getName() + "' for user: "+ user));
  }
 else {
    sendOk(lastClientTxId);
    channel.writeInt(connection.id);
    channel.writeInt(connection.database.getClusterNames().size());
    for (    OCluster c : (connection.database.getStorage()).getClusters()) {
      if (c != null) {
        channel.writeString(c.getName());
        channel.writeInt(c.getId());
        channel.writeString(c.getType());
      }
    }
    if (getClass().equals(ONetworkProtocolBinary.class))     channel.writeBytes(null);
  }
  break;
}
case OChannelBinaryProtocol.REQUEST_DB_CREATE:
{
data.commandInfo="Create database";
String dbName=channel.readString();
String storageMode=channel.readString();
checkServerAccess("database.create");
connection.database=getDatabaseInstance(dbName,storageMode);
createDatabase(connection.database);
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_DB_CLOSE:
data.commandInfo="Close Database";
if (connection.database != null) connection.database.close();
sendShutdown();
break;
case OChannelBinaryProtocol.REQUEST_DB_EXIST:
{
data.commandInfo="Exists database";
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_COUNT:
{
data.commandInfo="Count cluster elements";
int[] clusterIds=new int[channel.readShort()];
for (int i=0; i < clusterIds.length; ++i) clusterIds[i]=channel.readShort();
long count=connection.database.countClusterElements(clusterIds);
sendOk(lastClientTxId);
channel.writeLong(count);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_DATARANGE:
{
data.commandInfo="Get the begin/end range of data in cluster";
long[] pos=connection.database.getStorage().getClusterDataRange(channel.readShort());
sendOk(lastClientTxId);
channel.writeLong(pos[0]);
channel.writeLong(pos[1]);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_ADD:
{
data.commandInfo="Add cluster";
final String type=channel.readString();
final String name=channel.readString();
final int num;
OStorage.CLUSTER_TYPE t=OStorage.CLUSTER_TYPE.valueOf(type);
switch (t) {
case PHYSICAL:
num=connection.database.addPhysicalCluster(name,channel.readString(),channel.readInt());
break;
case MEMORY:
num=connection.database.getStorage().addCluster(name,t);
break;
case LOGICAL:
num=connection.database.addLogicalCluster(name,channel.readInt());
break;
default :
throw new IllegalArgumentException("Cluster type " + type + " is not supported");
}
sendOk(lastClientTxId);
channel.writeShort((short)num);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_REMOVE:
{
data.commandInfo="remove cluster";
final int id=channel.readShort();
boolean result=connection.database.getStorage().removeCluster(id);
sendOk(lastClientTxId);
channel.writeByte((byte)(result ? 1 : 0));
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_LOAD:
{
data.commandInfo="Load record";
final short clusterId=channel.readShort();
final long clusterPosition=channel.readLong();
final String fetchPlanString=channel.readString();
final ORawBuffer buffer=underlyingDatabase.read(clusterId,clusterPosition,null);
sendOk(lastClientTxId);
if (buffer != null) {
channel.writeByte((byte)1);
channel.writeBytes(buffer.buffer);
channel.writeInt(buffer.version);
channel.writeByte(buffer.recordType);
if (fetchPlanString.length() > 0) {
final ORecordInternal<?> record=ORecordFactory.newInstance(buffer.recordType);
record.fill(connection.database,clusterId,clusterPosition,buffer.version);
record.fromStream(buffer.buffer);
if (record instanceof ODocument) {
final Map<String,Integer> fetchPlan=OFetchHelper.buildFetchPlan(fetchPlanString);
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
OFetchHelper.fetch((ODocument)record,record,fetchPlan,null,0,-1,new OFetchListener(){
public int size(){
return recordsToSend.size();
}
public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
}
channel.writeByte((byte)0);
}
 else channel.writeByte((byte)0);
}
 else channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_CREATE:
data.commandInfo="Create record";
final long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1,channel.readByte());
sendOk(lastClientTxId);
channel.writeLong(location);
break;
case OChannelBinaryProtocol.REQUEST_RECORD_UPDATE:
data.commandInfo="Update record";
final int clusterId=channel.readShort();
final long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt(),channel.readByte());
if (connection.database.getMetadata().getSchema().getDocument().getIdentity().getClusterId() == clusterId && connection.database.getMetadata().getSchema().getDocument().getIdentity().getClusterPosition() == position) connection.database.getMetadata().loadSchema();
 else if (((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterId() == clusterId && ((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterPosition() == position) ((ODictionaryLocal<?>)connection.database.getDictionary()).load();
sendOk(lastClientTxId);
channel.writeInt((int)newVersion);
break;
case OChannelBinaryProtocol.REQUEST_RECORD_DELETE:
data.commandInfo="Delete record";
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk(lastClientTxId);
channel.writeByte((byte)1);
break;
case OChannelBinaryProtocol.REQUEST_COUNT:
{
data.commandInfo="Count cluster records";
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
sendOk(lastClientTxId);
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.REQUEST_COMMAND:
{
data.commandInfo="Execute remote command";
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(connection.database,channel.readBytes());
final OQuery<?> query=(OQuery<?>)(command instanceof OQuery<?> ? command : null);
data.commandDetail=command.getText();
if (asynch) {
final StringBuilder empty=new StringBuilder();
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
final int txId=lastClientTxId;
final Map<String,Integer> fetchPlan=query != null ? OFetchHelper.buildFetchPlan(query.getFetchPlan()) : null;
command.setResultListener(new OCommandResultListener(){
public boolean result(final Object iRecord){
if (empty.length() == 0) try {
sendOk(txId);
empty.append("-");
}
 catch (IOException e1) {
}
try {
channel.writeByte((byte)1);
writeRecord((ORecordInternal<?>)iRecord);
if (fetchPlan != null && iRecord instanceof ODocument) {
OFetchHelper.fetch((ODocument)iRecord,iRecord,fetchPlan,null,0,-1,new OFetchListener(){
public int size(){
return recordsToSend.size();
}
public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
}
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
((OCommandRequestInternal)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk(lastClientTxId);
}
 catch (IOException e1) {
}
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal)connection.database.command(command)).execute();
sendOk(lastClientTxId);
if (result == null) {
channel.writeByte((byte)'n');
channel.writeBytes(null);
}
 else if (result instanceof ORecord<?>) {
channel.writeByte((byte)'r');
writeRecord((ORecordInternal<?>)result);
}
 else {
channel.writeByte((byte)'a');
channel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(connection.database,result));
}
}
break;
}
case OChannelBinaryProtocol.REQUEST_DICTIONARY_LOOKUP:
{
data.commandInfo="Dictionary lookup";
final String key=channel.readString();
final ORecordAbstract<?> value=connection.database.getDictionary().get(key);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(lastClientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.REQUEST_DICTIONARY_PUT:
{
data.commandInfo="Dictionary put";
String key=channel.readString();
ORecordInternal<?> value=ORecordFactory.newInstance(channel.readByte());
final ORecordId rid=channel.readRID();
value.setIdentity(rid);
value.setDatabase(connection.database);
value=connection.database.getDictionary().putRecord(key,value);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(lastClientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.REQUEST_DICTIONARY_REMOVE:
{
data.commandInfo="Dictionary remove";
final String key=channel.readString();
final ORecordInternal<?> value=connection.database.getDictionary().remove(key);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(lastClientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.REQUEST_DICTIONARY_SIZE:
{
data.commandInfo="Dictionary size";
sendOk(lastClientTxId);
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.REQUEST_DICTIONARY_KEYS:
{
data.commandInfo="Dictionary keys";
sendOk(lastClientTxId);
channel.writeCollectionString(connection.database.getDictionary().keySet());
break;
}
case OChannelBinaryProtocol.REQUEST_TX_COMMIT:
{
data.commandInfo="Transaction commit";
final OTransactionOptimisticProxy tx=new OTransactionOptimisticProxy((ODatabaseRecordTx<OTransactionRecordProxy>)connection.database.getUnderlying(),channel);
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),tx);
sendOk(lastClientTxId);
channel.writeInt(tx.getUpdatedRecords().size());
for (Entry<ORecordId,ORecord<?>> entry : tx.getUpdatedRecords().entrySet()) {
channel.writeRID(entry.getKey());
channel.writeInt(entry.getValue().getVersion());
}
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_GET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.get");
final String key=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
String cfgValue=cfg != null ? cfg.getValueAsString() : "";
sendOk(lastClientTxId);
channel.writeString(cfgValue);
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_SET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.set");
final String key=channel.readString();
final String value=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
if (cfg != null) cfg.setValue(value);
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_LIST:
{
data.commandInfo="List config";
checkServerAccess("server.config.get");
sendOk(lastClientTxId);
channel.writeShort((short)OGlobalConfiguration.values().length);
for (OGlobalConfiguration cfg : OGlobalConfiguration.values()) {
channel.writeString(cfg.getKey());
channel.writeString(cfg.getValueAsString() != null ? cfg.getValueAsString() : "");
}
break;
}
default :
data.commandInfo="Command not supported";
OLogManager.instance().error(this,"Request not supported. Code: " + lastRequestType);
channel.clearInput();
sendError(lastClientTxId,new ONetworkProtocolException("Request not supported. Code: " + lastRequestType));
}
}
