{
  resetLastValidBackup();
  if (OScenarioThreadLocal.INSTANCE.get() == RUN_MODE.RUNNING_DISTRIBUTED) {
    wrapped.commit(iTx,callback);
    return null;
  }
  final ODistributedConfiguration dbCfg=dManager.getDatabaseConfiguration(getName());
  final String localNodeName=dManager.getLocalNodeName();
  checkNodeIsMaster(localNodeName,dbCfg);
  try {
    if (!dbCfg.isReplicationActive(null,localNodeName)) {
      ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
        @Override public Object call() throws Exception {
          wrapped.commit(iTx,callback);
          return null;
        }
      }
);
      return null;
    }
    OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.BEGUN);
    final OTxTask txTask=new OTxTask();
    final Set<String> involvedClusters=new HashSet<String>();
    final List<OAbstractRemoteTask> undoTasks=createUndoTasks(iTx);
    Boolean executionModeSynch=dbCfg.isExecutionModeSynchronous(null);
    if (executionModeSynch == null)     executionModeSynch=Boolean.TRUE;
    final boolean exclusiveLock=iTx.hasRecordCreation();
    if (exclusiveLock)     sequentialRIDLock.writeLock().lock();
    final int maxAutoRetry=OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_MAX_AUTORETRY.getValueAsInteger();
    final int autoRetryDelay=OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_AUTORETRY_DELAY.getValueAsInteger();
    try {
      final ODistributedDatabase ddb=dManager.getMessageService().getDatabase(getName());
      final ODistributedRequestId localReqId=new ODistributedRequestId(dManager.getLocalNodeId(),dManager.getNextMessageIdCounter());
      for (      ORecordOperation op : iTx.getAllRecordEntries()) {
        boolean locked=false;
        for (int retry=1; retry <= maxAutoRetry; ++retry) {
          if (ddb.lockRecord(op.record,localReqId)) {
            locked=true;
            break;
          }
          if (autoRetryDelay > -1)           Thread.sleep(autoRetryDelay);
        }
        if (!locked)         throw new ODistributedRecordLockedException(op.record.getIdentity());
      }
      try {
        final List<ORecordOperation> uResult=(List<ORecordOperation>)ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
          @Override public Object call() throws Exception {
            return wrapped.commit(iTx,callback);
          }
        }
);
        for (        ORecordOperation ent : iTx.getAllRecordEntries()) {
          ORecordInternal.getDirtyManager(ent.getRecord()).clear();
        }
        final OTxTaskResult localResult=new OTxTaskResult();
        for (        ORecordOperation op : uResult) {
          final OAbstractRecordReplicatedTask task;
          final ORecord record=op.getRecord();
switch (op.type) {
case ORecordOperation.CREATED:
            task=new OCreateRecordTask(record);
          localResult.results.add(new OPlaceholder((ORecordId)record.getIdentity(),record.getVersion()));
        undoTasks.add(new ODeleteRecordTask(record));
      break;
case ORecordOperation.UPDATED:
    task=new OUpdateRecordTask(record);
  localResult.results.add(record.getVersion());
break;
case ORecordOperation.DELETED:
task=new ODeleteRecordTask(record);
localResult.results.add(Boolean.TRUE);
break;
default :
continue;
}
involvedClusters.add(getClusterNameByRID((ORecordId)record.getIdentity()));
txTask.add(task);
}
txTask.setUndoTasks(undoTasks);
OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.COMMITTING);
final Set<String> nodes=dbCfg.getServers(involvedClusters);
nodes.remove(localNodeName);
dManager.getAvailableNodes(nodes,getName());
if (nodes.isEmpty()) return null;
if (executionModeSynch) {
ODistributedResponse lastResult=null;
for (int retry=1; retry <= maxAutoRetry; ++retry) {
lastResult=dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE,localResult);
if (!processCommitResult(localNodeName,iTx,txTask,involvedClusters,uResult,nodes,autoRetryDelay,lastResult.getRequestId(),lastResult.getPayload())) {
continue;
}
return null;
}
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"Distributed transaction retries exceed maximum auto-retries (%d)",maxAutoRetry);
throw (ODistributedRecordLockedException)lastResult.getPayload();
}
if (!nodes.isEmpty()) {
if (executionModeSynch) dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE,localResult);
 else {
final OAsyncReplicationOk onAsyncReplicationOk=OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationOk;
final OAsyncReplicationError onAsyncReplicationError=getAsyncReplicationError();
asynchronousExecution(new OAsynchDistributedOperation(getName(),involvedClusters,nodes,txTask,new OCallable<Object,OPair<ODistributedRequestId,Object>>(){
@Override public Object call(final OPair<ODistributedRequestId,Object> iArgument){
final Object value=iArgument.getValue();
final ODistributedRequestId reqId=iArgument.getKey();
if (value instanceof OTxTaskResult) {
sendTxCompleted(localNodeName,involvedClusters,nodes,reqId,true);
if (onAsyncReplicationOk != null) onAsyncReplicationOk.onAsyncReplicationOk();
return null;
}
 else if (value instanceof Exception) {
try {
final ORemoteTask undo=txTask.getUndoTask(reqId);
if (undo != null) try {
final ODatabaseDocumentTx database=new ODatabaseDocumentTx(getURL());
database.setProperty(ODatabase.OPTIONS.SECURITY.toString(),OSecurityServerUser.class);
database.open("system","system");
try {
  undo.execute(new ODistributedRequestId(),serverInstance,dManager,database);
}
  finally {
  database.close();
}
}
 catch (Exception e) {
ODistributedServerLog.error(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"Async distributed transaction failed, cannot revert local transaction. Current node could have a not aligned database. Remote answer: %s",e,value);
throw OException.wrapException(new OTransactionException("Error on execution async distributed transaction, the database could be inconsistent"),(Exception)value);
}
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"Async distributed transaction failed: %s",value);
sendTxCompleted(localNodeName,involvedClusters,nodes,reqId,false);
if (value instanceof RuntimeException) throw (RuntimeException)value;
 else throw OException.wrapException(new OTransactionException("Error on execution async distributed transaction"),(Exception)value);
}
  finally {
if (onAsyncReplicationError != null) onAsyncReplicationError.onAsyncReplicationError((Throwable)value,0);
}
}
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"Async distributed transaction error, received unknown response type: %s",iArgument);
throw new OTransactionException("Error on committing async distributed transaction, received unknown response type " + iArgument);
}
}
,localResult));
}
}
}
  finally {
for (ORecordOperation op : iTx.getAllRecordEntries()) {
ddb.unlockRecord(op.record);
}
}
}
  finally {
if (exclusiveLock) sequentialRIDLock.writeLock().unlock();
}
}
 catch (OValidationException e) {
throw e;
}
catch (Exception e) {
handleDistributedException("Cannot route TX operation against distributed node",e);
}
return null;
}
