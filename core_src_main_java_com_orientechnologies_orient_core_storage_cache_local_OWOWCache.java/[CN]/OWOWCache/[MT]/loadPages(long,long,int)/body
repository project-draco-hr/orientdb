{
  final int intId=extractFileId(fileId);
  final int totPages=prefetchPages + 1;
  final PagedKey[] pagedKeys=new PagedKey[totPages];
  for (int i=0; i < totPages; ++i)   pagedKeys[i]=new PagedKey(intId,pageIndex + i);
  filesLock.acquireReadLock();
  try {
    lockManager.acquireSharedLocksInBatch(pagedKeys);
    try {
      final OCachePointer[] pagePointers=new OCachePointer[totPages];
      for (int i=0; i < totPages; ++i) {
        final PageGroup pageGroup=writeCachePages.get(pagedKeys[i]);
        if (pageGroup != null) {
          pagePointers[i]=pageGroup.page;
          pagePointers[i].incrementReadersReferrer();
        }
      }
      for (int pageNum=0; pageNum < totPages; ++pageNum) {
        if (pagePointers[pageNum] == null) {
          int lastPointer=pageNum;
          for (int k=pageNum + 1; k < totPages; ++k) {
            if (pagePointers[k] != null)             break;
            lastPointer=k;
          }
          if (pageNum == lastPointer)           pagePointers[pageNum]=cacheFileContent(fileId,intId,pageIndex + pageNum,false);
 else {
            final OCachePointer[] pointers=cacheFileContent(fileId,intId,pageIndex + pageNum,lastPointer - pageNum + 1);
            for (int i=0; i < pointers.length; ++i)             pagePointers[pageNum + i]=pointers[i];
          }
        }
      }
      return pagePointers;
    }
  finally {
      for (int i=0; i < pagedKeys.length; ++i)       lockManager.releaseSharedLock(pagedKeys[i]);
    }
  }
  finally {
    filesLock.releaseReadLock();
  }
}
