{
  if (status == TXSTATUS.ROLLED_BACK || status == TXSTATUS.ROLLBACKING)   throw new ORollbackException("Given transaction was rolled back and cannot be used.");
  status=TXSTATUS.COMMITTING;
  if (!allEntries.isEmpty() || !indexEntries.isEmpty()) {
    if (!OScenarioThreadLocal.INSTANCE.isRunModeDistributed() && !(database.getStorage().getUnderlying() instanceof OAbstractPaginatedStorage))     database.getStorage().commit(this,null);
 else {
      final Map<String,OIndex<?>> indexes=new HashMap<String,OIndex<?>>();
      for (      OIndex<?> index : database.getMetadata().getIndexManager().getIndexes())       indexes.put(index.getName(),index);
      final Runnable callback=new CommitIndexesCallback(indexes);
      final String storageType=database.getStorage().getUnderlying().getType();
      if (storageType.equals(OEngineLocalPaginated.NAME) || storageType.equals(OEngineMemory.NAME))       database.getStorage().commit(OTransactionOptimistic.this,callback);
 else {
        database.getStorage().callInLock(new Callable<Object>(){
          @Override public Object call() throws Exception {
            database.getStorage().commit(OTransactionOptimistic.this,callback);
            return null;
          }
        }
,true);
      }
    }
  }
  close();
  status=TXSTATUS.COMPLETED;
}
