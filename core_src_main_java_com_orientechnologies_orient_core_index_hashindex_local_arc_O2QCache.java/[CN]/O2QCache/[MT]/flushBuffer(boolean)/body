{
  OLockManager.LOCK lock=writeLock ? OLockManager.LOCK.EXCLUSIVE : OLockManager.LOCK.SHARED;
synchronized (syncObject) {
    for (    OCacheEntry entry : am) {
      lockManager.acquireLock(Thread.currentThread(),new FileLockKey(entry.fileId,entry.pageIndex),lock);
      try {
        if (entry.isDirty) {
          flushData(entry.fileId,entry.pageIndex,entry.dataPointer);
          entry.isDirty=false;
        }
      }
  finally {
        lockManager.releaseLock(Thread.currentThread(),new FileLockKey(entry.fileId,entry.pageIndex),lock);
      }
    }
    for (    OCacheEntry entry : a1in) {
      lockManager.acquireLock(Thread.currentThread(),new FileLockKey(entry.fileId,entry.pageIndex),lock);
      try {
        if (entry.isDirty) {
          flushData(entry.fileId,entry.pageIndex,entry.dataPointer);
          entry.isDirty=false;
        }
      }
  finally {
        lockManager.releaseLock(Thread.currentThread(),new FileLockKey(entry.fileId,entry.pageIndex),lock);
      }
    }
    flushEvictedPages();
    for (    OMultiFileSegment multiFileSegment : files.values())     multiFileSegment.synch();
  }
}
