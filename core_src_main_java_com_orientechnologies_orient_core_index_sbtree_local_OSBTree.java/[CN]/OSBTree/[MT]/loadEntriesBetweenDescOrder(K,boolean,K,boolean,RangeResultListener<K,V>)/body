{
  keyFrom=keySerializer.preprocess(keyFrom,(Object[])keyTypes);
  keyTo=keySerializer.preprocess(keyTo,(Object[])keyTypes);
  keyFrom=enhanceFromCompositeKeyBetweenDesc(keyFrom,fromInclusive);
  BucketSearchResult bucketSearchResultFrom=findBucket(keyFrom);
  long pageIndexFrom=bucketSearchResultFrom.getLastPathItem();
  int indexFrom;
  if (bucketSearchResultFrom.itemIndex >= 0) {
    indexFrom=fromInclusive ? bucketSearchResultFrom.itemIndex : bucketSearchResultFrom.itemIndex + 1;
  }
 else {
    indexFrom=-bucketSearchResultFrom.itemIndex - 1;
  }
  keyTo=enhanceToCompositeKeyBetweenDesc(keyTo,toInclusive);
  BucketSearchResult bucketSearchResultTo=findBucket(keyTo);
  long pageIndexTo=bucketSearchResultTo.getLastPathItem();
  int indexTo;
  if (bucketSearchResultTo.itemIndex >= 0) {
    indexTo=toInclusive ? bucketSearchResultTo.itemIndex : bucketSearchResultTo.itemIndex - 1;
  }
 else {
    indexTo=-bucketSearchResultTo.itemIndex - 2;
  }
  int startIndex;
  int endIndex;
  long pageIndex=pageIndexTo;
  resultsLoop:   while (true) {
    long prevPageIndex=-1;
    final OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
    final OCachePointer pointer=cacheEntry.getCachePointer();
    try {
      OSBTreeBucket<K,V> bucket=new OSBTreeBucket<K,V>(pointer.getDataPointer(),keySerializer,keyTypes,valueSerializer,ODurablePage.TrackMode.NONE);
      if (pageIndex == pageIndexTo)       startIndex=indexTo;
 else       startIndex=bucket.size() - 1;
      if (pageIndex != pageIndexFrom)       endIndex=0;
 else       endIndex=indexFrom;
      for (int i=startIndex; i >= endIndex; i--) {
        if (!listener.addResult(convertToMapEntry(bucket.getEntry(i))))         break resultsLoop;
      }
      if (pageIndex == pageIndexFrom)       break;
      if (bucket.getLeftSibling() >= 0)       prevPageIndex=bucket.getLeftSibling();
 else       break;
    }
  finally {
      diskCache.release(cacheEntry);
    }
    pageIndex=prevPageIndex;
  }
}
