{
  acquireExclusiveLock();
  try {
    final ORID rid=(ORID)iConfig.field(CONFIG_MAP_RID,ORID.class);
    if (rid == null)     throw new OIndexException("Error during deserialization of index definition: '" + CONFIG_MAP_RID + "' attribute is null");
    configuration=iConfig;
    name=configuration.field(OIndexInternal.CONFIG_NAME);
    final ODocument indexDefinitionDoc=configuration.field(OIndexInternal.INDEX_DEFINITION);
    if (indexDefinitionDoc != null) {
      try {
        final String indexDefClassName=configuration.field(OIndexInternal.INDEX_DEFINITION_CLASS);
        final Class<?> indexDefClass=Class.forName(indexDefClassName);
        indexDefinition=(OIndexDefinition)indexDefClass.getDeclaredConstructor().newInstance();
        indexDefinition.fromStream(indexDefinitionDoc);
      }
 catch (      final ClassNotFoundException e) {
        throw new OIndexException("Error during deserialization of index definition",e);
      }
catch (      final NoSuchMethodException e) {
        throw new OIndexException("Error during deserialization of index definition",e);
      }
catch (      final InvocationTargetException e) {
        throw new OIndexException("Error during deserialization of index definition",e);
      }
catch (      final InstantiationException e) {
        throw new OIndexException("Error during deserialization of index definition",e);
      }
catch (      final IllegalAccessException e) {
        throw new OIndexException("Error during deserialization of index definition",e);
      }
    }
 else {
      final Boolean isAutomatic=configuration.field(OIndexInternal.CONFIG_AUTOMATIC);
      if (Boolean.TRUE.equals(isAutomatic)) {
        final int pos=name.lastIndexOf('.');
        if (pos < 0)         throw new OIndexException("Can not convert from old index model to new one. " + "Invalid index name. Dot (.) separator should be present.");
        final String className=name.substring(0,pos);
        final String propertyName=name.substring(pos + 1);
        final String keyTypeStr=configuration.field(OIndexInternal.CONFIG_KEYTYPE);
        if (keyTypeStr == null)         throw new OIndexException("Can not convert from old index model to new one. " + "Index key type is absent.");
        final OType keyType=OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));
        indexDefinition=new OPropertyIndexDefinition(className,propertyName,keyType);
        configuration.removeField(OIndexInternal.CONFIG_AUTOMATIC);
        configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);
      }
 else       if (configuration.field(OIndexInternal.CONFIG_KEYTYPE) != null) {
        final String keyTypeStr=configuration.field(OIndexInternal.CONFIG_KEYTYPE);
        final OType keyType=OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));
        indexDefinition=new OSimpleKeyIndexDefinition(keyType);
        configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);
      }
    }
    clustersToIndex.clear();
    maxUpdatesBeforeSave=lazyUpdates();
    final Collection<? extends String> clusters=configuration.field(CONFIG_CLUSTERS);
    if (clusters != null)     clustersToIndex.addAll(clusters);
    map=new OMVRBTreeDatabaseLazySave<Object,T>(getDatabase(),rid,maxUpdatesBeforeSave);
    try {
      map.load();
    }
 catch (    Exception e) {
      if (onCorruptionRepairDatabase(null,"load","Index will be rebuilt")) {
        if (isAutomatic())         OLogManager.instance().warn(this,"Cannot load index '%s' from storage (rid=%s): rebuilt it from scratch",getName(),rid);
        try {
          rebuild();
        }
 catch (        Throwable t) {
          OLogManager.instance().error(this,"Cannot rebuild index '%s' from storage (rid=%s) bacause '" + t + "'. The index will be removed in configuration",getName(),rid);
          return false;
        }
      }
    }
    installHooks(iConfig.getDatabase());
    return true;
  }
  finally {
    releaseExclusiveLock();
  }
}
