{
  long documentIndexed=0;
  final boolean intentInstalled=getDatabase().declareIntent(new OIntentMassiveInsert());
  acquireExclusiveLock();
  try {
    rebuildThread=Thread.currentThread();
    rebuilding=true;
    try {
      if (indexId >= 0)       storage.deleteIndexEngine(indexId);
    }
 catch (    Exception e) {
      OLogManager.instance().error(this,"Error during index '%s' delete",name);
    }
    removeValuesContainer();
    indexId=storage.addIndexEngine(name,algorithm,indexDefinition,determineValueSerializer(),isAutomatic(),isDurableInNonTxMode(),version,getEngineProperties());
    onIndexEngineChange(indexId);
    long documentNum=0;
    long documentTotal=0;
    for (    final String cluster : clustersToIndex)     documentTotal+=getDatabase().countClusterElements(cluster);
    if (iProgressListener != null)     iProgressListener.onBegin(this,documentTotal,true);
    for (    final String clusterName : clustersToIndex) {
      final long[] metrics=indexCluster(clusterName,iProgressListener,documentNum,documentIndexed,documentTotal);
      documentNum=metrics[0];
      documentIndexed=metrics[1];
    }
    if (iProgressListener != null)     iProgressListener.onCompletition(this,true);
  }
 catch (  final Exception e) {
    if (iProgressListener != null)     iProgressListener.onCompletition(this,false);
    try {
      if (indexId >= 0)       storage.clearIndex(indexId);
    }
 catch (    Exception e2) {
      OLogManager.instance().error(this,"Error during index rebuild",e2);
    }
    throw new OIndexException("Error on rebuilding the index for clusters: " + clustersToIndex,e);
  }
 finally {
    rebuilding=false;
    rebuildThread=null;
    if (intentInstalled)     getDatabase().declareIntent(null);
    releaseExclusiveLock();
  }
  return documentIndexed;
}
