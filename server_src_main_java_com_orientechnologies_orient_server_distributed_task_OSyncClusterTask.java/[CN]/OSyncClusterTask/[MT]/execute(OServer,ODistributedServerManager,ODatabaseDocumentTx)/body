{
  if (!getNodeSource().equals(iManager.getLocalNodeName())) {
    if (database == null)     throw new ODistributedException("Database instance is null");
    final String databaseName=database.getName();
    final Lock lock=iManager.getLock("sync." + databaseName + "."+ clusterName);
    if (lock.tryLock()) {
      try {
        final Long lastDeployment=(Long)iManager.getConfigurationMap().get(DEPLOYCLUSTER + databaseName + "."+ clusterName);
        if (lastDeployment != null && lastDeployment.longValue() == random) {
          ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.NONE,"skip deploying cluster '%s' because already executed",clusterName);
          return Boolean.FALSE;
        }
        iManager.getConfigurationMap().put(DEPLOYCLUSTER + databaseName + "."+ clusterName,random);
        ODistributedServerLog.warn(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"deploying cluster %s...",databaseName);
        final File backupFile=new File(Orient.getTempPath() + "/backup_" + database.getName()+ "_"+ clusterName+ ".zip");
        if (backupFile.exists())         backupFile.delete();
 else         backupFile.getParentFile().mkdirs();
        backupFile.createNewFile();
        ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"creating backup of cluster '%s' in directory: %s...",databaseName,backupFile.getAbsolutePath());
        final OPaginatedCluster cluster=(OPaginatedCluster)database.getStorage().getClusterByName(clusterName);
switch (mode) {
case MERGE:
          throw new IllegalArgumentException("merge mode not supported");
case FULL_REPLACE:
        final FileOutputStream fileOutputStream=new FileOutputStream(backupFile);
      try {
        database.freeze();
        try {
          final String fileName=cluster.getFileName();
          final String dbPath=iServer.getDatabaseDirectory() + databaseName;
          OZIPCompressionUtil.compressFile(dbPath,fileName,fileOutputStream,null,OGlobalConfiguration.DISTRIBUTED_DEPLOYDB_TASK_COMPRESSION.getValueAsInteger());
        }
  finally {
          database.release();
        }
      }
  finally {
        fileOutputStream.close();
      }
    final long fileSize=backupFile.length();
  ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"sending the compressed cluster '%s.%s' over the NETWORK to node '%s', size=%s...",databaseName,clusterName,getNodeSource(),OFileUtils.getSizeAsString(fileSize));
final ODistributedDatabaseChunk chunk=new ODistributedDatabaseChunk(0,backupFile,0,CHUNK_MAX_SIZE);
ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"- transferring chunk #%d offset=%d size=%s...",1,0,OFileUtils.getSizeAsNumber(chunk.buffer.length));
return chunk;
}
}
  finally {
lock.unlock();
ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),ODistributedServerLog.DIRECTION.OUT,"deploy cluster %s task completed",clusterName);
}
}
}
 else ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.NONE,"skip deploying cluster %s.%s from the same node");
return Boolean.FALSE;
}
