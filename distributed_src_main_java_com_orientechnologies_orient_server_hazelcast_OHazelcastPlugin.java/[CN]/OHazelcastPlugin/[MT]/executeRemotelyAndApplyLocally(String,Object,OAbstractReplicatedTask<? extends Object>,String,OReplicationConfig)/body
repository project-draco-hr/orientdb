{
  try {
    ODistributedServerLog.debug(this,getLocalNodeId(),iTask.getNodeDestination(),DIRECTION.OUT,"routing execution %s db=%s oper=%d.%d...",iTask.getName().toUpperCase(),dbName,iTask.getRunId(),iTask.getOperationSerial());
    final Map<String,Object> remoteResults=replicate(iTask,iReplicationData);
    final Object localResult;
    if (iTask instanceof OAbstractReplicatedTask<?>) {
      ODistributedServerLog.debug(this,getLocalNodeId(),iTask.getNodeDestination(),DIRECTION.IN,"apply changes locally about %s against db=%s oper=%d.%d...",iTask.getName().toUpperCase(),dbName,iTask.getRunId(),iTask.getOperationSerial());
      final ORef<Long> journalOffset=new ORef<Long>();
      localResult=enqueueLocalExecution(iTask,journalOffset);
      updateJournal(iTask,iTask.getDatabaseSynchronizer(),journalOffset.value,true);
      checkForConflicts(iTask,localResult,remoteResults,iReplicationData.minSuccessfulOperations);
    }
 else     localResult=remoteResults.values().iterator().next();
    return localResult;
  }
 catch (  MemberLeftException e) {
    ODistributedServerLog.warn(this,getLocalNodeId(),iTask.getNodeDestination(),DIRECTION.OUT,"error on execution of operation %d.%d in %s mode, because node left. Re-route it in transparent way",e,iTask.getRunId(),iTask.getOperationSerial(),EXECUTION_MODE.SYNCHRONOUS);
    return execute(iClusterName,iKey,iTask,iReplicationData);
  }
catch (  Exception e) {
    ODistributedServerLog.error(this,getLocalNodeId(),iTask.getNodeDestination(),DIRECTION.OUT,"error on execution of operation %d.%d in %s mode",e,iTask.getRunId(),iTask.getOperationSerial(),EXECUTION_MODE.SYNCHRONOUS);
    throw e;
  }
 finally {
    notifyQueueWaiters(iTask.getDatabaseName(),iTask.getRunId(),iTask.getOperationSerial(),false);
  }
}
