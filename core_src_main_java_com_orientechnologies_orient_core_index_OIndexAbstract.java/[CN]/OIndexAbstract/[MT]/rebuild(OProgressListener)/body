{
  long documentIndexed=0;
  final boolean intentInstalled=getDatabase().declareIntent(new OIntentMassiveInsert());
  modificationLock.requestModificationLock();
  try {
    acquireExclusiveLock();
    try {
      markStorageDirty();
      rebuildThread=Thread.currentThread();
      rebuilding=true;
      try {
        indexEngine.deleteWithoutLoad(name);
      }
 catch (      Exception e) {
        OLogManager.instance().error(this,"Error during index '%s' delete",name);
      }
      removeValuesContainer();
      indexEngine.create(indexDefinition,getDatabase().getMetadata().getIndexManager().getDefaultClusterName(),determineValueSerializer(),isAutomatic());
      long documentNum=0;
      long documentTotal=0;
      for (      final String cluster : clustersToIndex)       documentTotal+=getDatabase().countClusterElements(cluster);
      if (iProgressListener != null)       iProgressListener.onBegin(this,documentTotal,true);
      for (      final String clusterName : clustersToIndex) {
        final long[] metrics=indexCluster(clusterName,iProgressListener,documentNum,documentIndexed,documentTotal);
        documentNum=metrics[0];
        documentIndexed=metrics[1];
      }
      if (iProgressListener != null)       iProgressListener.onCompletition(this,true);
    }
 catch (    final Exception e) {
      if (iProgressListener != null)       iProgressListener.onCompletition(this,false);
      try {
        indexEngine.clear();
      }
 catch (      Exception e2) {
        OLogManager.instance().error(this,"Error during index rebuild",e2);
      }
      throw new OIndexException("Error on rebuilding the index for clusters: " + clustersToIndex,e);
    }
 finally {
      rebuilding=false;
      rebuildThread=null;
      if (intentInstalled)       getDatabase().declareIntent(null);
      releaseExclusiveLock();
    }
  }
  finally {
    modificationLock.releaseModificationLock();
  }
  return documentIndexed;
}
