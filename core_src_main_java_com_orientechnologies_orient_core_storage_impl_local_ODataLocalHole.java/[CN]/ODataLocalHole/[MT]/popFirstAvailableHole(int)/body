{
  if (maxHoleSize > -1 && iRecordSize + ODataLocal.RECORD_FIX_SIZE + 50 > maxHoleSize)   return -1;
  final long timer=Orient.instance().getProfiler().startChrono();
  if (!availableHolesBySize.isEmpty()) {
    cursor.size=iRecordSize;
    ODataHoleInfo hole=availableHolesBySize.get(cursor);
    if (hole != null && hole.size == iRecordSize) {
      Orient.instance().getProfiler().stopChrono(PROFILER_DATA_RECYCLED_COMPLETE,"Time to recycle the hole space completely in data segment",timer);
      final long pos=hole.dataOffset;
      deleteHole(hole.holeOffset);
      return pos;
    }
    hole=availableHolesBySize.lastKey();
    if (hole.size > iRecordSize + ODataLocal.RECORD_FIX_SIZE + 50) {
      final long pos=hole.dataOffset;
      Orient.instance().getProfiler().stopChrono(PROFILER_DATA_RECYCLED_PARTIAL,"Time to recycle the hole space partially in data segment",timer);
      updateHole(hole,hole.dataOffset + iRecordSize,hole.size - iRecordSize);
      return pos;
    }
  }
  Orient.instance().getProfiler().stopChrono(PROFILER_DATA_RECYCLED_NOTFOUND,"Time to recycle a hole space in data segment, but without luck",timer);
  return -1;
}
