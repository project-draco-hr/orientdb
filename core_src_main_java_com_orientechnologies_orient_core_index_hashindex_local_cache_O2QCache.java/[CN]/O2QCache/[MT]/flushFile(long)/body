{
synchronized (syncObject) {
    final SortedSet<DirtyPage> dirtyPages=this.dirtyPages.get(fileId);
    for (Iterator<DirtyPage> iterator=dirtyPages.iterator(); iterator.hasNext(); ) {
      Long pageIndex=iterator.next().pageIndex;
      LRUEntry lruEntry=get(fileId,pageIndex);
      if (lruEntry == null) {
        final Long dataPointer=evictedPages.remove(new FileLockKey(fileId,pageIndex));
        if (dataPointer != null) {
          flushData(fileId,pageIndex,dataPointer);
          iterator.remove();
        }
      }
 else {
        if (lruEntry.usageCounter == 0) {
          flushData(fileId,lruEntry.pageIndex,lruEntry.dataPointer);
          iterator.remove();
          lruEntry.isDirty=false;
        }
 else {
          throw new OBlockedPageException("Unable to perform flush file because some pages is in use.");
        }
      }
    }
    files.get(fileId).synch();
  }
}
