{
  try {
    int unreadResponse=0;
    final long startClock=iTimeout > 0 ? System.currentTimeMillis() : 0;
    do {
      if (iTimeout <= 0)       lockRead.lock();
 else       if (!lockRead.tryLock(iTimeout,TimeUnit.MILLISECONDS))       throw new OTimeoutException("Cannot acquire read lock against channel: " + this);
      if (!channelRead) {
        channelRead=true;
        try {
          currentStatus=readByte();
          currentSessionId=readInt();
          if (debug)           OLogManager.instance().debug(this,"%s - Read response: %d-%d",socket.getRemoteSocketAddress(),(int)currentStatus,currentSessionId);
        }
 catch (        IOException e) {
          lockRead.unlock();
          channelRead=false;
          throw e;
        }
      }
      if (currentSessionId == iRequesterId)       break;
      if (debug)       OLogManager.instance().debug(this,"%s - Session %d skip response, it is for %d",socket.getRemoteSocketAddress(),iRequesterId,currentSessionId);
      if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout)       throw new OTimeoutException("Timeout on reading response from the server for the request " + iRequesterId);
      if (unreadResponse > maxUnreadResponses)       clearInput();
      lockRead.unlock();
synchronized (this) {
        try {
          final long start=System.currentTimeMillis();
          wait(1000);
          final long now=System.currentTimeMillis();
          if (debug)           OLogManager.instance().debug(this,"Slept %dms, checking again from %s for session %d",(now - start),socket.getRemoteSocketAddress(),currentSessionId);
          if (now - start >= 1000)           unreadResponse++;
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
 while (true);
    if (debug)     OLogManager.instance().debug(this,"%s - Session %d handle response",socket.getRemoteSocketAddress(),iRequesterId);
    handleStatus(currentStatus,currentSessionId);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    e.printStackTrace();
  }
}
