{
  if (dataCacheIterator == null)   return null;
  if (dataCacheIterator.hasNext())   return dataCacheIterator.next();
  dataCache.clear();
  if (prefetchSize < 0 || prefetchSize > OGlobalConfiguration.INDEX_CURSOR_PREFETCH_SIZE.getValueAsInteger())   prefetchSize=OGlobalConfiguration.INDEX_CURSOR_PREFETCH_SIZE.getValueAsInteger();
  atomicOperationsManager.acquireReadLock(OSBTree.this);
  try {
    acquireSharedLock();
    try {
      OAtomicOperation atomicOperation=atomicOperationsManager.getCurrentOperation();
      while (dataCache.size() < prefetchSize) {
        if (pageIndex >= getFilledUpTo(atomicOperation,fileId))         pageIndex=getFilledUpTo(atomicOperation,fileId) - 1;
        if (pageIndex == -1)         break;
        final OCacheEntry cacheEntry=loadPage(atomicOperation,fileId,pageIndex,false);
        try {
          final OSBTreeBucket<K,V> bucket=new OSBTreeBucket<K,V>(cacheEntry,keySerializer,keyTypes,valueSerializer,getChangesTree(atomicOperation,cacheEntry));
          if (itemIndex >= bucket.size())           itemIndex=bucket.size() - 1;
          if (itemIndex < 0) {
            pageIndex=bucket.getLeftSibling();
            itemIndex=Integer.MAX_VALUE;
            continue;
          }
          final Map.Entry<K,V> entry=convertToMapEntry(bucket.getEntry(itemIndex),atomicOperation);
          itemIndex--;
          if (toKey != null && (toKeyInclusive ? comparator.compare(entry.getKey(),toKey) > 0 : comparator.compare(entry.getKey(),toKey) >= 0))           continue;
          if (fromKey != null && (fromKeyInclusive ? comparator.compare(entry.getKey(),fromKey) < 0 : comparator.compare(entry.getKey(),fromKey) <= 0)) {
            pageIndex=-1;
            break;
          }
          dataCache.add(entry);
        }
  finally {
          releasePage(atomicOperation,cacheEntry);
        }
      }
    }
  finally {
      releaseSharedLock();
    }
  }
 catch (  IOException e) {
    throw OException.wrapException(new OSBTreeException("Error during element iteration"),e);
  }
 finally {
    atomicOperationsManager.releaseReadLock(OSBTree.this);
  }
  if (dataCache.isEmpty()) {
    dataCacheIterator=null;
    return null;
  }
  dataCacheIterator=dataCache.iterator();
  return dataCacheIterator.next();
}
