{
  acquireSharedLock();
  try {
    final long position=clusterPosition.longValue();
    if (position < 0)     return new OClusterPosition[0];
    long pageIndex=position / OClusterPositionMapBucket.MAX_ENTRIES;
    int index=(int)(position % OClusterPositionMapBucket.MAX_ENTRIES);
    final long filledUpTo=diskCache.getFilledUpTo(fileId);
    OClusterPosition[] result;
    if (pageIndex >= filledUpTo) {
      pageIndex=filledUpTo - 1;
      index=Integer.MIN_VALUE;
    }
    do {
      OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
      OCachePointer cachePointer=cacheEntry.getCachePointer();
      OClusterPositionMapBucket bucket=new OClusterPositionMapBucket(cachePointer.getDataPointer(),ODurablePage.TrackMode.NONE);
      if (index == Integer.MIN_VALUE)       index=bucket.getSize() - 1;
      int resultSize=index + 1;
      int entriesCount=0;
      long startPosition=cacheEntry.getPageIndex() * OClusterPositionMapBucket.MAX_ENTRIES;
      result=new OClusterPosition[resultSize];
      for (int i=0; i < resultSize; i++) {
        if (bucket.exists(i)) {
          result[entriesCount]=OClusterPositionFactory.INSTANCE.valueOf(startPosition + i);
          entriesCount++;
        }
      }
      if (entriesCount == 0) {
        result=null;
        pageIndex--;
        index=Integer.MIN_VALUE;
      }
 else       result=Arrays.copyOf(result,entriesCount);
      diskCache.release(cacheEntry);
    }
 while (result == null && pageIndex >= 0);
    if (result == null)     result=new OClusterPosition[0];
    return result;
  }
  finally {
    releaseSharedLock();
  }
}
