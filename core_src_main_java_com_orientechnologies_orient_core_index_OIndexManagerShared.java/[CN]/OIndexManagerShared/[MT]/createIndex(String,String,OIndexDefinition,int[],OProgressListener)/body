{
  if (getDatabase().getTransaction().isActive())   throw new IllegalStateException("Cannot create a new index inside a transaction");
  final Character c=OSchemaShared.checkNameIfValid(iName);
  if (c != null)   throw new IllegalArgumentException("Invalid index name '" + iName + "'. Character '"+ c+ "' is invalid");
  String alghorithm;
  ODatabase database=getDatabase();
  OStorage storage=database.getStorage();
  if ((storage.getType().equals(OEngineLocal.NAME) || storage.getType().equals(OEngineLocalPaginated.NAME)) && useSBTree)   alghorithm=ODefaultIndexFactory.SBTREE_ALGORITHM;
 else   alghorithm=ODefaultIndexFactory.MVRBTREE_ALGORITHM;
  acquireExclusiveLock();
  try {
    final OIndexInternal<?> index=OIndexes.createIndex(getDatabase(),iType,alghorithm);
    final String clusterName=indexDefinition != null && indexDefinition.getClassName() != null ? defaultClusterName : manualClusterName;
    if (iProgressListener == null)     iProgressListener=new OIndexRebuildOutputListener(index);
    Set<String> clustersToIndex=new HashSet<String>();
    if (clusterIdsToIndex != null) {
      for (      int clusterId : clusterIdsToIndex) {
        final String clusterNameToIndex=database.getClusterNameById(clusterId);
        if (clusterNameToIndex == null)         throw new OIndexException("Cluster with id " + clusterId + " does not exist.");
        clustersToIndex.add(clusterNameToIndex);
      }
    }
    index.create(iName,indexDefinition,clusterName,clustersToIndex,true,iProgressListener);
    addIndexInternal(index);
    setDirty();
    save();
    return index;
  }
  finally {
    releaseExclusiveLock();
  }
}
