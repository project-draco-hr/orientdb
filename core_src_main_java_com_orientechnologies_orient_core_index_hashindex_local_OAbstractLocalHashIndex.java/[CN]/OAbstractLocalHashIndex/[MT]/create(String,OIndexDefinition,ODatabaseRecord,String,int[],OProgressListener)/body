{
  acquireExclusiveLock();
  try {
    configuration=new ODocument();
    this.indexDefinition=indexDefinition;
    this.name=name;
    storage=(OStorageLocal)database.getStorage();
    final ORecord<?> emptyRecord=new ORecordBytes(new byte[]{});
    emptyRecord.save(clusterIndexName);
    identity=emptyRecord.getIdentity();
    keySerializer=detectKeySerializer(indexDefinition);
    if (clusterIdsToIndex != null)     for (    final int id : clusterIdsToIndex)     clustersToIndex.add(database.getClusterNameById(id));
    final OStorageFileConfiguration metadataConfiguration=new OStorageFileConfiguration(null,OStorageVariableParser.DB_PATH_VARIABLE + '/' + name+ METADATA_CONFIGURATION_FILE_EXTENSION,OFileFactory.MMAP,"0","50%");
    final OStorageFileConfiguration treeStateConfiguration=new OStorageFileConfiguration(null,OStorageVariableParser.DB_PATH_VARIABLE + '/' + name+ TREE_STATE_FILE_EXTENSION,OFileFactory.MMAP,"0","50%");
    metadataStore=new OEHFileMetadataStore(storage,metadataConfiguration);
    treeStateStore=new OEHTreeStateStore(storage,treeStateConfiguration);
    for (int i=0; i < 2; i++) {
      final OEHFileMetadata metadata=createFileMetadata(i);
      filesMetadata[i]=metadata;
    }
    metadataStore.create(-1);
    treeStateStore.create(-1);
    initHashTreeState();
    updateConfiguration();
    rebuild(progressListener);
    return this;
  }
 catch (  IOException e) {
    throw new OIndexException("Error during index creation.",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
