{
  Deque<TreeMap<OIndex<?>,List<Object>>> indexKeysMapQueue=lockedKeys.get();
  if (indexKeysMapQueue == null) {
    indexKeysMapQueue=new ArrayDeque<TreeMap<OIndex<?>,List<Object>>>();
    lockedKeys.set(indexKeysMapQueue);
  }
  final TreeMap<OIndex<?>,List<Object>> indexKeysMap=new TreeMap<OIndex<?>,List<Object>>();
  final Set<String> dirtyFields=new HashSet<String>(Arrays.asList(record.getDirtyFields()));
  if (dirtyFields.isEmpty())   return;
  for (  final OIndex<?> index : indexes) {
    final List<Object> keys=new ArrayList<Object>();
    final OIndexDefinition indexDefinition=index.getDefinition();
    final List<String> indexFields=indexDefinition.getFields();
    for (    final String indexField : indexFields) {
      if (dirtyFields.contains(indexField)) {
        final Object key=index.getDefinition().getDocumentValueToIndex(record);
        if (key instanceof Collection) {
          for (          final Object keyItem : (Collection<?>)key) {
            if (!indexDefinition.isNullValuesIgnored() || keyItem != null) {
              keys.add(copyKeyIfNeeded(keyItem));
            }
          }
        }
 else {
          if (!indexDefinition.isNullValuesIgnored() || key != null) {
            keys.add(copyKeyIfNeeded(key));
          }
        }
        break;
      }
    }
    indexKeysMap.put(index,keys);
  }
  for (  Map.Entry<OIndex<?>,List<Object>> entry : indexKeysMap.entrySet()) {
    final OIndexInternal<?> index=entry.getKey().getInternal();
    index.lockKeysForUpdate(entry.getValue());
  }
  indexKeysMapQueue.push(indexKeysMap);
  for (  Map.Entry<OIndex<?>,List<Object>> entry : indexKeysMap.entrySet()) {
    final OIndex<?> index=entry.getKey();
    for (    Object keyItem : entry.getValue()) {
      index.checkEntry(record,keyItem);
    }
  }
}
