{
  int errors=0;
  int warnings=0;
  lock.acquireSharedLock();
  try {
    long totalRecors=0;
    final long start=System.currentTimeMillis();
    formatMessage(iVerbose,iListener,"\nChecking database '" + getName() + "'...\n");
    formatMessage(iVerbose,iListener,"\n(1) Checking data-clusters. This activity checks if pointers to data are coherent.");
    final OPhysicalPosition ppos=new OPhysicalPosition();
    for (    OCluster c : clusters) {
      if (!(c instanceof OClusterLocal))       continue;
      if (c.getName().equals("index"))       continue;
      formatMessage(iVerbose,iListener,"\n- data-cluster #%-5d %s -> ",c.getId(),c.getName());
      for (final OClusterEntryIterator it=c.absoluteIterator(); it.hasNext(); ) {
        final OPhysicalPosition physicalPosition=it.next();
        totalRecors++;
        try {
          if (physicalPosition.dataSegmentId >= dataSegments.length) {
            formatMessage(iVerbose,iListener,"WARN: Found wrong data segment %d ",physicalPosition.dataSegmentId);
            warnings++;
          }
          if (physicalPosition.recordSize < 0) {
            formatMessage(iVerbose,iListener,"WARN: Found wrong record size %d ",physicalPosition.recordSize);
            warnings++;
          }
          if (physicalPosition.recordSize >= 1000000) {
            formatMessage(iVerbose,iListener,"WARN: Found suspected big record size %d. Is it corrupted? ",physicalPosition.recordSize);
            warnings++;
          }
          if (physicalPosition.dataSegmentPos > dataSegments[physicalPosition.dataSegmentId].getFilledUpTo()) {
            formatMessage(iVerbose,iListener,"WARN: Found wrong pointer to data chunk %d out of data segment size (%d) ",physicalPosition.dataSegmentPos,dataSegments[physicalPosition.dataSegmentId].getFilledUpTo());
            warnings++;
          }
          if (physicalPosition.recordVersion.isTombstone() && (c instanceof OClusterLocal)) {
            boolean found=false;
            int tot=((OClusterLocal)c).holeSegment.getHoles();
            for (int i=0; i < tot; ++i) {
              final long recycledPosition=((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE;
              if (recycledPosition == physicalPosition.clusterPosition.longValue()) {
                found=true;
                break;
              }
            }
            if (!found) {
              formatMessage(iVerbose,iListener,"WARN: Cannot find hole for deleted record %d:%d ",c.getId(),physicalPosition.clusterPosition);
              warnings++;
            }
          }
        }
 catch (        IOException e) {
          formatMessage(iVerbose,iListener,"WARN: Error while reading record #%d:%d ",e,c.getId(),ppos.clusterPosition);
          warnings++;
        }
      }
      if (c instanceof OClusterLocal) {
        final int totalHoles=((OClusterLocal)c).holeSegment.getHoles();
        if (totalHoles > 0) {
          formatMessage(iVerbose,iListener," [found " + totalHoles + " hole(s)]");
          for (int i=0; i < totalHoles; ++i) {
            long recycledPosition=-1;
            try {
              ppos.clusterPosition=OClusterPositionFactory.INSTANCE.valueOf(((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE);
              OPhysicalPosition physicalPosition=c.getPhysicalPosition(ppos);
              if (physicalPosition != null && !physicalPosition.recordVersion.isTombstone()) {
                formatMessage(iVerbose,iListener,"WARN: Found wrong hole %d/%d for deleted record %d:%d. The record seems good ",i,totalHoles - 1,c.getId(),recycledPosition);
                warnings++;
              }
            }
 catch (            Exception e) {
              formatMessage(iVerbose,iListener,"WARN: Found wrong hole %d/%d for deleted record %d:%d. The record not exists ",i,totalHoles - 1,c.getId(),recycledPosition);
              warnings++;
            }
          }
        }
      }
      formatMessage(iVerbose,iListener,"OK");
    }
    int totalChunks=0;
    formatMessage(iVerbose,iListener,"\n\n(2) Checking data chunks integrity. In this phase data segments are scanned to check the back reference into the clusters.");
    for (    ODataLocal d : dataSegments) {
      if (d == null)       continue;
      if (d.getName().equals("index"))       continue;
      formatMessage(iVerbose,iListener,"\n- data-segment %s (id=%d) size=%d/%d...",d.getName(),d.getId(),d.getFilledUpTo(),d.getSize(),d.getHoles());
      int nextPos=0;
      final List<ODataHoleInfo> holes=d.getHolesList();
      if (iVerbose) {
        formatMessage(iVerbose,iListener,"\n-- found %d holes:",holes.size());
        for (        ODataHoleInfo hole : holes)         formatMessage(iVerbose,iListener,"\n--- hole #%-7d offset=%-10d size=%-7d",hole.holeOffset,hole.dataOffset,hole.size);
      }
      formatMessage(iVerbose,iListener,"\n-- checking chunks:");
      int pos;
      do {
        try {
          pos=nextPos;
          ODataHoleInfo foundHole=null;
          for (          ODataHoleInfo hole : holes) {
            if (hole.dataOffset == pos) {
              foundHole=hole;
              break;
            }
          }
          int recordSize=d.getRecordSize(pos);
          formatMessage(iVerbose,iListener,"\n--- chunk #%-7d offset=%-10d size=%-7d -> ",totalChunks,pos,recordSize);
          if (recordSize < 0) {
            recordSize*=-1;
            if (foundHole != null) {
              if (foundHole.size != recordSize) {
                formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) differs in size with the hole size %d ",d.getName(),totalChunks,pos,recordSize,foundHole.size);
                warnings++;
              }
              nextPos=pos + foundHole.size;
            }
 else {
              formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) has no hole for deleted chunk ",d.getName(),totalChunks,pos,recordSize);
              warnings++;
              nextPos=pos + recordSize;
            }
          }
 else {
            if (foundHole != null) {
              formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) it's between the holes (hole #%d) even if has no negative recordSize. Jump the content ",d.getName(),totalChunks,pos,recordSize,foundHole.holeOffset);
              warnings++;
              nextPos=pos + foundHole.size;
            }
 else {
              nextPos=pos + ODataLocal.RECORD_FIX_SIZE + recordSize;
              final byte[] buffer=d.getRecord(pos);
              if (buffer.length != recordSize) {
                formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) has wrong record size because the record length is %d ",d.getName(),totalChunks,pos,recordSize,buffer.length);
                warnings++;
              }
              final ORecordId rid=d.getRecordRid(pos);
              if (!rid.isValid()) {
                formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) points to invalid RID %s ",d.getName(),totalChunks,pos,recordSize,rid);
                warnings++;
              }
 else {
                if (rid.clusterId >= clusters.length) {
                  formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) has invalid RID because points to %s but configured clusters are %d in total ",d.getName(),totalChunks,pos,recordSize,rid,clusters.length);
                  warnings++;
                }
 else                 if (clusters[rid.clusterId] == null) {
                  formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) has invalid RID because points to %s but the cluster %d not exists ",d.getName(),totalChunks,pos,recordSize,rid,rid.clusterId);
                  warnings++;
                }
 else {
                  ppos.clusterPosition=rid.clusterPosition;
                  clusters[rid.clusterId].getPhysicalPosition(ppos);
                  if (ppos.dataSegmentId != d.getId()) {
                    formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) point to the RID %d but it doesn't point to current data segment %d but to %d ",d.getName(),totalChunks,pos,recordSize,rid,d.getId(),ppos.dataSegmentId);
                    warnings++;
                  }
                  if (ppos.dataSegmentPos != pos) {
                    formatMessage(iVerbose,iListener,"WARN: Chunk %s:%d (offset=%d size=%d) point to the RID %d but it doesn't point to current chunk %d but to %d ",d.getName(),totalChunks,pos,recordSize,rid,ppos.dataSegmentPos,pos);
                    warnings++;
                  }
                }
              }
            }
          }
          totalChunks++;
          formatMessage(iVerbose,iListener,"OK");
        }
 catch (        Exception e) {
          iListener.onMessage("ERROR: " + e.toString());
          errors++;
        }
      }
 while (nextPos < d.getFilledUpTo());
      formatMessage(iVerbose,iListener,"\n");
    }
    iListener.onMessage("\nCheck of database completed in " + (System.currentTimeMillis() - start) + "ms:\n- Total records checked: "+ totalRecors+ "\n- Total chunks checked.: "+ totalChunks+ "\n- Warnings.............: "+ warnings+ "\n- Errors...............: "+ errors+ "\n");
  }
  finally {
    lock.releaseSharedLock();
  }
  return errors == 0;
}
