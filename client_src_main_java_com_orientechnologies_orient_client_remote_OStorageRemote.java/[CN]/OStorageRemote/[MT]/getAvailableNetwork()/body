{
  OChannelBinaryAsynchClient network=null;
  boolean modeForCheckFreeChannel=true;
  int beginCursor=networkPoolCursor;
  while (network == null) {
    networkPoolLock.lock();
    try {
      checkPoolBounds();
      network=networkPool.get(networkPoolCursor);
      networkPoolCursor++;
      final String serverURL=getServerURL();
      if (serverURL == null || network.getServerURL().equals(serverURL)) {
        if (!modeForCheckFreeChannel || !network.isWaitingForResponse())         if (network.tryLock()) {
          break;
        }
      }
      network=null;
      if (beginCursor >= networkPool.size())       beginCursor=networkPoolCursor;
      if (networkPoolCursor == beginCursor) {
        if (networkPool.size() < maxPool) {
          network=createNetworkConnection();
          if (network.tryLock())           break;
        }
 else {
          if (modeForCheckFreeChannel) {
            modeForCheckFreeChannel=false;
            continue;
          }
          OLogManager.instance().info(this,"Network connection pool is full (max=%d): increase max size to avoid such bottleneck on connections",maxPool);
          removeDeadConnections();
          final long startToWait=System.currentTimeMillis();
          networkPoolLock.unlock();
          try {
synchronized (networkPool) {
              networkPool.wait(5000);
            }
          }
 catch (          InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new OStorageException("Cannot acquire a connection because the thread has been interrupted");
          }
 finally {
            networkPoolLock.lock();
          }
          Orient.instance().getProfiler().stopChrono("system.network.connectionPool.waitingTime","Waiting for a free connection from the pool of channels",startToWait);
        }
      }
    }
  finally {
      networkPoolLock.unlock();
    }
  }
  return network;
}
