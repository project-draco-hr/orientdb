{
  commandType=-1;
  data.commandInfo="Listening";
  data.commandDetail="-";
  try {
    commandType=channel.readByte();
    ++data.totalRequests;
    data.lastCommandReceived=System.currentTimeMillis();
switch (commandType) {
case OChannelBinaryProtocol.CONNECT:
{
        data.commandInfo="Connect";
        user=channel.readString();
        passwd=channel.readString();
        sendOk();
        channel.writeString(connection.id);
        break;
      }
case OChannelBinaryProtocol.DB_OPEN:
{
      data.commandInfo="Open database";
      String dbURL=channel.readString();
      String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
      user=channel.readString();
      passwd=channel.readString();
      connection.database=(ODatabaseDocumentTx)OServerMain.server().getMemoryDatabases().get(dbName);
      if (connection.database == null)       connection.database=new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));
      if (connection.database.isClosed())       if (connection.database.getStorage() instanceof OStorageMemory)       connection.database.create();
 else       connection.database.open(user,passwd);
      underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
      if (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user,passwd)) {
        sendError(new OSecurityAccessException(connection.database.getName(),"Access denied to database '" + connection.database.getName() + "' for user: "+ user));
      }
 else {
        sendOk();
        channel.writeString(connection.id);
        channel.writeInt(connection.database.getClusterNames().size());
        for (        OCluster c : (connection.database.getStorage()).getClusters()) {
          if (c != null) {
            channel.writeString(c.getName());
            channel.writeInt(c.getId());
          }
        }
      }
      break;
    }
case OChannelBinaryProtocol.DB_CREATE:
{
    data.commandInfo="Create database";
    String dbName=channel.readString();
    String storageMode=channel.readString();
    final String path;
    final String realPath;
    if (storageMode.equals(OEngineLocal.NAME)) {
      if (OServerMain.server().existsStoragePath(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":${ORIENT_HOME}/databases/" + dbName+ "/"+ dbName;
      realPath=OSystemVariableResolver.resolveSystemVariables(path);
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      if (OServerMain.server().getMemoryDatabases().containsKey(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":" + dbName;
      realPath=path;
    }
 else     throw new IllegalArgumentException("Can't create databse: storage mode '" + storageMode + "' is not supported.");
    connection.database=new ODatabaseDocumentTx(realPath);
    connection.database.create();
    if (storageMode.equals(OEngineLocal.NAME)) {
      connection.database.close();
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      OServerMain.server().getMemoryDatabases().put(dbName,connection.database);
    }
    underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
    sendOk();
    break;
  }
case OChannelBinaryProtocol.DB_CLOSE:
data.commandInfo="Close Database";
break;
case OChannelBinaryProtocol.DB_EXIST:
data.commandInfo="Exists database";
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk();
break;
case OChannelBinaryProtocol.CLUSTER_COUNT:
data.commandInfo="Count cluster elements";
int[] ids=new int[channel.readShort()];
for (int i=0; i < ids.length; ++i) ids[i]=channel.readShort();
long count=connection.database.countClusterElements(ids);
sendOk();
channel.writeLong(count);
break;
case OChannelBinaryProtocol.CLUSTER_ADD:
{
data.commandInfo="Add cluster";
final String type=channel.readString();
final String name=channel.readString();
final int num;
if (OClusterLocal.TYPE.equals(type)) num=connection.database.addPhysicalCluster(name,channel.readString(),channel.readInt());
 else num=connection.database.addLogicalCluster(name,channel.readInt());
sendOk();
channel.writeShort((short)num);
break;
}
case OChannelBinaryProtocol.CLUSTER_REMOVE:
{
data.commandInfo="remove cluster";
final int id=channel.readShort();
boolean result=connection.database.getStorage().removeCluster(id);
sendOk();
channel.writeByte((byte)(result ? '1' : '0'));
break;
}
case OChannelBinaryProtocol.RECORD_LOAD:
data.commandInfo="Load record";
final ORawBuffer record=underlyingDatabase.read(channel.readShort(),channel.readLong());
sendOk();
if (record != null) {
channel.writeByte((byte)1);
channel.writeBytes(record.buffer);
channel.writeInt(record.version);
channel.writeByte(record.recordType);
}
 else channel.writeByte((byte)0);
break;
case OChannelBinaryProtocol.RECORD_CREATE:
data.commandInfo="Create record";
final long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1,channel.readByte());
sendOk();
channel.writeLong(location);
break;
case OChannelBinaryProtocol.RECORD_UPDATE:
data.commandInfo="Update record";
final int clusterId=channel.readShort();
final long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt(),channel.readByte());
if (connection.database.getMetadata().getSchema().getIdentity().getClusterId() == clusterId && connection.database.getMetadata().getSchema().getIdentity().getClusterPosition() == position) connection.database.getMetadata().loadSchema();
 else if (((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterId() == clusterId && ((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterPosition() == position) ((ODictionaryLocal<?>)connection.database.getDictionary()).load();
sendOk();
channel.writeInt((int)newVersion);
break;
case OChannelBinaryProtocol.RECORD_DELETE:
data.commandInfo="Delete record";
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk();
channel.writeByte((byte)'1');
break;
case OChannelBinaryProtocol.COUNT:
{
data.commandInfo="Count cluster records";
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
sendOk();
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.COMMAND:
{
data.commandInfo="Execute remote command";
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
final OQuery<?> query=(OQuery<?>)(command instanceof OQuery<?> ? command : null);
data.commandDetail=command.getText();
if (asynch) {
final StringBuilder empty=new StringBuilder();
final Set<ODocument> recordToSend=new HashSet<ODocument>();
command.setResultListener(new OCommandResultListener(){
public boolean result(final Object iRecord){
if (empty.length() == 0) try {
sendOk();
empty.append("-");
}
 catch (IOException e1) {
}
try {
channel.writeByte((byte)1);
writeRecord((ORecordInternal<?>)iRecord);
channel.flush();
if (query != null && query.getFetchPlan() != null && iRecord instanceof ODocument) fetchInDeep((ODocument)iRecord,query.getFetchPlan().split(" "),null,0,-1);
}
 catch (IOException e) {
return false;
}
return true;
}
private void fetchInDeep(final ODocument doc,final String[] iFetchPlan,final String iCurrentField,final int iCurrentLevel,final int iMaxFetch){
if (recordToSend.size() >= iMaxFetch) return;
String parts[];
Object fieldValue;
int depthLevel;
int currentLevel;
for (String field : iFetchPlan) {
parts=field.split(":");
depthLevel=Integer.parseInt(parts[1]);
if (depthLevel == 0) continue;
if (parts[0].equals(iCurrentField)) {
currentLevel=iCurrentLevel + 1;
if (depthLevel >= currentLevel) continue;
}
 else currentLevel=0;
if (recordToSend.size() >= iMaxFetch) return;
fieldValue=doc.field(parts[0]);
if (fieldValue != null && fieldValue instanceof ODocument) {
final ODocument linked=(ODocument)fieldValue;
recordToSend.add(linked);
fetchInDeep(linked,iFetchPlan,parts[0],currentLevel,iMaxFetch);
}
}
}
}
);
((OCommandRequestInternal)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk();
}
 catch (IOException e1) {
}
for (ODocument doc : recordToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal)connection.database.command(command)).execute();
sendOk();
if (result == null) {
channel.writeByte((byte)'n');
channel.writeBytes(null);
}
 else if (result instanceof ORecord<?>) {
channel.writeByte((byte)'r');
writeRecord((ORecordInternal<?>)result);
}
 else {
channel.writeByte((byte)'a');
channel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(result));
}
}
break;
}
case OChannelBinaryProtocol.DICTIONARY_LOOKUP:
{
data.commandInfo="Dictionary lookup";
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().get(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_PUT:
{
data.commandInfo="Dictionary put";
String key=channel.readString();
ORecordInternal<?> value=ORecordFactory.newInstance(channel.readByte());
final ORecordId rid=new ORecordId(channel.readString());
value.setIdentity(rid.clusterId,rid.clusterPosition);
value.setDatabase(connection.database);
value=connection.database.getDictionary().putRecord(key,value);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_REMOVE:
{
data.commandInfo="Dictionary remove";
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().remove(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_SIZE:
{
data.commandInfo="Dictionary size";
sendOk();
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.DICTIONARY_KEYS:
{
data.commandInfo="Dictionary keys";
sendOk();
channel.writeCollectionString(connection.database.getDictionary().keySet());
break;
}
case OChannelBinaryProtocol.TX_COMMIT:
data.commandInfo="Transaction commit";
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),new OTransactionOptimisticProxy((ODatabaseRecordTx<OTransactionRecordProxy>)connection.database.getUnderlying(),channel));
sendOk();
break;
default :
data.commandInfo="Command not supported";
OLogManager.instance().error(this,"Request not supported. Code: " + commandType);
channel.clearInput();
sendError(null);
}
}
 catch (EOFException eof) {
shutdown();
}
catch (SocketException e) {
shutdown();
}
catch (OException e) {
sendError(e);
}
catch (Throwable t) {
OLogManager.instance().error(this,"Error on executing request",t);
sendError(t);
}
 finally {
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
OSerializationThreadLocal.INSTANCE.get().clear();
data.lastCommandExecutionTime=System.currentTimeMillis() - data.lastCommandReceived;
data.totalCommandExecutionTime+=data.lastCommandExecutionTime;
data.lastCommandInfo=data.commandInfo;
data.lastCommandDetail=data.commandDetail;
}
}
