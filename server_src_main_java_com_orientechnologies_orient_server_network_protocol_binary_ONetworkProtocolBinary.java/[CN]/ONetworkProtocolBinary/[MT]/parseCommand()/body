{
switch (lastRequestType) {
case OChannelBinaryProtocol.REQUEST_SHUTDOWN:
{
      data.commandInfo="Shutdowning";
      OLogManager.instance().info(this,"Received shutdown command from the remote client %s:%d",channel.socket.getInetAddress(),channel.socket.getPort());
      user=channel.readString();
      passwd=channel.readString();
      if (OServerMain.server().authenticate(user,passwd,"shutdown")) {
        OLogManager.instance().info(this,"Remote client %s:%d authenticated. Starting shutdown of server...",channel.socket.getInetAddress(),channel.socket.getPort());
        channel.acquireExclusiveLock();
        try {
          sendOk(lastClientTxId);
        }
  finally {
          channel.releaseExclusiveLock();
        }
        channel.flush();
        channel.close();
        OServerMain.server().shutdown();
        System.exit(0);
        return;
      }
      OLogManager.instance().error(this,"Authentication error of remote client %s:%d: shutdown is aborted.",channel.socket.getInetAddress(),channel.socket.getPort());
      sendError(lastClientTxId,new OSecurityAccessException("Invalid user/password to shutdown the server"));
      break;
    }
case OChannelBinaryProtocol.REQUEST_CONNECT:
{
    data.commandInfo="Connect";
    serverLogin(channel.readString(),channel.readString(),"connect");
    channel.acquireExclusiveLock();
    try {
      sendOk(lastClientTxId);
      channel.writeInt(connection.id);
    }
  finally {
      channel.releaseExclusiveLock();
    }
    break;
  }
case OChannelBinaryProtocol.REQUEST_DB_LIST:
{
  data.commandInfo="List databases";
  ODocument doc=listDatabases();
  channel.acquireExclusiveLock();
  try {
    sendOk(lastClientTxId);
    channel.writeBytes(doc.toStream());
  }
  finally {
    channel.releaseExclusiveLock();
  }
  break;
}
case OChannelBinaryProtocol.REQUEST_DB_OPEN:
{
data.commandInfo="Open database";
String dbURL=channel.readString();
user=channel.readString();
passwd=channel.readString();
openDatabase(dbURL,user,passwd);
if (!(connection.database.getStorage() instanceof OStorageEmbedded) && !loadUserFromSchema(user,passwd)) {
  sendError(lastClientTxId,new OSecurityAccessException(connection.database.getName(),"User or password not valid for database: '" + connection.database.getName() + "'"));
}
 else {
  channel.acquireExclusiveLock();
  try {
    sendOk(lastClientTxId);
    channel.writeInt(connection.id);
    sendDatabaseInformation();
    if (getClass().equals(ONetworkProtocolBinary.class))     channel.writeBytes(null);
  }
  finally {
    channel.releaseExclusiveLock();
  }
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_RELOAD:
{
data.commandInfo="Reload database information";
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
sendDatabaseInformation();
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_CREATE:
{
data.commandInfo="Create database";
String dbName=channel.readString();
String storageMode=channel.readString();
checkServerAccess("database.create");
checkStorageExistence(dbName);
connection.database=getDatabaseInstance(dbName,storageMode);
createDatabase(connection.database,null,null);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_CLOSE:
data.commandInfo="Close Database";
if (connection != null) {
connection.close();
OClientConnectionManager.instance().disconnect(connection.id);
}
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
case OChannelBinaryProtocol.REQUEST_DB_EXIST:
{
data.commandInfo="Exists database";
String dbName=channel.readString();
checkServerAccess("database.exists");
connection.database=getDatabaseInstance(dbName,"local");
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_DELETE:
{
data.commandInfo="Delete database";
String dbName=channel.readString();
checkServerAccess("database.delete");
connection.database=getDatabaseInstance(dbName,"local");
OLogManager.instance().info(this,"Dropped database '%s",connection.database.getURL());
connection.database.delete();
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_SIZE:
{
data.commandInfo="Database size";
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(connection.database.getStorage().getSize());
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DB_COUNTRECORDS:
{
data.commandInfo="Database count records";
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(connection.database.getStorage().countRecords());
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_COUNT:
{
data.commandInfo="Count cluster elements";
int[] clusterIds=new int[channel.readShort()];
for (int i=0; i < clusterIds.length; ++i) clusterIds[i]=channel.readShort();
final long count=connection.database.countClusterElements(clusterIds);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(count);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_DATARANGE:
{
data.commandInfo="Get the begin/end range of data in cluster";
long[] pos=connection.database.getStorage().getClusterDataRange(channel.readShort());
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(pos[0]);
channel.writeLong(pos[1]);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_ADD:
{
data.commandInfo="Add cluster";
final String type=channel.readString();
final String name=channel.readString();
final int num;
OStorage.CLUSTER_TYPE t=OStorage.CLUSTER_TYPE.valueOf(type);
switch (t) {
case PHYSICAL:
num=connection.database.addPhysicalCluster(name,channel.readString(),channel.readInt());
break;
case MEMORY:
num=connection.database.getStorage().addCluster(name,t);
break;
case LOGICAL:
num=connection.database.addLogicalCluster(name,channel.readInt());
break;
default :
throw new IllegalArgumentException("Cluster type " + type + " is not supported");
}
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeShort((short)num);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_REMOVE:
{
data.commandInfo="Remove cluster";
final int id=channel.readShort();
boolean result=connection.database.dropCluster(connection.database.getClusterNameById(id));
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeByte((byte)(result ? 1 : 0));
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_LOAD:
{
data.commandInfo="Load record";
final ORecordId rid=channel.readRID();
final String fetchPlanString=channel.readString();
if (rid.clusterId == 0 && rid.clusterPosition == 0) {
OFetchHelper.checkFetchPlanValid(fetchPlanString);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeByte((byte)1);
channel.writeBytes(connection.database.getStorage().getConfiguration().toStream());
channel.writeInt(0);
channel.writeByte(ORecordBytes.RECORD_TYPE);
}
  finally {
channel.releaseExclusiveLock();
}
}
 else {
final ORecordInternal<?> record=connection.database.load(rid,fetchPlanString);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
if (record != null) {
channel.writeByte((byte)1);
channel.writeBytes(record.toStream());
channel.writeInt(record.getVersion());
channel.writeByte(record.getRecordType());
if (fetchPlanString.length() > 0) {
if (record instanceof ODocument) {
final Map<String,Integer> fetchPlan=OFetchHelper.buildFetchPlan(fetchPlanString);
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
final ODocument doc=(ODocument)record;
OFetchHelper.fetch(doc,doc,doc.fieldNames(),fetchPlan,null,0,-1,new OFetchListener(){
@Override public int size(){
return recordsToSend.size();
}
@Override public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) {
if (((ODocument)iLinked).getIdentity().isValid()) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
return null;
}
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
for (ODocument d : recordsToSend) {
if (d.getIdentity().isValid()) {
channel.writeByte((byte)2);
writeIdentifiable(d);
}
}
}
}
}
}
  finally {
channel.releaseExclusiveLock();
}
}
channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_CREATE:
{
data.commandInfo="Create record";
final ORecordId rid=new ORecordId(channel.readShort(),ORID.CLUSTER_POS_INVALID);
final byte[] buffer=channel.readBytes();
final byte recordType=channel.readByte();
final long clusterPosition=createRecord(rid,buffer,recordType);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(clusterPosition);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_UPDATE:
{
data.commandInfo="Update record";
final ORecordId rid=channel.readRID();
final byte[] buffer=channel.readBytes();
final int version=channel.readInt();
final byte recordType=channel.readByte();
final int newVersion=updateRecord(rid,buffer,version,recordType);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeInt(newVersion);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_DELETE:
{
data.commandInfo="Delete record";
final ORID rid=channel.readRID();
final int version=channel.readInt();
final int result=deleteRecord(rid,version);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeByte((byte)result);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_COUNT:
{
data.commandInfo="Count cluster records";
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(size);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_COMMAND:
{
data.commandInfo="Execute remote command";
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
final OQuery<?> query=(OQuery<?>)(command instanceof OQuery<?> ? command : null);
data.commandDetail=command.getText();
channel.acquireExclusiveLock();
try {
if (asynch) {
final StringBuilder empty=new StringBuilder();
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
final int txId=lastClientTxId;
final Map<String,Integer> fetchPlan=query != null ? OFetchHelper.buildFetchPlan(query.getFetchPlan()) : null;
command.setResultListener(new OCommandResultListener(){
@Override public boolean result(final Object iRecord){
if (empty.length() == 0) try {
sendOk(txId);
empty.append("-");
}
 catch (IOException e1) {
}
try {
channel.writeByte((byte)1);
writeIdentifiable((ORecordInternal<?>)iRecord);
if (fetchPlan != null && iRecord instanceof ODocument) {
final ODocument doc=(ODocument)iRecord;
OFetchHelper.fetch(doc,iRecord,doc.fieldNames(),fetchPlan,null,0,-1,new OFetchListener(){
@Override public int size(){
return recordsToSend.size();
}
@Override public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
}
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
((OCommandRequestInternal)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk(lastClientTxId);
}
 catch (IOException e1) {
}
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeIdentifiable(doc);
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal)connection.database.command(command)).execute();
sendOk(lastClientTxId);
if (result == null) {
channel.writeByte((byte)'n');
}
 else if (result instanceof OIdentifiable) {
channel.writeByte((byte)'r');
writeIdentifiable((OIdentifiable)result);
}
 else if (result instanceof Collection<?>) {
channel.writeByte((byte)'l');
final Collection<OIdentifiable> list=(Collection<OIdentifiable>)result;
channel.writeInt(list.size());
for (OIdentifiable o : list) {
writeIdentifiable(o);
}
}
 else {
channel.writeByte((byte)'a');
final StringBuilder value=new StringBuilder();
ORecordSerializerStringAbstract.fieldTypeToString(value,OType.getTypeByClass(result.getClass()),result);
channel.writeString(value.toString());
}
}
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_TX_COMMIT:
{
data.commandInfo="Transaction commit";
final OTransactionOptimisticProxy tx=new OTransactionOptimisticProxy((ODatabaseRecordTx)connection.database.getUnderlying(),channel);
connection.database.begin(tx);
try {
connection.database.commit();
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeInt(tx.getCreatedRecords().size());
for (Entry<ORecordId,ORecord<?>> entry : tx.getCreatedRecords().entrySet()) {
channel.writeRID(entry.getKey());
channel.writeRID(entry.getValue().getIdentity());
if (entry.getValue().getVersion() > 0) tx.getUpdatedRecords().put((ORecordId)entry.getValue().getIdentity(),entry.getValue());
}
channel.writeInt(tx.getUpdatedRecords().size());
for (Entry<ORecordId,ORecord<?>> entry : tx.getUpdatedRecords().entrySet()) {
channel.writeRID(entry.getKey());
channel.writeInt(entry.getValue().getVersion());
}
}
  finally {
channel.releaseExclusiveLock();
}
}
 catch (Exception e) {
connection.database.rollback();
sendError(lastClientTxId,e);
}
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_GET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.get");
final String key=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
String cfgValue=cfg != null ? cfg.getValueAsString() : "";
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeString(cfgValue);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_SET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.set");
final String key=channel.readString();
final String value=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
if (cfg != null) cfg.setValue(value);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_LIST:
{
data.commandInfo="List config";
checkServerAccess("server.config.get");
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeShort((short)OGlobalConfiguration.values().length);
for (OGlobalConfiguration cfg : OGlobalConfiguration.values()) {
channel.writeString(cfg.getKey());
channel.writeString(cfg.getValueAsString() != null ? cfg.getValueAsString() : "");
}
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
default :
data.commandInfo="Command not supported";
OLogManager.instance().error(this,"Request not supported. Code: " + lastRequestType);
channel.clearInput();
sendError(lastClientTxId,new ONetworkProtocolException("Request not supported. Code: " + lastRequestType));
}
}
