{
  super.begin();
  try {
    setUsingLog(channel.readByte() == 1);
    byte lastTxStatus;
    for (lastTxStatus=channel.readByte(); lastTxStatus == 1; lastTxStatus=channel.readByte()) {
      final byte recordStatus=channel.readByte();
      final ORecordId rid=channel.readRID();
      final byte recordType=channel.readByte();
      final ORecordOperation entry=new OTransactionEntryProxy(recordType);
      entry.type=recordStatus;
switch (recordStatus) {
case ORecordOperation.CREATED:
        entry.getRecord().fill(rid,OVersionFactory.instance().createVersion(),channel.readBytes(),true);
      createdRecords.put(rid.copy(),entry.getRecord());
    break;
case ORecordOperation.UPDATED:
  entry.getRecord().fill(rid,channel.readVersion(),channel.readBytes(),true);
if (protocolVersion >= 22) entry.getRecord().setContentChanged(channel.readBoolean());
break;
case ORecordOperation.DELETED:
entry.getRecord().fill(rid,channel.readVersion(),null,false);
break;
default :
throw new OTransactionException("Unrecognized tx command: " + recordStatus);
}
tempEntries.put(entry.getRecord().getIdentity(),entry);
}
if (lastTxStatus == -1) throw new OTransactionAbortedException("Transaction aborted by the client");
final ODocument remoteIndexEntries=new ODocument(channel.readBytes());
fillIndexOperations(remoteIndexEntries);
for (Entry<ORID,ORecordOperation> entry : tempEntries.entrySet()) {
if (entry.getValue().type == ORecordOperation.UPDATED) {
final ORecordInternal<?> record=entry.getValue().record.getRecord();
final ORecordInternal<?> loadedRecord=record.getIdentity().copy().getRecord();
if (loadedRecord == null) throw new ORecordNotFoundException(record.getIdentity().toString());
if (loadedRecord.getRecordType() == ODocument.RECORD_TYPE && loadedRecord.getRecordType() == record.getRecordType()) {
((ODocument)loadedRecord).merge((ODocument)record,false,false);
loadedRecord.getRecordVersion().copyFrom(record.getRecordVersion());
entry.getValue().record=loadedRecord;
updatedRecords.put((ORecordId)entry.getKey(),entry.getValue().getRecord());
}
}
addRecord(entry.getValue().getRecord(),entry.getValue().type,null);
}
tempEntries.clear();
for (ORecord<?> record : createdRecords.values()) unmarshallRecord(record);
for (ORecordInternal<?> record : updatedRecords.values()) unmarshallRecord(record);
}
 catch (IOException e) {
rollback();
throw new OSerializationException("Cannot read transaction record from the network. Transaction aborted",e);
}
}
