{
  checkForRebuild();
  key=getCollatingValue(key);
  modificationLock.requestModificationLock();
  try {
    checkForKeyType(key);
    acquireExclusiveLock();
    try {
      final OIdentifiable value=indexEngine.get(key);
      if (value != null) {
        if (!value.equals(iSingleValue)) {
          final Boolean mergeSameKey=metadata != null ? (Boolean)metadata.field(OIndex.MERGE_KEYS) : Boolean.FALSE;
          if (mergeSameKey != null && mergeSameKey)           ;
 else           throw new ORecordDuplicatedException(String.format("Cannot index record %s: found duplicated key '%s' in index '%s' previously assigned to the record %s",iSingleValue.getIdentity(),key,getName(),value.getIdentity()),value.getIdentity());
        }
 else         return this;
      }
      if (!iSingleValue.getIdentity().isPersistent())       ((ORecord)iSingleValue.getRecord()).save();
      markStorageDirty();
      indexEngine.put(key,iSingleValue.getIdentity());
      return this;
    }
  finally {
      releaseExclusiveLock();
    }
  }
  finally {
    modificationLock.releaseModificationLock();
  }
}
