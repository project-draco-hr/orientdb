{
  if (iRequest.getExecutionMode() == EXECUTION_MODE.NO_RESPONSE)   return null;
  final int queueSize=iNodes.size();
  final ODistributedResponse[] responses=new ODistributedResponse[queueSize];
  int receivedResponses=0;
  ODistributedResponse firstResponse=null;
  int availableNodes=0;
  for (  String node : iNodes) {
    if (manager.isNodeAvailable(node))     availableNodes++;
  }
  final int expectedSynchronousResponses=Math.min(availableNodes,Math.min(queueSize,writeQuorum));
  final long beginTime=System.currentTimeMillis();
  for (int i=0; i < expectedSynchronousResponses; ++i) {
    final long elapsed=System.currentTimeMillis() - beginTime;
    responses[i]=responseQueue.poll(MAX_PULL_TIMEOUT - elapsed,TimeUnit.MILLISECONDS);
    if (responses[i] != null) {
      if (responses[i].getRequestId() != iRequest.getId()) {
        ODistributedServerLog.error(this,getLocalNodeNameAndThread(),responses[i].getSenderNodeName(),DIRECTION.OUT,"ignore message from another request (%d)",responses[i].getRequestId());
        --i;
        continue;
      }
      ODistributedServerLog.debug(this,getLocalNodeNameAndThread(),responses[i].getSenderNodeName(),DIRECTION.IN,"- received response: %s",responses[i]);
      if (firstResponse == null)       firstResponse=responses[i];
      receivedResponses++;
    }
 else     ODistributedServerLog.warn(this,getLocalNodeNameAndThread(),null,DIRECTION.IN,"- timeout (%dms) on response for request: %s",elapsed,iRequest);
  }
  if (queueSize > writeQuorum) {
  }
  for (int i=0; i < responses.length; ++i) {
  }
  if (receivedResponses < writeQuorum) {
    iRequest.undo();
  }
  return firstResponse;
}
