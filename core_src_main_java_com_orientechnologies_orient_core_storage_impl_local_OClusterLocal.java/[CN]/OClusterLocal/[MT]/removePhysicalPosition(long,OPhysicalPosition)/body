{
  final long position=iPosition * RECORD_SIZE;
  acquireSharedLock();
  try {
    final long[] pos=getRelativePosition(position);
    final OFile file=files[(int)pos[0]];
    long p=pos[1];
    iPPosition.dataSegment=file.readShort(p);
    iPPosition.dataPosition=file.readLong(p+=OConstants.SIZE_SHORT);
    iPPosition.type=file.readByte(p+=OConstants.SIZE_LONG);
    iPPosition.version=file.readInt(p+=OConstants.SIZE_BYTE);
    holeSegment.pushPosition(position);
    file.writeInt(p,-1);
    if (iPosition == beginOffsetData) {
      if (getEntries() == 0)       beginOffsetData=-1;
 else {
        beginOffsetData++;
        long[] fetchPos;
        for (long currentPos=position + RECORD_SIZE; currentPos < getFilledUpTo(); currentPos+=RECORD_SIZE) {
          fetchPos=getRelativePosition(currentPos);
          if (files[(int)fetchPos[0]].readShort(fetchPos[1]) != -1)           break;
          beginOffsetData++;
        }
      }
      files[0].writeHeaderLong(0,beginOffsetData);
    }
    if (iPosition == endOffsetData) {
      if (getEntries() == 0)       endOffsetData=-1;
 else {
        endOffsetData--;
        long[] fetchPos;
        for (long currentPos=position - RECORD_SIZE; currentPos >= beginOffsetData; currentPos-=RECORD_SIZE) {
          fetchPos=getRelativePosition(currentPos);
          if (files[(int)fetchPos[0]].readShort(fetchPos[1]) != -1)           break;
          endOffsetData--;
        }
      }
      files[0].writeHeaderLong(OConstants.SIZE_LONG,endOffsetData);
    }
  }
  finally {
    releaseSharedLock();
  }
}
