{
  if (iValue == null)   return null;
  if (iType == null)   iType=OType.EMBEDDED;
switch (iType) {
case STRING:
    return "\"" + encode(iValue.toString()) + "\"";
case INTEGER:
case FLOAT:
case LONG:
case DOUBLE:
case SHORT:
case BOOLEAN:
  return String.valueOf(iValue);
case BYTE:
if (iValue instanceof Character) return String.valueOf((int)((Character)iValue).charValue());
 else if (iValue instanceof String) return String.valueOf((int)((String)iValue).charAt(0));
 else return String.valueOf(iValue);
case BINARY:
final String str;
if (iValue instanceof Byte) str=new String(new byte[]{((Byte)iValue).byteValue()});
 else str=OBase64Utils.encodeBytes((byte[])iValue);
return "\"" + str + "\"";
case DATE:
if (iValue instanceof Date) return String.valueOf(((Date)iValue).getTime());
 else return String.valueOf(iValue);
case LINK:
if (iValue instanceof ORID) return iValue.toString();
 else return ((ORecord<?>)iValue).getIdentity().toString();
case EMBEDDEDMAP:
return ORecordSerializerSchemaAware2CSV.INSTANCE.embeddedMapToStream(iDatabase,null,null,null,iValue,null,true);
case EMBEDDED:
return OStringSerializerAnyStreamable.INSTANCE.toStream(iDatabase,iValue);
}
throw new IllegalArgumentException("Type " + iType + " not supported to convert value: "+ iValue);
}
