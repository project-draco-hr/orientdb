{
  OExtendibleHashingTable extendibleHashingTable;
  MersenneTwisterFast random;
  List<Long> keys=new ArrayList<Long>();
  long i=0;
  while (i < MAX_SEED) {
    extendibleHashingTable=new OExtendibleHashingTable();
    random=new MersenneTwisterFast(i);
    keys.clear();
    while (keys.size() < KEYS_COUNT) {
      long key=random.nextLong(Long.MAX_VALUE);
      OPhysicalPosition position=new OPhysicalPosition(new OClusterPositionLong(key));
      if (extendibleHashingTable.put(position)) {
        keys.add(key);
        Assert.assertTrue(extendibleHashingTable.contains(position.clusterPosition),"key " + key);
      }
    }
    Collections.sort(keys);
    OExtendibleHashingTable.Entry[] hashTableEntries=extendibleHashingTable.ceilingEntries(new OClusterPositionLong(keys.get(10)));
    int curPos=0;
    for (    Long key : keys) {
      if (key < keys.get(10)) {
        continue;
      }
      OClusterPosition lhKey=hashTableEntries[curPos].key;
      Assert.assertEquals(new OClusterPositionLong(key),lhKey,"" + key);
      curPos++;
      if (curPos >= hashTableEntries.length) {
        hashTableEntries=extendibleHashingTable.higherEntries(hashTableEntries[hashTableEntries.length - 1].key);
        curPos=0;
      }
    }
    i++;
  }
}
