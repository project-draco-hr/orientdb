{
  acquireExclusiveLock();
  try {
    key=keySerializer.prepocess(key,(Object[])keyTypes);
    final long hashCode=keyHashFunction.hashCode(key);
    final BucketPath nodePath=getBucket(hashCode);
    final long bucketPointer=hashTree[nodePath.nodeIndex][nodePath.itemIndex + nodePath.hashMapOffset];
    final long pageIndex=getPageIndex(bucketPointer);
    final int fileLevel=getFileLevel(bucketPointer);
    final V removed;
    final OCacheEntry cacheEntry=loadPageEntry(pageIndex,fileLevel);
    final OCachePointer dataPointer=cacheEntry.getCachePointer();
    dataPointer.acquireExclusiveLock();
    try {
      final OHashIndexBucket<K,V> bucket=new OHashIndexBucket<K,V>(dataPointer.getDataPointer(),keySerializer,valueSerializer,keyTypes,keyHashFunction);
      final int positionIndex=bucket.getIndex(key);
      if (positionIndex < 0)       return null;
      removed=bucket.deleteEntry(positionIndex).value;
      size--;
      mergeBucketsAfterDeletion(nodePath,bucket);
      cacheEntry.markDirty();
    }
  finally {
      dataPointer.releaseExclusiveLock();
      diskCache.release(cacheEntry);
    }
    if (nodePath.parent != null) {
      final int hashMapSize=1 << nodePath.nodeLocalDepth;
      final long[] node=hashTree[nodePath.nodeIndex];
      final boolean allMapsContainSameBucket=checkAllMapsContainSameBucket(node,hashMapSize);
      if (allMapsContainSameBucket)       mergeNodeToParent(node,nodePath);
    }
    return removed;
  }
 catch (  IOException e) {
    throw new OIndexException("Error during index removal",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
