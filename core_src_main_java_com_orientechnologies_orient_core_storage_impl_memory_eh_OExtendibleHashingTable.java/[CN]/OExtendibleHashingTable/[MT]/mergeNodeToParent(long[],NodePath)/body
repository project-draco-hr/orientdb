{
  final int startIndex=findParentNodeStartIndex(nodePath);
  final int localNodeDepth=nodePath.nodeLocalDepth;
  final int hashMapSize=1 << localNodeDepth;
  final long[] parentNode=hashTree[nodePath.parent.nodeIndex];
  for (int i=0, k=startIndex; i < node.length; i+=hashMapSize, k++) {
    parentNode[k]=node[i];
  }
  deleteNode(nodePath.nodeIndex);
  final OExtendibleHashingNodeMetadata metadata=nodesMetadata[nodePath.parent.nodeIndex];
  if (nodePath.parent.itemIndex < maxLevelSize / 2) {
    final int maxChildDepth=metadata.getMaxLeftChildDepth();
    if (maxChildDepth == localNodeDepth)     metadata.setMaxLeftChildDepth(getMaxLevelDepth(parentNode,0,parentNode.length / 2));
  }
 else {
    final int maxChildDepth=metadata.getMaxRightChildDepth();
    if (maxChildDepth == localNodeDepth)     metadata.setMaxRightChildDepth(getMaxLevelDepth(parentNode,parentNode.length / 2,parentNode.length));
  }
}
