{
  final int[] clusterIds=iTarget.getClusterIds();
  final List<Integer> iterators=new ArrayList<Integer>();
  for (int i=0; i < clusterIds.length; ++i)   if (db.getStorage().getClusterById(clusterIds[i]).getEntries() > 0)   iterators.add(clusterIds[i]);
  final int threadNumber=iterators.size();
  OLogManager.instance().debug(this,"Executing parallel query with strategy one thread per cluster. clusterIds=%d, threads=%d",clusterIds.length,threadNumber);
  final Thread[] threads=new Thread[threadNumber];
  final boolean[] results=new boolean[threadNumber];
  final RuntimeException[] exceptions=new RuntimeException[threadNumber];
  for (int i=0; i < threadNumber; ++i) {
    final int current=i;
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        exceptions[current]=null;
        results[current]=true;
        final ODatabaseDocumentTx localDatabase=db.copy();
        try {
          db.getMetadata().getSchema().makeSnapshot();
          final ORecordIteratorCluster it=new ORecordIteratorCluster(localDatabase,localDatabase,iterators.get(current),true,false);
          while (it.hasNext()) {
            final ORecord next=it.next();
            if (!executeSearchRecord(next)) {
              results[current]=false;
              return;
            }
          }
        }
 catch (        RuntimeException t) {
          exceptions[current]=t;
        }
 finally {
          localDatabase.close();
        }
      }
    }
);
    threads[i].start();
  }
  for (int i=0; i < threadNumber; ++i) {
    try {
      threads[i].join();
    }
 catch (    InterruptedException e) {
    }
  }
  for (int i=0; i < threadNumber; ++i)   if (exceptions[i] != null)   throw exceptions[i];
  for (int i=0; i < threadNumber; ++i) {
    if (!results[i])     return false;
  }
  return true;
}
