{
  final int offset1=iValue1.offset;
  final int offset2=iValue2.offset;
  try {
switch (iType1) {
case INTEGER:
{
        final int value1=OVarIntSerializer.readAsInteger(iValue1);
switch (iType2) {
case INTEGER:
{
            final int value2=OVarIntSerializer.readAsInteger(iValue2);
            return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
          }
case LONG:
case DATETIME:
{
          final long value2=OVarIntSerializer.readAsLong(iValue2);
          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
        }
case DATE:
{
        final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
        return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
      }
case SHORT:
{
      final short value2=OVarIntSerializer.readAsShort(iValue2);
      return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
    }
case BYTE:
{
    final byte value2=OVarIntSerializer.readAsByte(iValue2);
    return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
  }
case FLOAT:
{
  final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
  return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final int value2=Integer.parseInt(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case LONG:
{
final long value1=OVarIntSerializer.readAsLong(iValue1);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
case DATETIME:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DATE:
{
final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final long value2=Long.parseLong(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case SHORT:
{
final short value1=OVarIntSerializer.readAsShort(iValue1);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
case DATETIME:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DATE:
{
final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final short value2=Short.parseShort(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case STRING:
{
final String value1=ORecordSerializerBinaryV0.readString(iValue1);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return value1.compareTo(Integer.toString(value2));
}
case LONG:
case DATETIME:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return value1.compareTo(Long.toString(value2));
}
case DATE:
{
final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
return value1.compareTo(Long.toString(value2));
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return value1.compareTo(Short.toString(value2));
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return value1.compareTo(Byte.toString(value2));
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return value1.compareTo(Float.toString(value2));
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return value1.compareTo(Double.toString(value2));
}
case STRING:
{
final String value2=ORecordSerializerBinaryV0.readString(iValue1);
return value1.compareTo(value2);
}
case BOOLEAN:
{
final boolean value2=ORecordSerializerBinaryV0.readByte(iValue1) == 1;
return value1.compareTo(Boolean.toString(value2));
}
}
break;
}
case DOUBLE:
{
final double value1=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue1));
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final double value2=Double.parseDouble(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case FLOAT:
{
final float value1=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue1));
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final float value2=Float.parseFloat(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case BYTE:
{
final byte value1=ORecordSerializerBinaryV0.readByte(iValue1);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=ORecordSerializerBinaryV0.readByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final byte value2=Byte.parseByte((ORecordSerializerBinaryV0.readString(iValue2)));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
}
break;
}
case BOOLEAN:
{
final boolean value1=ORecordSerializerBinaryV0.readByte(iValue1) == 1;
switch (iType2) {
case BOOLEAN:
{
final boolean value2=ORecordSerializerBinaryV0.readByte(iValue1) == 1;
return (value1 == value2) ? 0 : value1 ? 1 : 0;
}
case STRING:
{
final boolean value2=Boolean.parseBoolean(ORecordSerializerBinaryV0.readString(iValue2));
return (value1 == value2) ? 0 : value1 ? 1 : 0;
}
}
break;
}
case DATETIME:
{
final long value1=OVarIntSerializer.readAsLong(iValue1);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
case DATETIME:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DATE:
{
final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case BYTE:
{
final byte value2=OVarIntSerializer.readAsByte(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final String value2AsString=ORecordSerializerBinaryV0.readString(iValue2);
if (OIOUtils.isLong(value2AsString)) {
final long value2=Long.parseLong(value2AsString);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
try {
final Date value2AsDate=ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getConfiguration().getDateFormatInstance().parse(value2AsString);
final long value2=value2AsDate.getTime();
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
 catch (ParseException e) {
try {
final Date value2AsDate=ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getConfiguration().getDateTimeFormatInstance().parse(value2AsString);
final long value2=value2AsDate.getTime();
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
 catch (ParseException e1) {
return new Date(value1).toString().compareTo(value2AsString);
}
}
}
}
break;
}
case DATE:
{
final long value1=OVarIntSerializer.readAsLong(iValue1) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case LONG:
case DATETIME:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DATE:
{
final long value2=OVarIntSerializer.readAsLong(iValue2) * ORecordSerializerBinaryV0.MILLISEC_PER_DAY;
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
case STRING:
{
final String value2AsString=ORecordSerializerBinaryV0.readString(iValue2);
if (OIOUtils.isLong(value2AsString)) {
final long value2=Long.parseLong(value2AsString);
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
try {
final Date value2AsDate=ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getConfiguration().getDateTimeFormatInstance().parse(value2AsString);
final long value2=value2AsDate.getTime();
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
 catch (ParseException e) {
try {
final Date value2AsDate=ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getConfiguration().getDateFormatInstance().parse(value2AsString);
final long value2=value2AsDate.getTime();
return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);
}
 catch (ParseException e1) {
return new Date(value1).toString().compareTo(value2AsString);
}
}
}
}
break;
}
case BINARY:
{
switch (iType2) {
case BINARY:
{
final int length1=OVarIntSerializer.readAsInteger(iValue1);
final int length2=OVarIntSerializer.readAsInteger(iValue2);
for (int i=0; i < length1; ++i) {
final byte b1=iValue1.bytes[offset1 + i];
final byte b2=iValue2.bytes[offset2 + i];
if (b1 > b2) return 1;
 else if (b2 > b1) return -1;
}
return 0;
}
}
break;
}
case LINK:
{
switch (iType2) {
case LINK:
{
final int clusterId1=OVarIntSerializer.readAsInteger(iValue1);
final int clusterId2=OVarIntSerializer.readAsInteger(iValue2);
if (clusterId1 > clusterId2) return 1;
 else if (clusterId1 < clusterId2) return -1;
 else {
final long clusterPos1=OVarIntSerializer.readAsLong(iValue1);
final long clusterPos2=OVarIntSerializer.readAsLong(iValue2);
if (clusterPos1 > clusterPos2) return 1;
 else if (clusterPos1 < clusterPos2) return -1;
return 0;
}
}
case STRING:
{
return ORecordSerializerBinaryV0.readOptimizedLink(iValue1).compareTo(new ORecordId(ORecordSerializerBinaryV0.readString(iValue2)));
}
}
break;
}
case DECIMAL:
{
final BigDecimal value1=ODecimalSerializer.INSTANCE.deserialize(iValue1.bytes,iValue1.offset);
switch (iType2) {
case INTEGER:
{
final int value2=OVarIntSerializer.readAsInteger(iValue2);
return value1.compareTo(new BigDecimal(value2));
}
case LONG:
{
final long value2=OVarIntSerializer.readAsLong(iValue2);
return value1.compareTo(new BigDecimal(value2));
}
case SHORT:
{
final short value2=OVarIntSerializer.readAsShort(iValue2);
return value1.compareTo(new BigDecimal(value2));
}
case FLOAT:
{
final float value2=Float.intBitsToFloat(ORecordSerializerBinaryV0.readInteger(iValue2));
return value1.compareTo(new BigDecimal(value2));
}
case DOUBLE:
{
final double value2=Double.longBitsToDouble(ORecordSerializerBinaryV0.readLong(iValue2));
return value1.compareTo(new BigDecimal(value2));
}
case STRING:
{
final String value2=ORecordSerializerBinaryV0.readString(iValue2);
return value1.compareTo(new BigDecimal(value2));
}
}
break;
}
}
}
  finally {
iValue1.offset=offset1;
iValue2.offset=offset2;
}
return 1;
}
