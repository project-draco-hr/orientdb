{
  acquireSharedLock();
  try {
    if (clusterPosition < 0)     return new long[0];
    long pageIndex=clusterPosition / OClusterPositionMapBucket.MAX_ENTRIES;
    int index=(int)(clusterPosition % OClusterPositionMapBucket.MAX_ENTRIES);
    OAtomicOperation atomicOperation=storage.getAtomicOperationsManager().getCurrentOperation();
    final long filledUpTo=diskCache.getFilledUpTo(fileId);
    long[] result;
    if (pageIndex >= filledUpTo) {
      pageIndex=filledUpTo - 1;
      index=Integer.MIN_VALUE;
    }
    do {
      OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
      OClusterPositionMapBucket bucket=new OClusterPositionMapBucket(cacheEntry,getChangesTree(atomicOperation,cacheEntry));
      if (index == Integer.MIN_VALUE)       index=bucket.getSize() - 1;
      int resultSize=index + 1;
      int entriesCount=0;
      long startPosition=cacheEntry.getPageIndex() * OClusterPositionMapBucket.MAX_ENTRIES;
      result=new long[resultSize];
      for (int i=0; i < resultSize; i++) {
        if (bucket.exists(i)) {
          result[entriesCount]=startPosition + i;
          entriesCount++;
        }
      }
      if (entriesCount == 0) {
        result=null;
        pageIndex--;
        index=Integer.MIN_VALUE;
      }
 else       result=Arrays.copyOf(result,entriesCount);
      diskCache.release(cacheEntry);
    }
 while (result == null && pageIndex >= 0);
    if (result == null)     result=new long[0];
    return result;
  }
  finally {
    releaseSharedLock();
  }
}
