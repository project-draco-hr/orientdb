{
  checkOpeness();
  final ORecordId rid=(ORecordId)record.getIdentity();
  if (rid == null)   throw new ODatabaseException("Cannot delete record because it has no identity. Probably was created from scratch or contains projections of fields rather than a full record");
  if (!rid.isValid())   return;
  record=record.getRecord();
  if (record == null)   return;
  checkSecurity(ODatabaseSecurityResources.CLUSTER,ORole.PERMISSION_DELETE,getClusterNameById(rid.clusterId));
  final Set<OIndex<?>> lockedIndexes=new HashSet<OIndex<?>>();
  setCurrentDatabaseinThreadLocal();
  OSchemaProxy schemaProxy=getMetadata().getSchema();
  ORecordSerializationContext.pushContext(schemaProxy.updateSchemaCache());
  try {
    if (record instanceof ODocument)     acquireIndexModificationLock((ODocument)record,lockedIndexes);
    try {
      ORecord rec=record.getRecord();
      if (iCallTriggers && rec != null)       callbackHooks(TYPE.BEFORE_DELETE,rec);
      final ORecordVersion realVersion=mvcc ? iVersion : OVersionFactory.instance().createUntrackedVersion();
      final OStorageOperationResult<Boolean> operationResult;
      try {
        if (prohibitTombstones)         operationResult=new OStorageOperationResult<Boolean>(underlying.cleanOutRecord(rid,realVersion,iRequired,(byte)iMode.ordinal()));
 else         operationResult=underlying.delete(rid,realVersion,iRequired,(byte)iMode.ordinal());
        if (iCallTriggers) {
          if (!operationResult.isMoved() && rec != null)           callbackHooks(TYPE.AFTER_DELETE,rec);
 else           if (rec != null)           callbackHooks(TYPE.DELETE_REPLICATED,rec);
        }
      }
 catch (      Throwable t) {
        if (iCallTriggers)         callbackHooks(TYPE.DELETE_FAILED,rec);
        throw t;
      }
      if (!operationResult.isMoved()) {
        getLocalCache().deleteRecord(rid);
      }
    }
 catch (    OException e) {
      throw e;
    }
catch (    Throwable t) {
      throw new ODatabaseException("Error on deleting record in cluster #" + record.getIdentity().getClusterId(),t);
    }
  }
  finally {
    releaseIndexModificationLock(lockedIndexes);
    ORecordSerializationContext.pullContext();
  }
}
