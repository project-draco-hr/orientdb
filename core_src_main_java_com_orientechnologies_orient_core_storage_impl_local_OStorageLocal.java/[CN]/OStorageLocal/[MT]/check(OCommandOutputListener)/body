{
  int errors=0;
  int warnings=0;
  lock.acquireSharedLock();
  try {
    long totalRecors=0;
    final long start=System.currentTimeMillis();
    iListener.onMessage("\nChecking database '" + getName() + "'...\n");
    iListener.onMessage("\n(1) Checking clusters. This activity checks if pointers to data are coherent.\n");
    final OPhysicalPosition ppos=new OPhysicalPosition();
    for (    OCluster c : clusters) {
      if (!(c instanceof OClusterLocal))       continue;
      iListener.onMessage(String.format("- %5d %s",c.getId(),c.getName()));
      for (final OClusterPositionIterator it=c.absoluteIterator(); it.hasNext(); ) {
        final Long pos=it.next();
        totalRecors++;
        try {
          c.getPhysicalPosition(pos,ppos);
          if (ppos.dataSegmentId >= dataSegments.length) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong data segment %d",ppos.dataSegmentId);
            warnings++;
          }
          if (ppos.recordSize < 0) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong record size %d",ppos.recordSize);
            warnings++;
          }
          if (ppos.recordSize >= 1000000) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found suspected big record size %d. Is it corrupted?",ppos.recordSize);
            warnings++;
          }
          if (ppos.dataChunkPosition > dataSegments[ppos.dataSegmentId].getFilledUpTo()) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong pointer to data chunk %d out of data segment size (%d)",ppos.dataChunkPosition,dataSegments[ppos.dataSegmentId].getFilledUpTo());
            warnings++;
          }
          if (ppos.version < -1) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong record version %d",ppos.version);
            warnings++;
          }
 else           if (ppos.version == -1) {
            boolean found=false;
            int tot=((OClusterLocal)c).holeSegment.getHoles();
            for (int i=0; i < tot; ++i) {
              final long recycledPosition=((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE;
              if (recycledPosition == pos) {
                found=true;
                break;
              }
            }
            if (!found) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Cannot find hole for deleted record %d:%d",c.getId(),pos);
              warnings++;
            }
          }
        }
 catch (        IOException e) {
          OLogManager.instance().warn(this,"[OStorageLocal.check] Error while reading record #%d:%d",e,c.getId(),pos);
          warnings++;
        }
      }
      final int tot=((OClusterLocal)c).holeSegment.getHoles();
      if (tot > 0) {
        iListener.onMessage(" [found " + tot + " hole(s)]");
        for (int i=0; i < tot; ++i) {
          long recycledPosition=-1;
          try {
            recycledPosition=((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE;
            c.getPhysicalPosition(recycledPosition,ppos);
            if (ppos.version != -1) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong hole %d/%d for deleted record %d:%d. The record seems good",i,tot - 1,c.getId(),recycledPosition);
              warnings++;
            }
          }
 catch (          Exception e) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong hole %d/%d for deleted record %d:%d. The record not exists",i,tot - 1,c.getId(),recycledPosition);
            warnings++;
          }
        }
      }
      iListener.onMessage(" = OK\n");
    }
    int totalChunks=0;
    iListener.onMessage("\n(2) Checking data chunks integrity. In this phase data segments are scanned to check the back reference into the clusters.\n");
    for (    ODataLocal d : dataSegments) {
      int nextPos=0;
      for (int pos=0; nextPos < d.getFilledUpTo(); ) {
        try {
          pos=nextPos;
          int recordSize=d.getRecordSize(pos);
          if (recordSize < 0) {
            recordSize*=-1;
            nextPos=pos + recordSize;
            boolean found=false;
            for (            ODataHoleInfo hole : d.getHolesList()) {
              if (hole.dataOffset == pos) {
                found=true;
                if (hole.size != recordSize) {
                  OLogManager.instance().warn(this,"[OStorageLocal.check] chunk %d has size %d while the hole has %d",pos,recordSize,hole.size);
                  warnings++;
                }
                break;
              }
            }
            if (!found) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Cannot find hole for deleted chunk %d of size %d",pos,recordSize);
              warnings++;
            }
          }
 else {
            nextPos=pos + ODataLocal.RECORD_FIX_SIZE + recordSize;
            final byte[] buffer=d.getRecord(pos);
            if (buffer.length != recordSize) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong record size: found %d but record length is %d",recordSize,buffer.length);
              warnings++;
            }
            final ORecordId rid=d.getRecordRid(pos);
            if (!rid.isValid()) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Chunk at position %d points to invalid RID %s",pos,rid);
              warnings++;
            }
 else {
              if (clusters[rid.clusterId] == null) {
                OLogManager.instance().warn(this,"[OStorageLocal.check] Found ghost chunk at position %d pointed from %s. The cluster %d not exists",pos,rid,rid.clusterId);
                warnings++;
              }
 else {
                clusters[rid.clusterId].getPhysicalPosition(rid.clusterPosition,ppos);
                if (ppos.dataSegmentId != d.getId()) {
                  OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong record chunk data segment: found %d but current id is %d",ppos.dataSegmentId,d.getId());
                  warnings++;
                }
                if (ppos.dataChunkPosition != pos) {
                  OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong chunk position: cluster record points to %d, but current chunk is at %d",ppos.dataChunkPosition,pos);
                  warnings++;
                }
              }
            }
          }
          totalChunks++;
        }
 catch (        Exception e) {
          OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong chunk %d in %s:%d, cause: ",e,totalChunks,d.getName(),pos,e.toString());
          errors++;
        }
      }
    }
    iListener.onMessage("\nCheck of database completed in " + (System.currentTimeMillis() - start) + "ms:\n- Total records checked: "+ totalRecors+ "\n- Total chunks checked.: "+ totalChunks+ "\n- Warnings.............: "+ warnings+ "\n- Errors...............: "+ errors+ "\n");
  }
  finally {
    lock.releaseSharedLock();
  }
  return errors == 0;
}
