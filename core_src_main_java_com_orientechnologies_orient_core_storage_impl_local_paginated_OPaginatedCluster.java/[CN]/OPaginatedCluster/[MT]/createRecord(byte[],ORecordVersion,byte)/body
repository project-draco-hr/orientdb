{
  content=compression.compress(content);
  externalModificationLock.requestModificationLock();
  try {
    acquireExclusiveLock();
    try {
      int grownContentSize=(int)(config.recordGrowFactor * content.length);
      int entryContentLength=grownContentSize + 2 * OByteSerializer.BYTE_SIZE + OIntegerSerializer.INT_SIZE + OLongSerializer.LONG_SIZE;
      if (useCRC32)       entryContentLength+=OIntegerSerializer.INT_SIZE;
      if (entryContentLength < OClusterPage.MAX_RECORD_SIZE) {
        OAtomicOperation atomicOperation=startAtomicOperation();
        try {
          byte[] entryContent=new byte[entryContentLength];
          int entryPosition=0;
          entryContent[entryPosition]=recordType;
          entryPosition++;
          OIntegerSerializer.INSTANCE.serializeNative(content.length,entryContent,entryPosition);
          entryPosition+=OIntegerSerializer.INT_SIZE;
          System.arraycopy(content,0,entryContent,entryPosition,content.length);
          entryPosition+=grownContentSize;
          if (useCRC32) {
            CRC32 crc32=new CRC32();
            crc32.update(entryContent,0,entryPosition);
            OIntegerSerializer.INSTANCE.serializeNative((int)crc32.getValue(),entryContent,entryPosition);
            entryPosition+=OIntegerSerializer.INT_SIZE;
          }
          entryContent[entryPosition]=1;
          entryPosition++;
          OLongSerializer.INSTANCE.serializeNative(-1L,entryContent,entryPosition);
          final AddEntryResult addEntryResult=addEntry(recordVersion,entryContent,atomicOperation);
          updateClusterState(1,addEntryResult.recordsSizeDiff,atomicOperation);
          final long clusterPosition=clusterPositionMap.add(addEntryResult.pageIndex,addEntryResult.pagePosition);
          endAtomicOperation(false);
          return createPhysicalPosition(recordType,clusterPosition,addEntryResult.recordVersion);
        }
 catch (        Throwable e) {
          endAtomicOperation(true);
          throw new OStorageException(null,e);
        }
      }
 else {
        OAtomicOperation atomicOperation=startAtomicOperation();
        try {
          int entrySize=grownContentSize + OIntegerSerializer.INT_SIZE + OByteSerializer.BYTE_SIZE;
          if (useCRC32)           entrySize+=OIntegerSerializer.INT_SIZE;
          int fullEntryPosition=0;
          byte[] fullEntry=new byte[entrySize];
          fullEntry[fullEntryPosition]=recordType;
          fullEntryPosition++;
          OIntegerSerializer.INSTANCE.serializeNative(content.length,fullEntry,fullEntryPosition);
          fullEntryPosition+=OIntegerSerializer.INT_SIZE;
          System.arraycopy(content,0,fullEntry,fullEntryPosition,content.length);
          fullEntryPosition+=grownContentSize;
          if (useCRC32) {
            CRC32 crc32=new CRC32();
            crc32.update(fullEntry,0,fullEntryPosition);
            OIntegerSerializer.INSTANCE.serializeNative((int)crc32.getValue(),fullEntry,fullEntryPosition);
          }
          long prevPageRecordPointer=-1;
          long firstPageIndex=-1;
          int firstPagePosition=-1;
          ORecordVersion version=null;
          int from=0;
          int to=from + (OClusterPage.MAX_RECORD_SIZE - OByteSerializer.BYTE_SIZE - OLongSerializer.LONG_SIZE);
          int recordsSizeDiff=0;
          do {
            byte[] entryContent=new byte[to - from + OByteSerializer.BYTE_SIZE + OLongSerializer.LONG_SIZE];
            System.arraycopy(fullEntry,from,entryContent,0,to - from);
            if (from > 0)             entryContent[entryContent.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE]=0;
 else             entryContent[entryContent.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE]=1;
            OLongSerializer.INSTANCE.serializeNative(-1L,entryContent,entryContent.length - OLongSerializer.LONG_SIZE);
            final AddEntryResult addEntryResult=addEntry(recordVersion,entryContent,atomicOperation);
            recordsSizeDiff+=addEntryResult.recordsSizeDiff;
            if (firstPageIndex == -1) {
              firstPageIndex=addEntryResult.pageIndex;
              firstPagePosition=addEntryResult.pagePosition;
              version=addEntryResult.recordVersion;
            }
            long addedPagePointer=createPagePointer(addEntryResult.pageIndex,addEntryResult.pagePosition);
            if (prevPageRecordPointer >= 0) {
              long prevPageIndex=prevPageRecordPointer >>> PAGE_INDEX_OFFSET;
              int prevPageRecordPosition=(int)(prevPageRecordPointer & RECORD_POSITION_MASK);
              final OCacheEntry prevPageCacheEntry=loadPage(atomicOperation,fileId,prevPageIndex,false,diskCache);
              prevPageCacheEntry.acquireExclusiveLock();
              try {
                final OClusterPage prevPage=new OClusterPage(prevPageCacheEntry,false,getChangesTree(atomicOperation,prevPageCacheEntry));
                prevPage.setRecordLongValue(prevPageRecordPosition,-OLongSerializer.LONG_SIZE,addedPagePointer);
              }
  finally {
                prevPageCacheEntry.releaseExclusiveLock();
                releasePage(atomicOperation,prevPageCacheEntry,diskCache);
              }
            }
            prevPageRecordPointer=addedPagePointer;
            from=to;
            to=to + (OClusterPage.MAX_RECORD_SIZE - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE);
            if (to > fullEntry.length)             to=fullEntry.length;
          }
 while (from < to);
          updateClusterState(1,recordsSizeDiff,atomicOperation);
          long clusterPosition=clusterPositionMap.add(firstPageIndex,firstPagePosition);
          endAtomicOperation(false);
          return createPhysicalPosition(recordType,clusterPosition,version);
        }
 catch (        Throwable e) {
          endAtomicOperation(true);
          throw new OStorageException(null,e);
        }
      }
    }
  finally {
      releaseExclusiveLock();
    }
  }
  finally {
    externalModificationLock.releaseModificationLock();
  }
}
