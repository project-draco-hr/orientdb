{
  final NodePath nodePath=getBucket(clusterPosition);
  final long position=hashTree[nodePath.nodeIndex][nodePath.itemIndex + nodePath.hashMapOffset];
  final OExtendibleHashingBucket bucket=file.get((int)position - 1);
  final int positionIndex=bucket.getPosition(clusterPosition);
  if (positionIndex < 0)   return null;
  final OPhysicalPosition removedPosition=bucket.deleteEntry(positionIndex);
  if (bucket.size() > 0)   return removedPosition;
  mergeNodesAfterDeletion(nodePath,bucket,position);
  if (nodePath.parent != null) {
    final int hashMapSize=1 << nodePath.nodeLocalDepth;
    final long[] node=hashTree[nodePath.nodeIndex];
    final boolean allMapsContainSameBucket=checkAllMapsContainSameBucket(node,hashMapSize);
    if (allMapsContainSameBucket)     mergeNodeToParent(node,nodePath);
  }
  return removedPosition;
}
