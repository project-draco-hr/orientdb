{
  final Comparable<? super K> key=(Comparable<? super K>)iKey;
  if (entryPoints.size() == 0)   return root;
  OMVRBTreeEntryPersistent<K,V> e;
  int entryPointSize=entryPoints.size();
  int cmp;
  OMVRBTreeEntryPersistent<K,V> bestNode=null;
  if (entryPointSize < OMVRBTreeEntry.BINARY_SEARCH_THRESHOLD) {
    for (int i=0; i < entryPointSize; ++i) {
      e=entryPoints.get(i);
      if (e.serializedKeys == null) {
        OLogManager.instance().error(this,"Found wrong entrypoint in position %d",i);
        entryPoints.remove(i);
        --i;
        continue;
      }
      cmp=key.compareTo(e.getFirstKey());
      if (cmp < 0) {
        return bestNode != null ? bestNode : e;
      }
 else       if (cmp >= 0 && key.compareTo(e.getLastKey()) <= 0)       return e;
      bestNode=e;
    }
  }
 else {
    int low=0;
    int high=entryPointSize - 1;
    int mid=0;
    while (low <= high) {
      mid=(low + high) >>> 1;
      e=entryPoints.get(mid);
      if (e.serializedKeys == null) {
        OLogManager.instance().error(this,"Found wrong entrypoint in position %d",mid);
        entryPoints.remove(mid);
        low=0;
        entryPointSize=entryPoints.size();
        high=entryPointSize - 1;
        continue;
      }
      cmp=key.compareTo(e.getFirstKey());
      if (cmp >= 0 && key.compareTo(e.getLastKey()) <= 0)       return e;
      if (low == high)       break;
      if (cmp > 0)       low=mid + 1;
 else       high=mid;
      bestNode=e;
    }
    if (mid > 0 && key.compareTo(bestNode.getFirstKey()) < 0)     bestNode=entryPoints.get(mid - 1);
  }
  return bestNode;
}
