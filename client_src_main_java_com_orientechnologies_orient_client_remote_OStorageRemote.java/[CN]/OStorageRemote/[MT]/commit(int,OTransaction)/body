{
  checkConnection();
  do {
    boolean locked=lock.acquireExclusiveLock();
    try {
      final int reqId;
      final Set<OTransactionEntry> allEntries=new HashSet<OTransactionEntry>();
      try {
        reqId=beginRequest(OChannelBinaryProtocol.REQUEST_TX_COMMIT);
        network.writeInt(iTx.getId());
        final List<OTransactionEntry> tmpEntries=new ArrayList<OTransactionEntry>();
        while (iTx.getEntries().iterator().hasNext()) {
          for (          OTransactionEntry txEntry : iTx.getEntries())           if (!allEntries.contains(txEntry))           tmpEntries.add(txEntry);
          iTx.clearEntries();
          if (tmpEntries.size() > 0) {
            for (            OTransactionEntry txEntry : tmpEntries)             commitEntry(txEntry);
            allEntries.addAll(tmpEntries);
            tmpEntries.clear();
          }
        }
        network.writeByte((byte)0);
      }
  finally {
        endRequest();
      }
      try {
        beginResponse(reqId);
        final int updatedRecords=network.readInt();
        ORecordId rid;
        for (int i=0; i < updatedRecords; ++i) {
          rid=network.readRID();
          for (          OTransactionEntry txEntry : allEntries) {
            if (txEntry.getRecord().getIdentity().equals(rid)) {
              txEntry.getRecord().setVersion(network.readInt());
              break;
            }
          }
        }
      }
  finally {
        endResponse();
      }
      OTransactionAbstract.updateCacheFromEntries(this,iTx,allEntries);
      break;
    }
 catch (    Exception e) {
      handleException("Error on commit",e);
    }
 finally {
      lock.releaseExclusiveLock(locked);
    }
  }
 while (true);
}
