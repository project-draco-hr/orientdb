{
  acquireSharedLock();
  try {
    long position=clusterPosition.longValue();
    if (position < 0)     position=0;
    long pageIndex=position / OClusterPositionMapBucket.MAX_ENTRIES;
    int index=(int)(position % OClusterPositionMapBucket.MAX_ENTRIES);
    final long filledUpTo=diskCache.getFilledUpTo(fileId);
    if (pageIndex >= filledUpTo)     return new OClusterPosition[0];
    OClusterPosition[] result=null;
    do {
      OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
      OCachePointer cachePointer=cacheEntry.getCachePointer();
      OClusterPositionMapBucket bucket=new OClusterPositionMapBucket(cachePointer.getDataPointer(),ODurablePage.TrackMode.NONE);
      int resultSize=bucket.getSize() - index;
      if (resultSize <= 0) {
        diskCache.release(cacheEntry);
        pageIndex++;
      }
 else {
        int entriesCount=0;
        long startIndex=cacheEntry.getPageIndex() * OClusterPositionMapBucket.MAX_ENTRIES + index;
        result=new OClusterPosition[resultSize];
        for (int i=0; i < resultSize; i++) {
          if (bucket.exists(i + index)) {
            result[entriesCount]=OClusterPositionFactory.INSTANCE.valueOf(startIndex + i);
            entriesCount++;
          }
        }
        if (entriesCount == 0) {
          result=null;
          pageIndex++;
          index=0;
        }
 else         result=Arrays.copyOf(result,entriesCount);
        diskCache.release(cacheEntry);
      }
    }
 while (result == null && pageIndex < filledUpTo);
    if (result == null)     result=new OClusterPosition[0];
    return result;
  }
  finally {
    releaseSharedLock();
  }
}
