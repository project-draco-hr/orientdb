{
  if (!groupResponsesByResult || request.getTask().getQuorumType() == OAbstractRemoteTask.QUORUM_TYPE.NONE)   return;
  if (dManager.getNodeStatus() != ODistributedServerManager.NODE_STATUS.ONLINE)   return;
  final int bestResponsesGroupIndex=getBestResponsesGroup();
  final List<ODistributedResponse> bestResponsesGroup=responseGroups.get(bestResponsesGroupIndex);
  final int maxCoherentResponses=bestResponsesGroup.size();
  final int conflicts=getExpectedResponses() - maxCoherentResponses;
  if (isMinimumQuorumReached(true)) {
    if (responseGroups.size() == 1)     return;
    if (checkNoWinnerCase(bestResponsesGroup))     return;
    ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,"detected %d conflicts, but the quorum (%d) has been reached. Fixing remote records. Request (%s)",conflicts,quorum,request);
    fixNodesInConflict(bestResponsesGroup);
  }
 else {
    ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,"detected %d node(s) in timeout or in conflict and quorum (%d) has not been reached, rolling back changes for request (%s)",conflicts,quorum,request);
    final StringBuilder msg=new StringBuilder(256);
    msg.append("Quorum " + getQuorum() + " not reached for request ("+ request+ "). Timeout="+ (System.currentTimeMillis() - sentOn)+ "ms");
    final List<ODistributedResponse> res=getConflictResponses();
    if (res.isEmpty())     msg.append(" No server in conflict. ");
 else {
      msg.append(" Servers in timeout/conflict are:");
      for (      ODistributedResponse r : res) {
        msg.append("\n - ");
        msg.append(r.getExecutorNodeName());
        msg.append(": ");
        msg.append(r.getPayload());
      }
      msg.append("\n");
    }
    msg.append("Received: ");
    msg.append(responses);
    ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,msg.toString());
    undoRequest();
    throw new ODistributedException(msg.toString());
  }
}
