{
  OLogManager.instance().info(this,"DISTRIBUTED <-[%s/%s] align request starting from %d.%d",nodeSource,databaseName,lastRunId,lastOperationId);
  int aligned;
  final ODistributedServerManager dManager=getDistributedServerManager();
  final String localNode=dManager.getLocalNodeId();
  final OStorageSynchronizer synchronizer=getDatabaseSynchronizer();
  if (synchronizer == null)   return 0;
  final ODatabaseJournal log=synchronizer.getLog();
  final Lock alignmentLock=dManager.getLock("align." + databaseName);
  if (alignmentLock.tryLock())   try {
    aligned=0;
    final OMultipleDistributedTasks tasks=new OMultipleDistributedTasks(localNode,databaseName,EXECUTION_MODE.SYNCHRONOUS);
    final List<Long> positions=new ArrayList<Long>();
    Iterator<Long> it=log.browse(new long[]{lastRunId,lastOperationId});
    while (it.hasNext()) {
      final long pos=it.next();
      final OAbstractDistributedTask<?> operation=log.getOperation(pos);
      if (operation == null) {
        OLogManager.instance().info(this,"DISTRIBUTED ->[%s/%s] skipped operation #%d.%d",nodeSource,databaseName,lastRunId,lastOperationId);
        continue;
      }
      OLogManager.instance().info(this,"DISTRIBUTED ->[%s/%s] operation %s",nodeSource,databaseName,operation);
      operation.setNodeSource(localNode);
      operation.setDatabaseName(databaseName);
      operation.setMode(EXECUTION_MODE.SYNCHRONOUS);
      tasks.addTask(operation);
      positions.add(pos);
      if (tasks.getTasks() >= OP_BUFFER)       aligned+=flushBufferedTasks(dManager,synchronizer,tasks,positions);
    }
    if (tasks.getTasks() > 0)     aligned+=flushBufferedTasks(dManager,synchronizer,tasks,positions);
    OLogManager.instance().info(this,"DISTRIBUTED ->[%s/%s] aligned %d operations",nodeSource,databaseName,aligned);
  }
  finally {
    alignmentLock.unlock();
  }
 else   aligned=-1;
  dManager.sendOperation2Node(nodeSource,new OAlignResponseDistributedTask(localNode,databaseName,EXECUTION_MODE.FIRE_AND_FORGET,aligned));
  return aligned;
}
