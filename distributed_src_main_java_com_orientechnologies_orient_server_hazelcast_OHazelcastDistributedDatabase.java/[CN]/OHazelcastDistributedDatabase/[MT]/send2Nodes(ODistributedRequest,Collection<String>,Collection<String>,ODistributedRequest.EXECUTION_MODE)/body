{
  checkForServerOnline(iRequest);
  final String databaseName=iRequest.getDatabaseName();
  if (iNodes.isEmpty()) {
    ODistributedServerLog.error(this,getLocalNodeName(),null,DIRECTION.OUT,"No nodes configured for database '%s' request: %s",databaseName,iRequest);
    throw new ODistributedException("No nodes configured for partition '" + databaseName + "' request: "+ iRequest);
  }
  final ODistributedConfiguration cfg=manager.getDatabaseConfiguration(databaseName);
  final OPair<String,IQueue>[] reqQueues=getRequestQueues(databaseName,iNodes,iRequest.getTask());
  iRequest.setSenderNodeName(getLocalNodeName());
  final int onlineNodes=getAvailableNodes(iRequest,iNodes,databaseName,reqQueues);
  final int quorum=calculateQuorum(iRequest,iClusterNames,cfg,onlineNodes,iExecutionMode);
  final int queueSize=iNodes.size();
  int expectedSynchronousResponses=onlineNodes;
  final boolean groupByResponse;
  if (iRequest.getTask().getResultStrategy() == OAbstractRemoteTask.RESULT_STRATEGY.UNION) {
    expectedSynchronousResponses=onlineNodes;
    groupByResponse=false;
  }
 else {
    groupByResponse=true;
  }
  final boolean waitLocalNode=waitForLocalNode(cfg,iClusterNames,iNodes);
  final ODistributedResponseManager currentResponseMgr=new ODistributedResponseManager(manager,iRequest,iNodes,expectedSynchronousResponses,quorum,waitLocalNode,iRequest.getTask().getSynchronousTimeout(expectedSynchronousResponses),iRequest.getTask().getTotalTimeout(queueSize),groupByResponse);
  final long timeout=OGlobalConfiguration.DISTRIBUTED_QUEUE_TIMEOUT.getValueAsLong();
  final int queueMaxSize=OGlobalConfiguration.DISTRIBUTED_QUEUE_MAXSIZE.getValueAsInteger();
  try {
    requestLock.lock();
    try {
      iRequest.setId(msgService.getMessageIdCounter().getAndIncrement());
      if (ODistributedServerLog.isDebugEnabled())       ODistributedServerLog.debug(this,getLocalNodeName(),iNodes.toString(),DIRECTION.OUT,"sending request %s",iRequest);
      msgService.registerRequest(iRequest.getId(),currentResponseMgr);
      for (      OPair<String,IQueue> entry : reqQueues) {
        final String node=entry.getKey();
        final IQueue queue=entry.getValue();
        if (queue != null) {
          int nodeQueueSize=queue.size();
          if (queueMaxSize > 0 && nodeQueueSize > queueMaxSize) {
            final int nodeQueuePrevSize=queueSizes.getOrDefault(node,0);
            final int nodeQueueWarnings=queueWarningCounter.getOrDefault(node,0);
            final ODistributedServerManager.DB_STATUS nodeStatus=manager.getDatabaseStatus(node,databaseName);
            if (nodeStatus == ODistributedServerManager.DB_STATUS.SYNCHRONIZING || nodeStatus == ODistributedServerManager.DB_STATUS.BACKUP) {
              queue.offer(iRequest,timeout,TimeUnit.MILLISECONDS);
              queueWarningCounter.remove(node);
            }
 else             if (nodeQueueSize < nodeQueuePrevSize || nodeQueueWarnings < 10) {
              queue.offer(iRequest,timeout,TimeUnit.MILLISECONDS);
              if (System.currentTimeMillis() - manager.getLastClusterChangeOn() > 10000) {
                queueWarningCounter.put(node,nodeQueueWarnings + 1);
                ODistributedServerLog.debug(this,getLocalNodeName(),node,DIRECTION.OUT,"queue '%s' has too many messages (%d), checking if the node is in stall (warnings=%d)",queue.getName(),nodeQueueSize,nodeQueueWarnings);
              }
 else {
                queueWarningCounter.remove(node);
                ODistributedServerLog.debug(this,getLocalNodeName(),node,DIRECTION.OUT,"queue '%s' has too many messages (%d), but the cluster shape is changed recently (%d secs)",queue.getName(),nodeQueueSize,((System.currentTimeMillis() - manager.getLastClusterChangeOn()) / 1000));
              }
            }
 else {
              ODistributedServerLog.warn(this,getLocalNodeName(),node,DIRECTION.OUT,"queue '%s' has too many messages (%d), treating the node as in stall: trying to restart it...",queue.getName(),nodeQueueSize);
              queue.clear();
              queueWarningCounter.remove(node);
              nodeQueueSize=0;
              manager.disconnectNode(entry.getKey());
            }
          }
 else {
            queue.offer(iRequest,timeout,TimeUnit.MILLISECONDS);
            queueWarningCounter.remove(node);
          }
          queueSizes.put(node,nodeQueueSize);
        }
      }
    }
  finally {
      requestLock.unlock();
    }
    if (ODistributedServerLog.isDebugEnabled())     ODistributedServerLog.debug(this,getLocalNodeName(),iNodes.toString(),DIRECTION.OUT,"sent request %s",iRequest);
    Orient.instance().getProfiler().updateCounter("distributed.db." + databaseName + ".msgSent","Number of replication messages sent from current node",+1,"distributed.db.*.msgSent");
    return waitForResponse(iRequest,currentResponseMgr);
  }
 catch (  Exception e) {
    throw OException.wrapException(new ODistributedException("Error on executing distributed request (" + iRequest + ") against database '"+ databaseName+ (iClusterNames != null ? "." + iClusterNames : "")+ "' to nodes "+ iNodes),e);
  }
}
