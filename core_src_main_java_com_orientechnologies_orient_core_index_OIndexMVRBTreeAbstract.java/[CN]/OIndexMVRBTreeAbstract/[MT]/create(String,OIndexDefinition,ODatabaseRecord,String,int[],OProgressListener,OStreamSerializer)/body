{
  acquireExclusiveLock();
  try {
    name=iName;
    configuration=new ODocument();
    indexDefinition=iIndexDefinition;
    maxUpdatesBeforeSave=lazyUpdates();
    if (iClusterIdsToIndex != null)     for (    final int id : iClusterIdsToIndex)     clustersToIndex.add(iDatabase.getClusterNameById(id));
    if (indexDefinition != null) {
      if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {
        map=new OMVRBTreeDatabaseLazySave<Object,T>(iClusterIndexName,((ORuntimeKeyIndexDefinition)indexDefinition).getSerializer(),iValueSerializer,1,maxUpdatesBeforeSave);
      }
 else {
        final OBinarySerializer<?> keySerializer;
        if (indexDefinition.getTypes().length > 1) {
          keySerializer=OCompositeKeySerializer.INSTANCE;
        }
 else {
          keySerializer=OBinarySerializerFactory.INSTANCE.getObjectSerializer(indexDefinition.getTypes()[0]);
        }
        map=new OMVRBTreeDatabaseLazySave<Object,T>(iClusterIndexName,(OBinarySerializer<Object>)keySerializer,iValueSerializer,indexDefinition.getTypes().length,maxUpdatesBeforeSave);
      }
    }
 else     map=new OMVRBTreeDatabaseLazySave<Object,T>(iClusterIndexName,new OSimpleKeySerializer(),iValueSerializer,1,maxUpdatesBeforeSave);
    installHooks(iDatabase);
    rebuild(iProgressListener);
    updateConfiguration();
  }
 catch (  Exception e) {
    if (map != null)     map.delete();
    if (e instanceof OIndexException)     throw (OIndexException)e;
    throw new OIndexException("Cannot create the index '" + iName + "'",e);
  }
 finally {
    releaseExclusiveLock();
  }
  return this;
}
