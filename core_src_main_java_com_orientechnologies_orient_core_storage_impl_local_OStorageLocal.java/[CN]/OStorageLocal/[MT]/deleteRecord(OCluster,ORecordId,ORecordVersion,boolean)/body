{
  assert(lock.assertExclusiveLockHold());
  final long timer=Orient.instance().getProfiler().startChrono();
  try {
    lockManager.acquireLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    try {
      final OPhysicalPosition ppos=iClusterSegment.getPhysicalPosition(new OPhysicalPosition(iRid.clusterPosition));
      if (ppos == null || ppos.dataSegmentId < 0 || (useTombstones && ppos.recordVersion.isTombstone()))       return null;
      if (iVersion.getCounter() > -1 && !ppos.recordVersion.equals(iVersion))       if (OFastConcurrentModificationException.enabled())       throw OFastConcurrentModificationException.instance();
 else       throw new OConcurrentModificationException(iRid,ppos.recordVersion,iVersion,ORecordOperation.DELETED);
      if (!ppos.recordVersion.isTombstone() && ppos.dataSegmentPos > -1) {
        try {
          getDataSegmentById(ppos.dataSegmentId).deleteRecord(ppos.dataSegmentPos);
        }
 catch (        OIOException e) {
          OLogManager.instance().error(this,"Cannot remove the record in data segment, however remove it from cluster",e);
        }
      }
      if (useTombstones && iClusterSegment.hasTombstonesSupport())       iClusterSegment.convertToTombstone(iRid.clusterPosition);
 else       iClusterSegment.removePhysicalPosition(iRid.clusterPosition);
      return ppos;
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    }
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"Error on deleting record " + iRid + "( cluster: "+ iClusterSegment+ ")",e);
  }
 finally {
    Orient.instance().getProfiler().stopChrono(PROFILER_DELETE_RECORD,"Delete a record from database",timer,"db.*.deleteRecord");
  }
  return null;
}
