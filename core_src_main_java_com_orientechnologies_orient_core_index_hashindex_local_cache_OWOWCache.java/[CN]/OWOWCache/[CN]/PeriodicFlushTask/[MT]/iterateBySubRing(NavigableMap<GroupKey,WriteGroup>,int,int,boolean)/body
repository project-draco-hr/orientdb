{
  Iterator<Map.Entry<GroupKey,WriteGroup>> entriesIterator=subMap.entrySet().iterator();
  long currentTime=System.currentTimeMillis();
  groupsLoop:   while (entriesIterator.hasNext() && flushedWriteGroups < writeGroupsToFlush) {
    Map.Entry<GroupKey,WriteGroup> entry=entriesIterator.next();
    final WriteGroup group=entry.getValue();
    final GroupKey groupKey=entry.getKey();
    lockManager.acquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    try {
      if (group.recencyBit && group.creationTime - currentTime < groupTTL && !forceFlush)       group.recencyBit=false;
 else {
        List<PageKey> lockedPages=new ArrayList<PageKey>();
        for (int i=0; i < 16; i++) {
          final PageKey pageKey=new PageKey(groupKey.fileId,groupKey.groupIndex << 4 + i);
          pageFlushLockManger.acquireLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED);
          lockedPages.add(pageKey);
        }
        try {
          for (          OCachePointer pagePointer : group.pages) {
            if (pagePointer != null && pagePointer.getUsagesCount() > 0)             continue groupsLoop;
          }
          for (int i=0; i < 16; i++) {
            final OCachePointer pagePointer=group.pages[i];
            if (pagePointer != null) {
              flushPage(groupKey.fileId,groupKey.groupIndex * 16 + i,pagePointer.getDataPointer());
              pagePointer.decrementReferrer();
              cacheSize.decrementAndGet();
            }
          }
          lastGroupKey=entry.getKey();
          entriesIterator.remove();
          flushedWriteGroups++;
        }
  finally {
          for (          PageKey pageKey : lockedPages)           pageFlushLockManger.releaseLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED);
        }
      }
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    }
  }
  return flushedWriteGroups;
}
