{
switch (requestType) {
case OClusterProtocol.REQUEST_NODE2NODE_CONNECT:
{
      commandInfo="Connection from node";
      remoteNodeId=channel.readString();
      logger.setNode(remoteNodeId);
      logger.log(this,Level.FINE,TYPE.REPLICATION,DIRECTION.IN,"connected, authenticating it...");
      setName("OrientDB <- Node/" + remoteNodeId);
      final String userName=channel.readString();
      serverUser=OServerMain.server().serverLogin(userName,channel.readString(),"connect");
      logger.log(this,Level.FINE,TYPE.REPLICATION,DIRECTION.IN,"authenticated correctly with user '%s'",userName);
      beginResponse();
      try {
        sendOk(clientTxId);
      }
  finally {
        endResponse();
      }
      break;
    }
case OClusterProtocol.REQUEST_LEADER2PEER_CONNECT:
{
    commandInfo="Connection from leader";
    final ODocument doc=new ODocument().fromStream(channel.readBytes());
    final String clusterName=doc.field("clusterName");
    final byte[] encodedSecurityKey=doc.field("clusterKey");
    final String leaderAddress=doc.field("leaderNodeAddress");
    logger.setNode(leaderAddress);
    if (!clusterName.equals(manager.getName()) || !Arrays.equals(encodedSecurityKey,manager.getConfig().getSecurityKey()))     throw new OSecurityException("Invalid combination of cluster name and key received");
    boolean remainTheLeader=false;
    beginResponse();
    try {
      sendOk(clientTxId);
      if (manager.isLeader()) {
        logger.log(this,Level.WARNING,TYPE.CLUSTER,DIRECTION.IN,"received remote connection from the leader, but current node is itself leader: split network problem or high network latency?");
        final String myUid=InetAddress.getLocalHost().getHostAddress() + ":" + channel.socket.getLocalPort();
        if (leaderAddress.compareTo(myUid) > 0) {
          remainTheLeader=true;
          logger.log(this,Level.WARNING,TYPE.CLUSTER,DIRECTION.NONE,"current node remains the Leader of the cluster because it has lower network address");
        }
      }
      channel.writeByte((byte)(remainTheLeader ? 0 : 1));
      if (!remainTheLeader) {
        final ODocument localCfg=manager.getReplicator().getLocalDatabaseConfiguration();
        channel.writeBytes(localCfg.toStream());
      }
    }
  finally {
      endResponse();
    }
    if (remainTheLeader)     sendShutdown();
 else {
      setName("OrientDB <- Distributed Leader");
      manager.becomePeer(this);
      manager.getReplicator().updateConfiguration(new ODocument(channel.readBytes()));
    }
    break;
  }
case OClusterProtocol.REQUEST_LEADER2PEER_HEARTBEAT:
checkConnected();
commandInfo="Cluster Heartbeat";
final long lastInterval=manager.updateHeartBeatTime();
logger.log(this,Level.FINE,TYPE.CLUSTER,DIRECTION.IN,"heartbeat. Last msg was %dms ago",lastInterval);
beginResponse();
try {
sendOk(clientTxId);
}
  finally {
endResponse();
}
break;
case OClusterProtocol.REQUEST_NODE2NODE_REPLICATION_SYNCHRONIZE:
{
commandInfo="Synchronization between nodes";
final String dbName=channel.readString();
final ODocument cfg=new ODocument(channel.readBytes());
logger.setDatabase(dbName);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"received synchronization request");
getOrOpenDatabase(dbName);
beginResponse();
try {
sendOk(clientTxId);
}
  finally {
endResponse();
}
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.OUT,"opening a connection back...");
manager.getReplicator().connect(remoteNodeId,dbName,SYNCH_TYPE.ASYNCH.toString());
final ODistributedNode replicationNode=manager.getReplicator().getNode(remoteNodeId);
final ORecordOperation op=new ORecordOperation();
Collection<ODocument> nodes=cfg.field("nodes");
int sent=0;
for (ODocument nodeCfg : nodes) {
final String node=nodeCfg.field("node");
final long lastLog=(Long)nodeCfg.field("lastLog");
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"reading operation for node %s logs after %d",node,lastLog);
final OOperationLog opLog=manager.getReplicator().getOperationLog(node,dbName);
if (opLog != null) {
final int position=opLog.findOperationId(lastLog);
if (position > -1) {
final int totalToSend=opLog.totalEntries();
for (int i=position; i < totalToSend; ++i) {
opLog.getEntry(i,op);
try {
replicationNode.propagateChange(op,SYNCH_TYPE.SYNCH);
sent++;
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"#%d operation %d with RID %s",sent,op.serial,op.record.getIdentity());
}
 catch (OSerializationException e) {
logger.log(this,Level.SEVERE,TYPE.REPLICATION,DIRECTION.OUT,"#%d cannot be transmitted, log entry %d, record %s: ",sent,op.serial,op.record.getIdentity(),e.getCause());
}
catch (RuntimeException e) {
logger.log(this,Level.SEVERE,TYPE.REPLICATION,DIRECTION.OUT,"#%d cannot be transmitted, log entry %d, record %s",e,sent,op.serial,op.record.getIdentity());
throw e;
}
}
}
}
}
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.OUT,"starting inverse replication...");
manager.getReplicator().startReplication(remoteNodeId,dbName,SYNCH_TYPE.ASYNCH.toString());
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.OUT,"synchronization completed");
break;
}
case OClusterProtocol.REQUEST_NODE2NODE_REPLICATION_ALIGN:
{
commandInfo="Alignment between nodes";
final ODocument cfg=new ODocument(channel.readBytes());
final String dbName=cfg.field("db");
final ODocument block=cfg.field("block");
logger.setDatabase(dbName);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"received alignment request");
final ODatabaseRecord db=getOrOpenDatabase(dbName);
final OStorage storage=db.getStorage();
final ODistributedNode remoteNode=manager.getReplicator().getNode(remoteNodeId);
beginResponse();
try {
sendOk(clientTxId);
}
  finally {
endResponse();
}
ORecordId rid=new ORecordId();
for (String ridAsString : block.fieldNames()) {
rid.fromString(ridAsString);
final ORawBuffer localRecord=storage.readRecord(rid,null,false,null);
final int remoteVersion=block.field(ridAsString);
if (localRecord.version == -1) {
if (remoteVersion > -1) remoteNode.propagateChange(new ORecordOperation(rid,ORecordOperation.DELETED),SYNCH_TYPE.SYNCH);
}
 else if (remoteVersion == -1) {
if (localRecord.version > -1) db.delete(rid);
}
 else if (localRecord.version > remoteVersion) {
logger.log(this,Level.FINE,TYPE.REPLICATION,DIRECTION.IN,"Sending record %s to remote: my version %d > remote %d",rid,localRecord.version,remoteVersion);
remoteNode.propagateChange(new ORecordOperation(rid,ORecordOperation.UPDATED),SYNCH_TYPE.SYNCH);
}
 else if (localRecord.version < remoteVersion) {
logger.log(this,Level.FINE,TYPE.REPLICATION,DIRECTION.IN,"Getting remote record %s: its version %d > mine %d",rid,remoteVersion,localRecord.version);
remoteNode.requestRecord(dbName,rid);
}
}
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.OUT,"alignment completed for %d",block.fields());
break;
}
case OClusterProtocol.REQUEST_NODE2NODE_REPLICATION_RECORD_REQUEST:
{
commandInfo="Retrieve record";
final String dbName=channel.readString();
final ORecordId rid=channel.readRID();
logger.setNode(dbName);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.OUT,"record %s...",rid);
final ODatabaseRecord database=getOrOpenDatabase(dbName);
final ORecordInternal<?> record=database.load(rid);
beginResponse();
try {
sendOk(clientTxId);
if (record != null) {
channel.writeByte(record.getRecordType());
channel.writeInt(record.getVersion());
channel.writeBytes(record.toStream());
}
 else channel.writeByte((byte)-1);
}
  finally {
endResponse();
}
break;
}
case OClusterProtocol.REQUEST_NODE2NODE_REPLICATION_RECORD_PROPAGATE:
{
commandInfo="Distributed record change";
final String dbName=channel.readString();
final byte operationType=channel.readByte();
final long operationId=channel.readLong();
final ORecordId rid=channel.readRID();
final byte[] buffer=channel.readBytes();
final int version=channel.readInt() - 1;
final byte recordType=channel.readByte();
logger.setNode(dbName);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"%s record %s...",ORecordOperation.getName(operationType),rid);
final long result;
final ODatabaseRecord database=getOrOpenDatabase(dbName);
OReplicationActiveThreadLocal.INSTANCE.set(false);
try {
switch (operationType) {
case ORecordOperation.CREATED:
long origClusterPosition=rid.clusterPosition;
rid.clusterPosition=-1;
result=createRecord(database,rid,buffer,recordType);
if (result != origClusterPosition) throw new OReplicationConflictException("Record created has RID different by the original: original " + rid.clusterId + ":"+ origClusterPosition+ ", local "+ rid.clusterId+ ":"+ result);
rid.clusterPosition=result;
break;
case ORecordOperation.UPDATED:
result=updateRecord(database,rid,buffer,version,recordType);
break;
case ORecordOperation.DELETED:
result=deleteRecord(database,rid,version);
break;
default :
throw new IllegalArgumentException("Received invalid distributed record change operation type: " + operationType);
}
}
  finally {
OReplicationActiveThreadLocal.INSTANCE.set(true);
}
final ODistributedNode node=manager.getReplicator().getNode(remoteNodeId);
final ODistributedDatabaseInfo db=node.getDatabase(database.getName());
db.getLog().appendLog(operationId,operationType,rid);
beginResponse();
try {
sendOk(clientTxId);
channel.writeLong(result);
}
  finally {
endResponse();
}
break;
}
case OClusterProtocol.REQUEST_NODE2NODE_DB_COPY:
{
checkConnected();
commandInfo="Importing a database from a remote node";
final String dbName=channel.readString();
final String dbUser=channel.readString();
final String dbPasswd=channel.readString();
final String dbType=channel.readString();
final String engineType=channel.readString();
try {
logger.setNode(dbName);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"importing database...");
ODatabaseDocumentTx database=getDatabaseInstance(dbName,dbType,engineType);
if (database.exists()) {
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.NONE,"deleting existent database...",database.getName());
database.drop();
}
database=createDatabase(database,dbUser,dbPasswd);
if (database.isClosed()) database.open(dbUser,dbPasswd);
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"reading database content via streaming from remote server node...");
manager.getReplicator().resetAnyPreviousReplicationLog(dbName);
beginResponse();
try {
OReplicationActiveThreadLocal.INSTANCE.set(false);
new ODatabaseImport(database,new OChannelBinaryInputStream(channel),this).importDatabase();
logger.log(this,Level.INFO,TYPE.REPLICATION,DIRECTION.IN,"database imported correctly");
sendOk(clientTxId);
}
  finally {
OReplicationActiveThreadLocal.INSTANCE.set(true);
endResponse();
}
}
  finally {
manager.getPeer().updateHeartBeatTime();
}
manager.getPeer().updateConfigurationToLeader();
break;
}
default :
return false;
}
return true;
}
