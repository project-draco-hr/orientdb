{
  checkOpeness();
  setCurrentDatabaseinThreadLocal();
  try {
    checkSecurity(ODatabaseSecurityResources.CLUSTER,ORole.PERMISSION_READ,getClusterNameById(iRid.getClusterId()));
    ORecordInternal<?> record=getTransaction().getRecordEntry(iRid);
    if (record == null && !iIgnoreCache)     record=getLevel1Cache().findRecord(iRid);
    if (record != null) {
      OFetchHelper.checkFetchPlanValid(iFetchPlan);
      callbackHooks(TYPE.BEFORE_READ,record);
      if (record.getInternalStatus() == ORecordElement.STATUS.NOT_LOADED)       record.reload();
      callbackHooks(TYPE.AFTER_READ,record);
      return (RET)record;
    }
    final ORawBuffer recordBuffer=underlying.read(iRid,iFetchPlan);
    if (recordBuffer == null)     return null;
    if (iRecord == null || iRecord.getRecordType() != recordBuffer.recordType)     iRecord=Orient.instance().getRecordFactoryManager().newInstance(this,recordBuffer.recordType);
    ODatabaseRecord currDb=iRecord.getDatabase();
    if (currDb == null)     currDb=(ODatabaseRecord)databaseOwner;
    iRecord.fill(currDb,iRid,recordBuffer.version,recordBuffer.buffer,false);
    callbackHooks(TYPE.BEFORE_READ,iRecord);
    iRecord.fromStream(recordBuffer.buffer);
    iRecord.setInternalStatus(ORecordElement.STATUS.LOADED);
    callbackHooks(TYPE.AFTER_READ,iRecord);
    if (!iIgnoreCache) {
      getLevel1Cache().updateRecord(iRecord);
    }
    return (RET)iRecord;
  }
 catch (  OException e) {
    throw e;
  }
catch (  Exception e) {
    OLogManager.instance().exception("Error on retrieving record " + iRid,e,ODatabaseException.class);
  }
  return null;
}
