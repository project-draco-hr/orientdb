{
  try {
    int unreadResponse=0;
    final long startClock=iTimeout > 0 ? System.currentTimeMillis() : 0;
    do {
      if (iTimeout <= 0)       acquireReadLock();
 else       if (!getLockRead().tryAcquireLock(iTimeout,TimeUnit.MILLISECONDS))       throw new OTimeoutException("Cannot acquire read lock against channel: " + this);
      if (!isConnected()) {
        releaseReadLock();
        throw new IOException("Channel is closed");
      }
      if (!channelRead) {
        channelRead=true;
        try {
          currentStatus=readByte();
          currentSessionId=readInt();
          if (debug)           OLogManager.instance().debug(this,"%s - Read response: %d-%d",socket.getLocalAddress(),(int)currentStatus,currentSessionId);
        }
 catch (        IOException e) {
          channelRead=false;
          readCondition.signalAll();
          releaseReadLock();
          throw e;
        }
      }
      if (currentSessionId == iRequesterId)       break;
      try {
        if (debug)         OLogManager.instance().debug(this,"%s - Session %d skip response, it is for %d",socket.getLocalAddress(),iRequesterId,currentSessionId);
        if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout) {
          close();
          throw new OTimeoutException("Timeout on reading response from the server " + (socket != null ? socket.getRemoteSocketAddress() : "") + " for the request "+ iRequesterId);
        }
        if (unreadResponse > maxUnreadResponses) {
          if (debug)           OLogManager.instance().info(this,"Unread responses %d > %d, consider the buffer as dirty: clean it",unreadResponse,maxUnreadResponses);
          close();
          throw new IOException("Timeout on reading response");
        }
        readCondition.signalAll();
        if (debug)         OLogManager.instance().debug(this,"Session %d is going to sleep...",iRequesterId);
        final long start=System.currentTimeMillis();
        readCondition.await(1,TimeUnit.SECONDS);
        final long now=System.currentTimeMillis();
        if (debug)         OLogManager.instance().debug(this,"Waked up: slept %dms, checking again from %s for session %d",(now - start),socket.getLocalAddress(),iRequesterId);
        if (now - start >= 1000)         unreadResponse++;
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        releaseReadLock();
      }
    }
 while (true);
    if (debug)     OLogManager.instance().debug(this,"%s - Session %d handle response",socket.getLocalAddress(),iRequesterId);
    handleStatus(currentStatus,currentSessionId);
  }
 catch (  OLockException e) {
    Thread.currentThread().interrupt();
    OLogManager.instance().error(this,"Unexpected error on reading response from channel",e);
  }
}
