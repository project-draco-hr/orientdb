{
  final long timer=OProfiler.getInstance().startChrono();
  try {
    if (root == null)     return;
    OLogManager.instance().debug(this,"Starting optimization of MVRB+Tree with %d items in memory...",cache.size());
    OMVRBTreeEntryPersistent<K,V> pRoot=(OMVRBTreeEntryPersistent<K,V>)root;
    if (entryPoints.size() == 0)     entryPoints.add(pRoot);
    config();
    int nodes=0;
    List<OMVRBTreeEntryPersistent<K,V>> tmp=null;
    if (isRuntimeCheckEnabled())     tmp=new ArrayList<OMVRBTreeEntryPersistent<K,V>>();
    for (    OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints) {
      for (OMVRBTreeEntryPersistent<K,V> e=(OMVRBTreeEntryPersistent<K,V>)entryPoint.getFirstInMemory(); e != null; e=e.getNextInMemory()) {
        if (isRuntimeCheckEnabled()) {
          for (          OMVRBTreeEntryPersistent<K,V> t : tmp)           if (t != e && t.record.getIdentity().equals(e.record.getIdentity())) {
            OLogManager.instance().error(this,"Found Node loaded in memory twice with different instances: " + e);
            continue;
          }
          tmp.add(e);
        }
        ++nodes;
      }
    }
    if (OLogManager.instance().isDebugEnabled())     OLogManager.instance().debug(this,"Found %d nodes in memory, %d items on disk, threshold=%d, entryPoints=%d",nodes,size,(entryPointsSize * optimizeEntryPointsFactor),entryPoints.size());
    if (!iForce && nodes < entryPointsSize * optimizeEntryPointsFactor)     return;
    if (debug)     System.out.printf("\n------------\nOptimizing: total items %d, root is %s...",size(),pRoot.toString());
    final int distance;
    if (nodes <= entryPointsSize)     distance=1;
 else     distance=nodes / entryPointsSize + 1;
    final List<OMVRBTreeEntryPersistent<K,V>> newEntryPoints=new ArrayList<OMVRBTreeEntryPersistent<K,V>>(entryPointsSize + 1);
    OLogManager.instance().debug(this,"Compacting nodes with distance = %d",distance);
    int nodeCounter=0;
    OMVRBTreeEntryPersistent<K,V> lastNode=null;
    OMVRBTreeEntryPersistent<K,V> currNode;
    for (int i=0; i < entryPoints.size(); ++i) {
      currNode=entryPoints.get(i);
      for (OMVRBTreeEntryPersistent<K,V> e=(OMVRBTreeEntryPersistent<K,V>)currNode.getFirstInMemory(); e != null; e=e.getNextInMemory()) {
        boolean alreadyPresent=false;
        for (int k=i + 1; k < entryPoints.size(); ++k)         if (e == entryPoints.get(k)) {
          alreadyPresent=true;
          break;
        }
        if (alreadyPresent)         continue;
        ++nodeCounter;
        if (newEntryPoints.size() == 0 || nodeCounter % distance == 0) {
          for (          OMVRBTreeEntryPersistent<K,V> ep : newEntryPoints)           if (ep == e) {
            alreadyPresent=true;
            break;
          }
          if (alreadyPresent)           --nodeCounter;
 else           newEntryPoints.add(e);
        }
        lastNode=e;
      }
    }
    if (newEntryPoints.size() > 1 && newEntryPoints.get(newEntryPoints.size() - 1) != lastNode)     newEntryPoints.add(lastNode);
    int cmp;
    for (int i=0; i < newEntryPoints.size(); ++i) {
      cmp=((Comparable<K>)pRoot.getFirstKey()).compareTo(newEntryPoints.get(i).getFirstKey());
      if (cmp < 0) {
        newEntryPoints.add(i,pRoot);
        break;
      }
 else       if (cmp == 0)       break;
    }
    entryPoints.clear();
    entryPoints=newEntryPoints;
    if (debug) {
      System.out.printf("\nEntrypoints (%d): ",entryPoints.size());
      for (      OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints) {
        if (debug)         System.out.printf(entryPoint.record.getIdentity() + " ");
      }
    }
    for (    OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints) {
      entryPoint.disconnectLinked(false);
    }
    if (isRuntimeCheckEnabled()) {
      for (      OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints)       for (OMVRBTreeEntryPersistent<K,V> e=(OMVRBTreeEntryPersistent<K,V>)entryPoint.getFirstInMemory(); e != null; e=e.getNextInMemory())       e.checkEntryStructure();
      if (OLogManager.instance().isDebugEnabled()) {
        nodes=0;
        for (        OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints)         for (OMVRBTreeEntryPersistent<K,V> e=(OMVRBTreeEntryPersistent<K,V>)entryPoint.getFirstInMemory(); e != null; e=e.getNextInMemory())         ++nodes;
        OLogManager.instance().debug(this,"Now Found %d nodes in memory and threshold=%d. EntryPoints=%d",nodes,(entryPointsSize * optimizeEntryPointsFactor),entryPoints.size());
      }
    }
    OLogManager.instance().debug(this,"Optimization done: MVRB-Tree nodes reduced to %d items",cache.size());
  }
  finally {
    if (isRuntimeCheckEnabled()) {
      if (entryPoints.size() > 0)       for (      OMVRBTreeEntryPersistent<K,V> entryPoint : entryPoints)       checkTreeStructure(entryPoint.getFirstInMemory());
 else       checkTreeStructure(root);
    }
    OProfiler.getInstance().stopChrono("OMVRBTreePersistent.optimize",timer);
    if (OLogManager.instance().isDebugEnabled())     OLogManager.instance().debug(this,"Optimization completed in %d ms\n",System.currentTimeMillis() - timer);
  }
}
