{
  acquireExclusiveLock();
  try {
    checkNullSupport(key);
    int sizeDiff=0;
    if (key != null) {
      key=keySerializer.preprocess(key,(Object[])keyTypes);
      final long hashCode=keyHashFunction.hashCode(key);
      final BucketPath nodePath=getBucket(hashCode);
      final long bucketPointer=hashTree[nodePath.nodeIndex][nodePath.itemIndex + nodePath.hashMapOffset];
      final long pageIndex=getPageIndex(bucketPointer);
      final int fileLevel=getFileLevel(bucketPointer);
      final V removed;
      final OCacheEntry cacheEntry=loadPageEntry(pageIndex,fileLevel);
      final OCachePointer dataPointer=cacheEntry.getCachePointer();
      dataPointer.acquireExclusiveLock();
      try {
        final OHashIndexBucket<K,V> bucket=new OHashIndexBucket<K,V>(dataPointer.getDataPointer(),keySerializer,valueSerializer,keyTypes);
        final int positionIndex=bucket.getIndex(hashCode,key);
        if (positionIndex < 0)         return null;
        removed=bucket.deleteEntry(positionIndex).value;
        sizeDiff--;
        mergeBucketsAfterDeletion(nodePath,bucket);
        cacheEntry.markDirty();
      }
  finally {
        dataPointer.releaseExclusiveLock();
        diskCache.release(cacheEntry);
      }
      if (nodePath.parent != null) {
        final int hashMapSize=1 << nodePath.nodeLocalDepth;
        final long[] node=hashTree[nodePath.nodeIndex];
        final boolean allMapsContainSameBucket=checkAllMapsContainSameBucket(node,hashMapSize);
        if (allMapsContainSameBucket)         mergeNodeToParent(node,nodePath);
      }
      changeSize(sizeDiff);
      return removed;
    }
 else {
      if (diskCache.getFilledUpTo(nullBucketFileId) == 0)       return null;
      V removed=null;
      OCacheEntry cacheEntry=diskCache.load(nullBucketFileId,0,false);
      OCachePointer cachePointer=cacheEntry.getCachePointer();
      cachePointer.acquireExclusiveLock();
      try {
        final ONullBucket<V> nullBucket=new ONullBucket<V>(cachePointer.getDataPointer(),ODurablePage.TrackMode.NONE,valueSerializer,false);
        removed=nullBucket.getValue();
        if (removed != null) {
          nullBucket.removeValue();
          sizeDiff--;
        }
      }
  finally {
        cachePointer.releaseExclusiveLock();
        diskCache.release(cacheEntry);
      }
      changeSize(sizeDiff);
      return removed;
    }
  }
 catch (  IOException e) {
    throw new OIndexException("Error during index removal",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
