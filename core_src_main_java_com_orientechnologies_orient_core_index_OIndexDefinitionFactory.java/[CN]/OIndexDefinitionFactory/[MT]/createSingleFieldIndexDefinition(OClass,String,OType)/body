{
  final String fieldName=adjustFieldName(oClass,extractFieldName(field));
  final OIndexDefinition indexDefinition;
  final OType indexType;
  if (type == OType.EMBEDDEDMAP || type == OType.LINKMAP) {
    final OPropertyMapIndexDefinition.INDEX_BY indexBy=extractMapIndexSpecifier(field);
    if (indexBy.equals(OPropertyMapIndexDefinition.INDEX_BY.KEY))     indexType=OType.STRING;
 else {
      if (type == OType.LINKMAP)       indexType=OType.LINK;
 else {
        final OProperty propertyToIndex=oClass.getProperty(fieldName);
        indexType=propertyToIndex.getLinkedType();
        if (indexType == null)         throw new OIndexException("Linked type was not provided." + " You should provide linked type for embedded collections that are going to be indexed.");
      }
    }
    indexDefinition=new OPropertyMapIndexDefinition(oClass.getName(),fieldName,indexType,indexBy);
  }
 else   if (type.equals(OType.EMBEDDEDLIST) || type.equals(OType.EMBEDDEDSET) || type.equals(OType.LINKLIST)|| type.equals(OType.LINKSET)) {
    if (type.equals(OType.LINKSET))     throw new OIndexException("LINKSET indexing is not supported.");
 else     if (type.equals(OType.LINKLIST)) {
      indexType=OType.LINK;
    }
 else {
      final OProperty propertyToIndex=oClass.getProperty(fieldName);
      indexType=propertyToIndex.getLinkedType();
      if (indexType == null)       throw new OIndexException("Linked type was not provided." + " You should provide linked type for embedded collections that are going to be indexed.");
    }
    indexDefinition=new OPropertyListIndexDefinition(oClass.getName(),fieldName,indexType);
  }
 else   indexDefinition=new OPropertyIndexDefinition(oClass.getName(),fieldName,type);
  return indexDefinition;
}
