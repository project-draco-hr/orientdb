{
  setDataCommandInfo("Execute remote command");
  final boolean asynch=channel.readByte() == 'a';
  String dbSerializerName=connection.database.getSerializer().toString();
  String name=getRecordSerializerName();
  if (!dbSerializerName.equals(name)) {
    ORecordSerializer ser=ORecordSerializerFactory.instance().getFormat(name);
    ONetworkThreadLocalSerializer.setNetworkSerializer(ser);
  }
  final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
  ONetworkThreadLocalSerializer.setNetworkSerializer(null);
  connection.data.commandDetail=command.getText();
  beginResponse();
  try {
    connection.data.command=command;
    final OAbstractCommandResultListener listener;
    if (asynch) {
      listener=new OAsyncCommandResultListener(this,clientTxId,command.getResultListener());
      command.setResultListener(listener);
    }
 else     listener=new OSyncCommandResultListener();
    final long serverTimeout=OGlobalConfiguration.COMMAND_TIMEOUT.getValueAsLong();
    if (serverTimeout > 0 && command.getTimeoutTime() > serverTimeout)     command.setTimeout(serverTimeout,command.getTimeoutStrategy());
    if (!isConnectionAlive())     return;
    listener.setFetchPlan(connection.database.command(command).getFetchPlan());
    final Object result=connection.database.command(command).execute();
    listener.setFetchPlan(command.getFetchPlan());
    if (asynch) {
      if (listener.isEmpty())       try {
        sendOk(clientTxId);
      }
 catch (      IOException ignored) {
      }
      channel.writeByte((byte)0);
    }
 else {
      sendOk(clientTxId);
      if (result == null) {
        channel.writeByte((byte)'n');
      }
 else       if (result instanceof OIdentifiable) {
        channel.writeByte((byte)'r');
        listener.result(result);
        writeIdentifiable((OIdentifiable)result);
      }
 else       if (result instanceof ODocumentWrapper) {
        channel.writeByte((byte)'r');
        final ODocument doc=((ODocumentWrapper)result).getDocument();
        listener.result(doc);
        writeIdentifiable(doc);
      }
 else       if (OMultiValue.isMultiValue(result)) {
        channel.writeByte((byte)'l');
        channel.writeInt(OMultiValue.getSize(result));
        for (        Object o : OMultiValue.getMultiValueIterable(result)) {
          try {
            listener.result(o);
            writeIdentifiable((OIdentifiable)o);
          }
 catch (          Exception e) {
            OLogManager.instance().warn(this,"Cannot serialize record: " + o);
            writeIdentifiable(null);
          }
        }
      }
 else {
        channel.writeByte((byte)'a');
        final StringBuilder value=new StringBuilder(64);
        listener.result(result);
        ORecordSerializerStringAbstract.fieldTypeToString(value,OType.getTypeByClass(result.getClass()),result);
        channel.writeString(value.toString());
      }
      if (connection.data.protocolVersion >= 17) {
        for (        ORecord rec : ((OSyncCommandResultListener)listener).getFetchedRecordsToSend()) {
          channel.writeByte((byte)2);
          writeIdentifiable(rec);
        }
        channel.writeByte((byte)0);
      }
    }
  }
  finally {
    connection.data.command=null;
    endResponse();
  }
}
