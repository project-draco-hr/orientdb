{
  final ODocument record=(ODocument)((OIdentifiable)iRecord).getRecord();
  try {
    if (compiledFilter != null) {
      if (!(Boolean)compiledFilter.evaluate(record,null,context))       return false;
    }
    final Set<ODocument> updatedRecords=new HashSet<ODocument>();
    parameters.reset();
    if (returning.equalsIgnoreCase("BEFORE"))     allUpdatedRecords.add(record.copy());
 else     if (returning.equalsIgnoreCase("AFTER"))     allUpdatedRecords.add(record);
    if (content != null) {
      record.clear();
      record.merge(content,false,false);
      updatedRecords.add(record);
    }
    if (merge != null) {
      record.merge(merge,true,false);
      updatedRecords.add(record);
    }
    if (!setEntries.isEmpty()) {
      Set<ODocument> changedDocuments=OSQLHelper.bindParameters(record,setEntries,parameters,context);
      if (changedDocuments != null)       updatedRecords.addAll(changedDocuments);
    }
    if (!incrementEntries.isEmpty()) {
      for (      Map.Entry<String,Number> entry : incrementEntries.entrySet()) {
        final Number prevValue=record.field(entry.getKey());
        if (prevValue == null)         record.field(entry.getKey(),entry.getValue());
 else         record.field(entry.getKey(),OType.increment(prevValue,entry.getValue()));
      }
      updatedRecords.add(record);
    }
    Object v;
    Collection<Object> coll=null;
    ORidBag bag=null;
    Object fieldValue;
    for (    OPair<String,Object> entry : addEntries) {
      coll=null;
      if (!record.containsField(entry.getKey())) {
        if (record.getSchemaClass() != null) {
          OProperty prop=record.getSchemaClass().getProperty(entry.getKey());
          if (prop != null && prop.getType() == OType.LINKSET)           coll=new HashSet<Object>();
        }
        if (coll == null)         coll=new ArrayList<Object>();
        record.field(entry.getKey(),coll);
      }
 else {
        fieldValue=record.field(entry.getKey());
        if (fieldValue instanceof Collection<?>)         coll=(Collection<Object>)fieldValue;
 else         if (fieldValue instanceof ORidBag)         bag=(ORidBag)fieldValue;
 else         continue;
      }
      v=entry.getValue();
      if (v instanceof OSQLFilterItem)       v=((OSQLFilterItem)v).getValue(record,null,context);
 else       if (v instanceof OSQLFunctionRuntime)       v=((OSQLFunctionRuntime)v).execute(record,record,null,context);
 else       if (v instanceof OCommandRequest)       v=((OCommandRequest)v).execute(record,null,context);
      if (coll != null)       coll.add(v);
 else {
        if (!(v instanceof OIdentifiable))         throw new OCommandExecutionException("Only links or records can be added to LINKBAG");
        bag.add((OIdentifiable)v);
      }
      updatedRecords.add(record);
    }
    Map<String,Object> map;
    OPair<String,Object> pair;
    if (!putEntries.isEmpty()) {
      for (      Entry<String,OPair<String,Object>> entry : putEntries.entrySet()) {
        fieldValue=record.field(entry.getKey());
        if (fieldValue == null) {
          if (record.getSchemaClass() != null) {
            final OProperty property=record.getSchemaClass().getProperty(entry.getKey());
            if (property != null && (property.getType() != null && (!property.getType().equals(OType.EMBEDDEDMAP) && !property.getType().equals(OType.LINKMAP)))) {
              throw new OCommandExecutionException("field " + entry.getKey() + " is not defined as a map");
            }
          }
          fieldValue=new HashMap<String,Object>();
          record.field(entry.getKey(),fieldValue);
        }
        if (fieldValue instanceof Map<?,?>) {
          map=(Map<String,Object>)fieldValue;
          pair=entry.getValue();
          v=pair.getValue();
          if (v instanceof OSQLFilterItem)           v=((OSQLFilterItem)v).getValue(record,null,context);
 else           if (pair.getValue() instanceof OSQLFunctionRuntime)           v=((OSQLFunctionRuntime)v).execute(record,record,null,context);
 else           if (v instanceof OCommandRequest)           v=((OCommandRequest)v).execute(record,null,context);
          map.put(pair.getKey(),v);
          updatedRecords.add(record);
        }
      }
    }
    if (!removeEntries.isEmpty()) {
      for (      OPair<String,Object> entry : removeEntries) {
        v=entry.getValue();
        if (v == EMPTY_VALUE) {
          record.removeField(entry.getKey());
          updatedRecords.add(record);
        }
 else {
          fieldValue=record.field(entry.getKey());
          if (fieldValue instanceof Collection<?>) {
            coll=(Collection<Object>)fieldValue;
            if (coll.remove(v))             updatedRecords.add(record);
          }
 else           if (fieldValue instanceof Map<?,?>) {
            map=(Map<String,Object>)fieldValue;
            if (map.remove(v) != null)             updatedRecords.add(record);
          }
 else           if (fieldValue instanceof ORidBag) {
            bag=(ORidBag)fieldValue;
            if (!(v instanceof OIdentifiable))             throw new OCommandExecutionException("Only links or records can be removed from LINKBAG");
            bag.remove((OIdentifiable)v);
            if (record.isDirty())             updatedRecords.add(record);
          }
        }
      }
    }
    for (    ODocument d : updatedRecords) {
      d.setDirty();
      d.save();
      recordCount++;
    }
    return true;
  }
  finally {
    if (lockStrategy.equalsIgnoreCase("RECORD"))     ((OStorageEmbedded)getDatabase().getStorage()).releaseWriteLock(record.getIdentity());
  }
}
