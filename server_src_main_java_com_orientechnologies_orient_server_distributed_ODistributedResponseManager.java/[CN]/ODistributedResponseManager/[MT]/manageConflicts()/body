{
  if (!groupResponsesByResult || request.getTask().getQuorumType() == OCommandDistributedReplicateRequest.QUORUM_TYPE.NONE)   return null;
  if (dManager.getNodeStatus() != ODistributedServerManager.NODE_STATUS.ONLINE)   return null;
  final int bestResponsesGroupIndex=getBestResponsesGroup();
  final List<ODistributedResponse> bestResponsesGroup=responseGroups.get(bestResponsesGroupIndex);
  final int maxCoherentResponses=bestResponsesGroup.size();
  final int conflicts=getExpectedResponses() - (maxCoherentResponses + discardedResponses);
  boolean requireUndo=false;
  if (isMinimumQuorumReached()) {
    if (responseGroups.size() == 1)     return null;
    if (checkNoWinnerCase(bestResponsesGroup))     return null;
    if (fixNodesInConflict(bestResponsesGroup,conflicts))     return null;
  }
  ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,"detected %d node(s) in timeout or in conflict and quorum (%d) has not been reached, rolling back changes for request (%s)",conflicts,quorum,request);
  final StringBuilder msg=new StringBuilder(256);
  msg.append("Quorum " + getQuorum() + " not reached for request ("+ request+ "). Elapsed="+ (System.currentTimeMillis() - sentOn)+ "ms");
  final List<ODistributedResponse> res=getConflictResponses();
  if (res.isEmpty())   msg.append(" No server in conflict. ");
 else {
    msg.append(" Servers in timeout/conflict are:");
    for (    ODistributedResponse r : res) {
      msg.append("\n - ");
      msg.append(r.getExecutorNodeName());
      msg.append(": ");
      msg.append(r.getPayload());
    }
    msg.append("\n");
  }
  msg.append("Received: ");
  msg.append(responses);
  ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,msg.toString());
  undoRequest();
  final Object goodResponsePayload=bestResponsesGroup.isEmpty() ? null : bestResponsesGroup.get(0).getPayload();
  if (goodResponsePayload instanceof RuntimeException)   return (RuntimeException)goodResponsePayload;
 else   if (goodResponsePayload instanceof Throwable)   return OException.wrapException(new ODistributedException(msg.toString()),(Throwable)goodResponsePayload);
 else   return new ODistributedOperationException(msg.toString());
}
