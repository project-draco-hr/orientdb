{
  acquireExclusiveLock();
  try {
    BucketSearchResult bucketSearchResult=findBucket(key);
    long keyBucketPointer=diskCache.load(fileId,bucketSearchResult.pageIndex);
    OSBTreeBucket<K> keyBucket=new OSBTreeBucket<K>(keyBucketPointer,keySerializer);
    if (bucketSearchResult.index >= 0) {
      keyBucket.updateValue(bucketSearchResult.index,value);
    }
 else {
      int insertionIndex=-bucketSearchResult.index - 1;
      while (!keyBucket.addEntry(insertionIndex,new OSBTreeBucket.SBTreeEntry<K>(-1,-1,key,value))) {
        diskCache.release(fileId,bucketSearchResult.pageIndex);
        bucketSearchResult=splitBucket(bucketSearchResult.pageIndex,insertionIndex);
        insertionIndex=bucketSearchResult.index;
        keyBucketPointer=diskCache.load(fileId,bucketSearchResult.pageIndex);
        keyBucket=new OSBTreeBucket<K>(keyBucketPointer,keySerializer);
      }
    }
    diskCache.markDirty(fileId,bucketSearchResult.pageIndex);
    diskCache.release(fileId,bucketSearchResult.pageIndex);
    setSize(size() + 1);
  }
 catch (  IOException e) {
    throw new OIndexException("Error during index update",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
