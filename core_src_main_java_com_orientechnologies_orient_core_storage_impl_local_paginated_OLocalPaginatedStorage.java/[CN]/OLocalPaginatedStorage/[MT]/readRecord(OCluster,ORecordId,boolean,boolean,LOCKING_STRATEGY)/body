{
  checkOpeness();
  if (!rid.isPersistent())   throw new IllegalArgumentException("Cannot read record " + rid + " since the position is invalid in database '"+ name+ '\'');
  final long timer=Orient.instance().getProfiler().startChrono();
  clusterSegment.getExternalModificationLock().requestModificationLock();
  try {
    if (atomicLock)     lock.acquireSharedLock();
    try {
switch (iLockingStrategy) {
case DEFAULT:
case KEEP_SHARED_LOCK:
        lockManager.acquireLock(Thread.currentThread(),rid,OLockManager.LOCK.SHARED);
      break;
case NONE:
    break;
case KEEP_EXCLUSIVE_LOCK:
  lockManager.acquireLock(Thread.currentThread(),rid,OLockManager.LOCK.EXCLUSIVE);
}
try {
return clusterSegment.readRecord(rid.clusterPosition);
}
  finally {
switch (iLockingStrategy) {
case DEFAULT:
  lockManager.releaseLock(Thread.currentThread(),rid,OLockManager.LOCK.SHARED);
break;
case NONE:
case KEEP_SHARED_LOCK:
case KEEP_EXCLUSIVE_LOCK:
break;
}
}
}
 catch (IOException e) {
OLogManager.instance().error(this,"Error on reading record " + rid + " (cluster: "+ clusterSegment+ ')',e);
return null;
}
 finally {
if (atomicLock) lock.releaseSharedLock();
}
}
  finally {
clusterSegment.getExternalModificationLock().releaseModificationLock();
Orient.instance().getProfiler().stopChrono(PROFILER_READ_RECORD,"Read a record from database",timer,"db.*.readRecord");
}
}
