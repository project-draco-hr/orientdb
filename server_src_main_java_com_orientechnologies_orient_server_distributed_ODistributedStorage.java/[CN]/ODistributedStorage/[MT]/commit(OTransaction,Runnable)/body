{
  if (OScenarioThreadLocal.INSTANCE.get() == RUN_MODE.RUNNING_DISTRIBUTED) {
    wrapped.commit(iTx,callback);
    return;
  }
  final ODistributedConfiguration dbCfg=dManager.getDatabaseConfiguration(getName());
  final String localNodeName=dManager.getLocalNodeName();
  checkNodeIsMaster(localNodeName,dbCfg);
  try {
    if (!dbCfg.isReplicationActive(null,localNodeName)) {
      ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
        @Override public Object call() throws Exception {
          wrapped.commit(iTx,callback);
          return null;
        }
      }
);
      return;
    }
    OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.BEGUN);
    final OTxTask txTask=new OTxTask();
    final Set<String> involvedClusters=new HashSet<String>();
    final List<ORecordOperation> tmpEntries=new ArrayList<ORecordOperation>();
    while (iTx.getCurrentRecordEntries().iterator().hasNext()) {
      for (      ORecordOperation txEntry : iTx.getCurrentRecordEntries())       tmpEntries.add(txEntry);
      iTx.clearRecordEntries();
      for (      ORecordOperation op : tmpEntries) {
        final OAbstractRecordReplicatedTask task;
        final ORecord record=op.getRecord();
        final ORecordId rid=(ORecordId)record.getIdentity();
switch (op.type) {
case ORecordOperation.CREATED:
          if (rid.isNew()) {
            task=new OCreateRecordTask(record);
            if (record instanceof ODocument)             ((ODocument)record).validate();
            break;
          }
case ORecordOperation.UPDATED:
        if (record instanceof ODocument)         ((ODocument)record).validate();
      final OStorageOperationResult<ORawBuffer> previousContent=wrapped.readRecord(rid,null,false,null,false,LOCKING_STRATEGY.DEFAULT);
    if (previousContent.getResult() == null)     throw new OTransactionException("Cannot update record '" + rid + "' because has been deleted");
  task=new OUpdateRecordTask(rid,previousContent.getResult().getBuffer(),previousContent.getResult().version,record.toStream(),record.getRecordVersion(),ORecordInternal.getRecordType(record));
break;
case ORecordOperation.DELETED:
task=new ODeleteRecordTask(rid,record.getRecordVersion());
break;
default :
continue;
}
involvedClusters.add(getClusterNameByRID(rid));
txTask.add(task);
}
}
OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.COMMITTING);
final Set<String> nodes=dbCfg.getServers(involvedClusters);
Boolean executionModeSynch=dbCfg.isExecutionModeSynchronous(null);
if (executionModeSynch == null) executionModeSynch=Boolean.TRUE;
if (executionModeSynch) {
final Object result=dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE);
if (result instanceof List<?>) {
final List<Object> list=(List<Object>)result;
for (int i=0; i < txTask.getTasks().size(); ++i) {
final Object o=list.get(i);
final OAbstractRecordReplicatedTask task=txTask.getTasks().get(i);
if (task instanceof OCreateRecordTask) {
final OCreateRecordTask t=(OCreateRecordTask)task;
t.getRid().copyFrom(((OPlaceholder)o).getIdentity());
t.getVersion().copyFrom(((OPlaceholder)o).getRecordVersion());
}
 else if (task instanceof OUpdateRecordTask) {
final OUpdateRecordTask t=(OUpdateRecordTask)task;
t.getVersion().copyFrom((ORecordVersion)o);
}
 else if (task instanceof ODeleteRecordTask) {
}
}
for (ORecordOperation op : tmpEntries) {
final ORecord record=op.getRecord();
if (record != null) ORecordInternal.unsetDirty(record);
}
}
 else if (result instanceof Throwable) {
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"distributed transaction error: %s",result,result.toString());
if (result instanceof OTransactionException || result instanceof ONeedRetryException) throw (RuntimeException)result;
throw new OTransactionException("Error on committing distributed transaction",(Throwable)result);
}
 else {
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"distributed transaction error, received unknown response type: %s",result);
throw new OTransactionException("Error on committing distributed transaction, received unknown response type " + result);
}
return;
}
ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
@Override public Object call() throws Exception {
((OTransactionRealAbstract)iTx).restore();
wrapped.commit(iTx,callback);
return null;
}
}
);
nodes.remove(localNodeName);
if (!nodes.isEmpty()) {
if (executionModeSynch) dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE);
 else asynchronousExecution(new OAsynchDistributedOperation(getName(),involvedClusters,nodes,txTask));
}
}
 catch (OValidationException e) {
throw e;
}
catch (Exception e) {
handleDistributedException("Cannot route TX operation against distributed node",e);
}
}
