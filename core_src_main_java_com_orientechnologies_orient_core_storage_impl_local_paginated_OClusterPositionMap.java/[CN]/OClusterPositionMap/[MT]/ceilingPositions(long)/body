{
  acquireSharedLock();
  try {
    if (clusterPosition < 0)     clusterPosition=0;
    long pageIndex=clusterPosition / OClusterPositionMapBucket.MAX_ENTRIES;
    int index=(int)(clusterPosition % OClusterPositionMapBucket.MAX_ENTRIES);
    OAtomicOperation atomicOperation=storage.getAtomicOperationsManager().getCurrentOperation();
    final long filledUpTo=getFilledUpTo(atomicOperation,diskCache,fileId);
    if (pageIndex >= filledUpTo)     return new long[0];
    long[] result=null;
    do {
      OCacheEntry cacheEntry=loadPage(atomicOperation,fileId,pageIndex,false,diskCache);
      OClusterPositionMapBucket bucket=new OClusterPositionMapBucket(cacheEntry,getChangesTree(atomicOperation,cacheEntry));
      int resultSize=bucket.getSize() - index;
      if (resultSize <= 0) {
        diskCache.release(cacheEntry);
        pageIndex++;
        index=0;
      }
 else {
        int entriesCount=0;
        long startIndex=cacheEntry.getPageIndex() * OClusterPositionMapBucket.MAX_ENTRIES + index;
        result=new long[resultSize];
        for (int i=0; i < resultSize; i++) {
          if (bucket.exists(i + index)) {
            result[entriesCount]=startIndex + i;
            entriesCount++;
          }
        }
        if (entriesCount == 0) {
          result=null;
          pageIndex++;
          index=0;
        }
 else         result=Arrays.copyOf(result,entriesCount);
        diskCache.release(cacheEntry);
      }
    }
 while (result == null && pageIndex < filledUpTo);
    if (result == null)     result=new long[0];
    return result;
  }
  finally {
    releaseSharedLock();
  }
}
