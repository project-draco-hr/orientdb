{
  final long timer=OProfiler.getInstance().startChrono();
  final OCluster cluster=getClusterById(iRid.clusterId);
  lock.acquireSharedLock();
  try {
    lockManager.acquireLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    try {
      final OPhysicalPosition ppos=cluster.getPhysicalPosition(new OPhysicalPosition(iRid.clusterPosition));
      if (ppos == null) {
        if (iCallback != null)         iCallback.call(iRid,-1);
        return -1;
      }
      if (iVersion != -1) {
        if (iVersion > -1) {
          if (iVersion != ppos.recordVersion)           if (OFastConcurrentModificationException.enabled())           throw OFastConcurrentModificationException.instance();
 else           throw new OConcurrentModificationException(iRid,ppos.recordVersion,iVersion,ORecordOperation.UPDATED);
          ++ppos.recordVersion;
        }
 else         --ppos.recordVersion;
      }
      final ODataSegmentMemory dataSegment=(ODataSegmentMemory)getDataSegmentById(ppos.dataSegmentId);
      dataSegment.updateRecord(ppos.dataSegmentPos,iContent);
      if (iCallback != null)       iCallback.call(null,ppos.recordVersion);
      return ppos.recordVersion;
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    }
  }
 catch (  IOException e) {
    throw new OStorageException("Error on update record " + iRid,e);
  }
 finally {
    lock.releaseSharedLock();
    OProfiler.getInstance().stopChrono(PROFILER_UPDATE_RECORD,timer);
  }
}
