{
  channel.acquireWriteLock();
  try {
    channel.writeByte(OChannelBinaryProtocol.RESPONSE_STATUS_ERROR);
    channel.writeInt(iClientTxId);
    if (Boolean.TRUE.equals(tokenBased)) {
      byte[] renewedToken=tokenHandler.renewIfNeeded(token);
      channel.writeBytes(renewedToken);
    }
    final Throwable current;
    if (t instanceof OLockException && t.getCause() instanceof ODatabaseException)     current=t.getCause();
 else     current=t;
    sendErrorDetails(current);
    if (connection != null && connection.data.protocolVersion >= 19) {
      serializeExceptionObject(current);
    }
    channel.flush();
    if (OLogManager.instance().isLevelEnabled(logClientExceptions)) {
      if (logClientFullStackTrace)       OLogManager.instance().log(this,logClientExceptions,"Sent run-time exception to the client %s: %s",t,channel.socket.getRemoteSocketAddress(),t.toString());
 else       OLogManager.instance().log(this,logClientExceptions,"Sent run-time exception to the client %s: %s",null,channel.socket.getRemoteSocketAddress(),t.toString());
    }
  }
 catch (  Exception e) {
    if (e instanceof SocketException)     shutdown();
 else     OLogManager.instance().error(this,"Error during sending an error to client",e);
  }
 finally {
    if (channel.getLockWrite().isHeldByCurrentThread())     channel.releaseWriteLock();
  }
}
