{
  checkForLoading();
  checkForFields();
  _source=null;
  for (  String f : iOther.keySet()) {
    final Object value=field(f);
    final Object otherValue=iOther.get(f);
    if (containsField(f) && iMergeSingleItemsOfMultiValueFields) {
      if (value instanceof Map<?,?>) {
        final Map<String,Object> map=(Map<String,Object>)value;
        final Map<String,Object> otherMap=(Map<String,Object>)otherValue;
        for (        Entry<String,Object> entry : otherMap.entrySet()) {
          map.put(entry.getKey(),entry.getValue());
        }
        continue;
      }
 else       if (value instanceof Collection<?>) {
        final Collection<Object> coll=(Collection<Object>)value;
        final Collection<Object> otherColl=(Collection<Object>)otherValue;
        for (        Object item : otherColl) {
          if (coll.contains(item))           coll.remove(item);
          coll.add(item);
        }
        continue;
      }
    }
    setFieldType(f,null);
    boolean bagsMerged=false;
    if (value instanceof ORidBag && otherValue instanceof ORidBag)     bagsMerged=((ORidBag)value).tryMerge((ORidBag)otherValue,iMergeSingleItemsOfMultiValueFields);
    if (!bagsMerged && (value != null && !value.equals(otherValue)) || (value == null && otherValue != null))     field(f,otherValue);
  }
  if (!iUpdateOnlyMode) {
    for (    String f : fieldNames())     if (!iOther.containsKey(f))     removeField(f);
  }
  return this;
}
