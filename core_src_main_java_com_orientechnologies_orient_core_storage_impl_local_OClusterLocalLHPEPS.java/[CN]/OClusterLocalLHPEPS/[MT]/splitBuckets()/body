{
  final long positionToSplit=calcPositionToSplit();
  splittedBuckets.set((int)positionToSplit);
  final long positionToAdd=positionToSplit + pageSize * g;
  if (mainBucketsSize - 1 < positionToAdd) {
    final long requiredSpace=(positionToAdd + 1) * OClusterLocalLHPEBucket.BUCKET_SIZE_IN_BYTES;
    if (requiredSpace > fileSegment.getFilledUpTo())     allocateSpace((int)(requiredSpace - fileSegment.getFilledUpTo()));
    mainBucketsSize=positionToAdd + 1;
  }
  fileSegment.writeContinuously(positionToAdd * OClusterLocalLHPEBucket.BUCKET_SIZE_IN_BYTES,new byte[OClusterLocalLHPEBucket.BUCKET_SIZE_IN_BYTES]);
  OClusterLocalLHPEBucket addedBucket=loadMainBucket(positionToAdd);
  Map<Long,OClusterLocalLHPEBucket> bucketMap=new HashMap<Long,OClusterLocalLHPEBucket>(g);
  List<Long> bucketsToSplit=new ArrayList<Long>(g);
  for (long ptr=positionToSplit; ptr < positionToSplit + pageSize * g; ptr+=pageSize) {
    final OClusterLocalLHPEBucket bucket=loadMainBucket(ptr);
    bucketMap.put(ptr,bucket);
    bucketsToSplit.add(ptr);
  }
  bucketMap.put(positionToAdd,addedBucket);
  int chainLength=0;
  int prevChainLength=getMainBucketOverflowChainLength(positionToAdd);
  for (  long currentBucketPosition : bucketsToSplit) {
    OClusterLocalLHPEBucket currentBucket=bucketMap.get(currentBucketPosition);
    while (true) {
      for (int i=0; i < currentBucket.getSize(); ) {
        long bucketKey=currentBucket.getKey(i);
        long position=calculatePageIndex(bucketKey)[0];
        if (currentBucketPosition != position) {
          OClusterLocalLHPEBucket bucketToAdd=bucketMap.get(position);
          while (bucketToAdd.getSize() >= OClusterLocalLHPEBucket.BUCKET_CAPACITY && bucketToAdd.getOverflowBucket() > -1)           bucketToAdd=loadOverflowBucket(bucketToAdd.getOverflowBucket());
          if (bucketToAdd.getSize() >= OClusterLocalLHPEBucket.BUCKET_CAPACITY) {
            OverflowBucketInfo bucketInfo=popOverflowBucket();
            bucketToAdd.setOverflowBucket(bucketInfo.index);
            bucketToAdd=bucketInfo.bucket;
            if (position == positionToAdd)             chainLength++;
          }
          bucketToAdd.addPhysicalPosition(currentBucket.getPhysicalPosition(i));
          currentBucket.removePhysicalPosition(i);
        }
 else         i++;
      }
      if (currentBucket.getOverflowBucket() > -1)       currentBucket=loadOverflowBucket(currentBucket.getOverflowBucket());
 else       break;
    }
  }
  updateMainBucketOverflowChainLength(positionToAdd,chainLength);
  updateBucketGroupOverflowChainLength(positionToSplit,chainLength - prevChainLength);
  for (  long currentBucketPosition : bucketsToSplit) {
    final OClusterLocalLHPEBucket currentBucket=bucketMap.get(currentBucketPosition);
    compressChain(currentBucket,currentBucketPosition,positionToSplit);
  }
  recordSplitPointer=splittedBuckets.nextClearBit((int)recordSplitPointer);
  if (recordSplitPointer == roundCapacity) {
    recordSplitPointer=0;
    splittedBuckets.clear();
    g++;
    if (g == 2 * GROUP_COUNT) {
      roundCapacity=nextPageSize;
      pageSize=nextPageSize;
      nextPageSize<<=1;
      g=GROUP_COUNT;
      splittedBuckets=new BitSet((int)pageSize);
    }
    rebuildGroupOverflowChain();
  }
}
