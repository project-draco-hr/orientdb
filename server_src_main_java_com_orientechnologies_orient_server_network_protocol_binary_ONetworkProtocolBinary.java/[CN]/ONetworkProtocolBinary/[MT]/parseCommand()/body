{
switch (lastRequestType) {
case OChannelBinaryProtocol.REQUEST_SHUTDOWN:
{
      data.commandInfo="Shutdowning";
      OLogManager.instance().info(this,"Received shutdown command from the remote client %s:%d",channel.socket.getInetAddress(),channel.socket.getPort());
      user=channel.readString();
      passwd=channel.readString();
      if (OServerMain.server().authenticate(user,passwd,"shutdown")) {
        OLogManager.instance().info(this,"Remote client %s:%d authenticated. Starting shutdown of server...",channel.socket.getInetAddress(),channel.socket.getPort());
        sendOk(lastClientTxId);
        channel.flush();
        channel.close();
        OServerMain.server().shutdown();
        System.exit(0);
        return;
      }
      OLogManager.instance().error(this,"Authentication error of remote client %s:%d: shutdown is aborted.",channel.socket.getInetAddress(),channel.socket.getPort());
      sendError(lastClientTxId,new OSecurityAccessException("Invalid user/password to shutdown the server"));
      break;
    }
case OChannelBinaryProtocol.REQUEST_CONNECT:
{
    data.commandInfo="Connect";
    serverLogin(channel.readString(),channel.readString());
    sendOk(lastClientTxId);
    channel.writeInt(connection.id);
    break;
  }
case OChannelBinaryProtocol.REQUEST_DB_OPEN:
{
  data.commandInfo="Open database";
  String dbURL=channel.readString();
  String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
  user=channel.readString();
  passwd=channel.readString();
  openDatabase(dbName,user,passwd);
  if (!(connection.database.getStorage() instanceof OStorageEmbedded) && !loadUserFromSchema(user,passwd)) {
    sendError(lastClientTxId,new OSecurityAccessException(connection.database.getName(),"Access denied to database '" + connection.database.getName() + "' for user: "+ user));
  }
 else {
    sendOk(lastClientTxId);
    channel.writeInt(connection.id);
    channel.writeInt(connection.database.getClusterNames().size());
    for (    OCluster c : (connection.database.getStorage()).getClusters()) {
      if (c != null) {
        channel.writeString(c.getName());
        channel.writeInt(c.getId());
        channel.writeString(c.getType());
      }
    }
    if (getClass().equals(ONetworkProtocolBinary.class))     channel.writeBytes(null);
  }
  break;
}
case OChannelBinaryProtocol.REQUEST_DB_CREATE:
{
data.commandInfo="Create database";
String dbName=channel.readString();
String storageMode=channel.readString();
checkServerAccess("database.create");
connection.database=getDatabaseInstance(dbName,storageMode);
createDatabase(connection.database,null,null);
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_DB_CLOSE:
data.commandInfo="Close Database";
if (connection != null) {
connection.close();
OClientConnectionManager.instance().disconnect(connection.id);
}
sendOk(lastClientTxId);
break;
case OChannelBinaryProtocol.REQUEST_DB_EXIST:
{
data.commandInfo="Exists database";
String dbName=channel.readString();
checkServerAccess("database.exists");
connection.database=getDatabaseInstance(dbName,"local");
sendOk(lastClientTxId);
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
break;
}
case OChannelBinaryProtocol.REQUEST_DB_DELETE:
{
data.commandInfo="Delete database";
String dbName=channel.readString();
checkServerAccess("database.delete");
connection.database=getDatabaseInstance(dbName,"local");
connection.database.delete();
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_DB_SIZE:
{
data.commandInfo="Database size";
sendOk(lastClientTxId);
channel.writeLong(connection.database.getStorage().getSize());
break;
}
case OChannelBinaryProtocol.REQUEST_DB_COUNTRECORDS:
{
data.commandInfo="Database count records";
sendOk(lastClientTxId);
channel.writeLong(connection.database.getStorage().countRecords());
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_COUNT:
{
data.commandInfo="Count cluster elements";
int[] clusterIds=new int[channel.readShort()];
for (int i=0; i < clusterIds.length; ++i) clusterIds[i]=channel.readShort();
long count=connection.database.countClusterElements(clusterIds);
sendOk(lastClientTxId);
channel.writeLong(count);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_DATARANGE:
{
data.commandInfo="Get the begin/end range of data in cluster";
long[] pos=connection.database.getStorage().getClusterDataRange(channel.readShort());
sendOk(lastClientTxId);
channel.writeLong(pos[0]);
channel.writeLong(pos[1]);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_ADD:
{
data.commandInfo="Add cluster";
final String type=channel.readString();
final String name=channel.readString();
final int num;
OStorage.CLUSTER_TYPE t=OStorage.CLUSTER_TYPE.valueOf(type);
switch (t) {
case PHYSICAL:
num=connection.database.addPhysicalCluster(name,channel.readString(),channel.readInt());
break;
case MEMORY:
num=connection.database.getStorage().addCluster(name,t);
break;
case LOGICAL:
num=connection.database.addLogicalCluster(name,channel.readInt());
break;
default :
throw new IllegalArgumentException("Cluster type " + type + " is not supported");
}
sendOk(lastClientTxId);
channel.writeShort((short)num);
break;
}
case OChannelBinaryProtocol.REQUEST_DATACLUSTER_REMOVE:
{
data.commandInfo="remove cluster";
final int id=channel.readShort();
boolean result=connection.database.getStorage().removeCluster(id);
sendOk(lastClientTxId);
channel.writeByte((byte)(result ? 1 : 0));
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_LOAD:
{
data.commandInfo="Load record";
final ORecordId rid=channel.readRID();
final String fetchPlanString=channel.readString();
if (rid.clusterId == 0 && rid.clusterPosition == 0) {
sendOk(lastClientTxId);
channel.writeByte((byte)1);
channel.writeBytes(connection.database.getStorage().getConfiguration().toStream());
channel.writeInt(0);
channel.writeByte(ORecordBytes.RECORD_TYPE);
}
 else {
final ORecordInternal<?> record=connection.database.load(rid);
if (rid.equals(connection.database.getMetadata().getSchema().getDocument().getIdentity())) connection.database.getMetadata().getSchema().reload();
sendOk(lastClientTxId);
if (record != null) {
channel.writeByte((byte)1);
channel.writeBytes(record.toStream());
channel.writeInt(record.getVersion());
channel.writeByte(record.getRecordType());
if (fetchPlanString.length() > 0) {
if (record instanceof ODocument) {
final Map<String,Integer> fetchPlan=OFetchHelper.buildFetchPlan(fetchPlanString);
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
OFetchHelper.fetch((ODocument)record,record,fetchPlan,null,0,-1,new OFetchListener(){
@Override public int size(){
return recordsToSend.size();
}
@Override public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) {
if (((ODocument)iLinked).getIdentity().isValid()) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
return null;
}
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
for (ODocument doc : recordsToSend) {
if (doc.getIdentity().isValid()) {
channel.writeByte((byte)2);
writeRecord(doc);
}
}
}
}
}
}
channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_CREATE:
{
data.commandInfo="Create record";
final ORecordId rid=new ORecordId(channel.readShort(),ORID.CLUSTER_POS_INVALID);
final byte[] buffer=channel.readBytes();
final byte recordType=channel.readByte();
final long location=connection.rawDatabase.save(rid,buffer,-1,recordType);
sendOk(lastClientTxId);
channel.writeLong(location);
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_UPDATE:
{
data.commandInfo="Update record";
final ORecordId rid=channel.readRID();
long newVersion=connection.rawDatabase.save(rid,channel.readBytes(),channel.readInt(),channel.readByte());
if (connection.database.getMetadata().getSchema().getDocument().getIdentity().equals(rid)) connection.database.getMetadata().getSchema().reload();
 else if (connection.database.getMetadata().getIndexManager().getDocument().getIdentity().equals(rid)) connection.database.getMetadata().getIndexManager().reload();
sendOk(lastClientTxId);
channel.writeInt((int)newVersion);
break;
}
case OChannelBinaryProtocol.REQUEST_RECORD_DELETE:
{
data.commandInfo="Delete record";
final ORecordId rid=new ORecordId(channel.readShort(),channel.readLong());
connection.rawDatabase.delete(rid,channel.readInt());
sendOk(lastClientTxId);
channel.writeByte((byte)1);
break;
}
case OChannelBinaryProtocol.REQUEST_COUNT:
{
data.commandInfo="Count cluster records";
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
sendOk(lastClientTxId);
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.REQUEST_COMMAND:
{
data.commandInfo="Execute remote command";
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(connection.database,channel.readBytes());
final OQuery<?> query=(OQuery<?>)(command instanceof OQuery<?> ? command : null);
data.commandDetail=command.getText();
if (asynch) {
final StringBuilder empty=new StringBuilder();
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
final int txId=lastClientTxId;
final Map<String,Integer> fetchPlan=query != null ? OFetchHelper.buildFetchPlan(query.getFetchPlan()) : null;
command.setResultListener(new OCommandResultListener(){
@Override public boolean result(final Object iRecord){
if (empty.length() == 0) try {
sendOk(txId);
empty.append("-");
}
 catch (IOException e1) {
}
try {
channel.writeByte((byte)1);
writeRecord((ORecordInternal<?>)iRecord);
if (fetchPlan != null && iRecord instanceof ODocument) {
OFetchHelper.fetch((ODocument)iRecord,iRecord,fetchPlan,null,0,-1,new OFetchListener(){
@Override public int size(){
return recordsToSend.size();
}
@Override public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else if (iLinked instanceof Collection<?>) return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
 else if (iLinked instanceof Map<?,?>) return recordsToSend.addAll(((Map<String,? extends ODocument>)iLinked).values()) ? iLinked : null;
 else throw new IllegalArgumentException("Unrecognized type while fetching records: " + iLinked);
}
}
);
}
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
((OCommandRequestInternal)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk(lastClientTxId);
}
 catch (IOException e1) {
}
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal)connection.database.command(command)).execute();
sendOk(lastClientTxId);
if (result == null) {
channel.writeByte((byte)'n');
}
 else if (result instanceof ORecord<?>) {
channel.writeByte((byte)'r');
writeRecord((ORecordInternal<?>)result);
}
 else if (result instanceof Collection<?>) {
channel.writeByte((byte)'l');
final Collection<OIdentifiable> list=(Collection<OIdentifiable>)result;
channel.writeInt(list.size());
for (OIdentifiable o : list) {
writeRecord(o);
}
}
 else {
channel.writeByte((byte)'a');
final StringBuilder value=new StringBuilder();
ORecordSerializerStringAbstract.fieldTypeToString(value,connection.database,OType.getTypeByClass(result.getClass()),result);
channel.writeString(value.toString());
}
}
break;
}
case OChannelBinaryProtocol.REQUEST_TX_COMMIT:
{
data.commandInfo="Transaction commit";
final OTransactionOptimisticProxy tx=new OTransactionOptimisticProxy((ODatabaseRecordTx)connection.database.getUnderlying(),channel);
connection.database.begin(tx);
try {
connection.database.commit();
sendOk(lastClientTxId);
channel.writeInt(tx.getUpdatedRecords().size());
for (Entry<ORecordId,ORecord<?>> entry : tx.getUpdatedRecords().entrySet()) {
channel.writeRID(entry.getKey());
channel.writeInt(entry.getValue().getVersion());
}
}
 catch (Exception e) {
connection.database.rollback();
sendError(lastClientTxId,e);
}
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_GET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.get");
final String key=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
String cfgValue=cfg != null ? cfg.getValueAsString() : "";
sendOk(lastClientTxId);
channel.writeString(cfgValue);
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_SET:
{
data.commandInfo="Get config";
checkServerAccess("server.config.set");
final String key=channel.readString();
final String value=channel.readString();
final OGlobalConfiguration cfg=OGlobalConfiguration.findByKey(key);
if (cfg != null) cfg.setValue(value);
sendOk(lastClientTxId);
break;
}
case OChannelBinaryProtocol.REQUEST_CONFIG_LIST:
{
data.commandInfo="List config";
checkServerAccess("server.config.get");
sendOk(lastClientTxId);
channel.writeShort((short)OGlobalConfiguration.values().length);
for (OGlobalConfiguration cfg : OGlobalConfiguration.values()) {
channel.writeString(cfg.getKey());
channel.writeString(cfg.getValueAsString() != null ? cfg.getValueAsString() : "");
}
break;
}
default :
data.commandInfo="Command not supported";
OLogManager.instance().error(this,"Request not supported. Code: " + lastRequestType);
channel.clearInput();
sendError(lastClientTxId,new ONetworkProtocolException("Request not supported. Code: " + lastRequestType));
}
}
