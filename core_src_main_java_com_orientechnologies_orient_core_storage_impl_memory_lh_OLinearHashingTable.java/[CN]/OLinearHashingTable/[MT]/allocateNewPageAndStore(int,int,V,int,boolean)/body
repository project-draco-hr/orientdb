{
  int groupSize=calculateGroupSize(currentLevel);
  byte groupNumber=calculateGroupNumber(bucketNumber,currentLevel);
  int[] pos=groupOverflowTable.searchForGroupOrCreate(groupNumber,groupSize);
  int pageToUse=pageIndicator.getFirstEmptyPage(pos[0],pos[1]);
  int actualStartingPage=pos[0];
  if (pageToUse == -1) {
    if (pos[1] == MAX_GROUP_SIZE) {
      throw new OGroupOverflowException("There is no empty page for group size " + groupSize + " because pages "+ pageIndicator.toString()+ " are already allocated."+ "Starting page is "+ pos[0]);
    }
 else {
      groupSize=pos[1] * 2;
      int newStartingPage=groupOverflowTable.enlargeGroupSize(groupNumber,groupSize);
      moveGroupToNewPosition(pos[0],newStartingPage,pos[1]);
      pageToUse=pageIndicator.getFirstEmptyPage(newStartingPage,groupSize);
      actualStartingPage=newStartingPage;
    }
  }
  if (mainChain) {
    primaryIndex.updateDisplacement(pageToStore,(byte)(pageToUse - actualStartingPage));
  }
 else {
    int realPosInSecondaryIndex=pageIndicator.getRealPosInSecondaryIndex(actualStartingPage + pageToStore - pos[0]);
    secondaryIndex.updateDisplacement(realPosInSecondaryIndex,(byte)(pageToUse - actualStartingPage));
  }
  pageIndicator.set(pageToUse);
  int realPosInSecondaryIndex=pageIndicator.getRealPosInSecondaryIndex(pageToUse);
  secondaryIndex.addNewPosition(realPosInSecondaryIndex);
  OLinearHashingBucket bucket=new OLinearHashingBucket();
  while (file.size() < pageToUse + 1) {
    file.add(null);
  }
  file.set(pageToUse,bucket);
  return storeRecordInBucket(pageToUse,value,false);
}
