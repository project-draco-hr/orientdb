{
  Iterator<Map.Entry<GroupKey,WriteGroup>> entriesIterator=subMap.entrySet().iterator();
  long currentTime=System.currentTimeMillis();
  groupsLoop:   while (entriesIterator.hasNext() && flushedWriteGroups < writeGroupsToFlush) {
    Map.Entry<GroupKey,WriteGroup> entry=entriesIterator.next();
    final WriteGroup group=entry.getValue();
    final GroupKey groupKey=entry.getKey();
    final boolean weakLockMode=group.creationTime - currentTime < groupTTL && !forceFlush;
    if (group.recencyBit && weakLockMode) {
      group.recencyBit=false;
      continue;
    }
    lockManager.acquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    try {
      if (group.recencyBit && weakLockMode)       group.recencyBit=false;
 else {
        group.recencyBit=false;
        int flushedPages=0;
        for (int i=0; i < 16; i++) {
          final OCachePointer pagePointer=group.pages[i];
          if (pagePointer != null) {
            if (!pagePointer.tryAcquireSharedLock())             continue groupsLoop;
            try {
              flushPage(groupKey.fileId,(groupKey.groupIndex << 4) + i,pagePointer.getDataPointer());
              flushedPages++;
              final OLogSequenceNumber flushedLSN=ODurablePage.getLogSequenceNumberFromPage(pagePointer.getDataPointer());
              pagePointer.setLastFlushedLsn(flushedLSN);
            }
  finally {
              pagePointer.releaseSharedLock();
            }
          }
        }
        for (        OCachePointer pagePointer : group.pages)         if (pagePointer != null)         pagePointer.decrementReferrer();
        entriesIterator.remove();
        flushedWriteGroups++;
        cacheSize.addAndGet(-flushedPages);
      }
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    }
    lastGroupKey=groupKey;
  }
  return flushedWriteGroups;
}
