{
  acquireExclusiveLock();
  try {
    this.storage=storageLocal;
    this.keyTypes=keyTypes;
    this.nullKeyIsSupported=nullKeyIsSupported;
    diskCache=storage.getDiskCache();
    this.name=name;
    initStores(metadataConfigurationFileExtension,treeStateFileExtension);
    fileStateId=diskCache.openFile(name + metadataConfigurationFileExtension);
    hashStateEntry=diskCache.load(fileStateId,0,true);
    diskCache.pinPage(hashStateEntry);
    final OCachePointer cachePointer=hashStateEntry.getCachePointer();
    try {
      OHashIndexFileLevelMetadataPage page=new OHashIndexFileLevelMetadataPage(cachePointer.getDataPointer(),ODurablePage.TrackMode.NONE,false);
      treeStateStore.open();
      final int arraySize;
      final int hashTreeSize=page.getHashTreeSize();
      int bitsCount=Integer.bitCount(hashTreeSize);
      if (bitsCount == 1)       arraySize=hashTreeSize;
 else       arraySize=Integer.highestOneBit(hashTreeSize) << 1;
      OHashIndexTreeStateStore.TreeState treeState=treeStateStore.loadTreeState(arraySize);
      hashTree=treeState.getHashTree();
      nodesMetadata=treeState.getHashTreeNodeMetadata();
      keySerializer=(OBinarySerializer<K>)OBinarySerializerFactory.getInstance().getObjectSerializer(page.getKeySerializerId());
      valueSerializer=(OBinarySerializer<V>)OBinarySerializerFactory.getInstance().getObjectSerializer(page.getValueSerializerId());
      for (int i=0; i < HASH_CODE_SIZE; i++)       if (!page.isRemoved(i))       diskCache.openFile(page.getFileId(i));
    }
  finally {
      diskCache.release(hashStateEntry);
    }
    if (nullKeyIsSupported)     nullBucketFileId=diskCache.openFile(name + nullBucketFileExtension);
  }
 catch (  IOException e) {
    throw new OIndexException("Exception during hash table loading",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
