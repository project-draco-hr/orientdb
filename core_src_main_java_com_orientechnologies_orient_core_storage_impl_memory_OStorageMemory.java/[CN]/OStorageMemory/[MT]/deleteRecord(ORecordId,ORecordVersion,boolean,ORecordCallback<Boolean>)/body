{
  final long timer=Orient.instance().getProfiler().startChrono();
  final OCluster cluster=getClusterById(iRid.clusterId);
  lock.acquireSharedLock();
  try {
    lockManager.acquireLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    try {
      final OPhysicalPosition ppos=cluster.getPhysicalPosition(new OPhysicalPosition(iRid.clusterPosition));
      if (ppos == null || (ppos.recordVersion.isTombstone() && useTombstones)) {
        if (iCallback != null)         iCallback.call(iRid,false);
        return false;
      }
      if (iVersion.getCounter() > -1 && !ppos.recordVersion.equals(iVersion))       if (OFastConcurrentModificationException.enabled())       throw OFastConcurrentModificationException.instance();
 else       throw new OConcurrentModificationException(iRid,ppos.recordVersion,iVersion,ORecordOperation.DELETED);
      if (!ppos.recordVersion.isTombstone()) {
        final ODataSegmentMemory dataSegment=getDataSegmentById(ppos.dataSegmentId);
        dataSegment.deleteRecord(ppos.dataSegmentPos);
        ppos.dataSegmentPos=-1;
      }
      if (useTombstones && cluster.hasTombstonesSupport())       cluster.convertToTombstone(iRid.clusterPosition);
 else       cluster.removePhysicalPosition(iRid.clusterPosition);
      if (iCallback != null)       iCallback.call(null,true);
      return true;
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),iRid,LOCK.EXCLUSIVE);
    }
  }
 catch (  IOException e) {
    throw new OStorageException("Error on delete record " + iRid,e);
  }
 finally {
    lock.releaseSharedLock();
    Orient.instance().getProfiler().stopChrono(PROFILER_DELETE_RECORD,"Delete a record from database",timer,"db.*.deleteRecord");
  }
}
