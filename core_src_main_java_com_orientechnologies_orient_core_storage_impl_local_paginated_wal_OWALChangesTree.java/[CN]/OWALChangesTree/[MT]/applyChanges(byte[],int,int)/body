{
  final List<Node> result=new ArrayList<Node>();
  findIntervals(root,start,end,result);
  if (result.isEmpty())   return;
  final Queue<Node> processedNodes=new ArrayDeque<Node>();
  for (  Node activeNode : result) {
    int activeStart=activeNode.start;
    final Iterator<Node> pNodesIterator=processedNodes.iterator();
    while (pNodesIterator.hasNext()) {
      final Node pNode=pNodesIterator.next();
      if (pNode.end > activeStart && pNode.version > activeNode.version)       activeStart=pNode.end;
      if (pNode.end <= activeNode.start)       pNodesIterator.remove();
    }
    processedNodes.add(activeNode);
    if (activeStart >= activeNode.end)     continue;
    final int deltaStart=activeStart - start;
    System.arraycopy(activeNode.value,deltaStart >= 0 ? 0 : -deltaStart,values,deltaStart >= 0 ? deltaStart : 0,deltaStart < 0 ? activeNode.value.length + deltaStart : activeNode.value.length);
  }
}
