{
  atomicOperationsManager.acquireReadLock(this);
  try {
    acquireSharedLock();
    try {
      OAtomicOperation atomicOperation=atomicOperationsManager.getCurrentOperation();
      OClusterPositionMapBucket.PositionEntry positionEntry=clusterPositionMap.get(clusterPosition);
      if (positionEntry == null)       return null;
      int recordPosition=positionEntry.getRecordPosition();
      long pageIndex=positionEntry.getPageIndex();
      if (getFilledUpTo(atomicOperation,fileId) <= pageIndex)       return null;
      ORecordVersion recordVersion=null;
      OCacheEntry cacheEntry=loadPage(atomicOperation,fileId,pageIndex,false);
      try {
        final OClusterPage localPage=new OClusterPage(cacheEntry,false,getChangesTree(atomicOperation,cacheEntry));
        if (localPage.isDeleted(recordPosition))         return null;
        recordVersion=localPage.getRecordVersion(recordPosition);
      }
  finally {
        releasePage(atomicOperation,cacheEntry);
      }
      byte[] fullContent=readFullEntry(clusterPosition,pageIndex,recordPosition,atomicOperation);
      if (fullContent == null)       return null;
      if (useCRC32) {
        CRC32 crc32=new CRC32();
        final int crcPosition=fullContent.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE- OIntegerSerializer.INT_SIZE;
        crc32.update(fullContent,0,crcPosition);
        final int crc=OIntegerSerializer.INSTANCE.deserializeNative(fullContent,crcPosition);
        if (crc != (int)crc32.getValue())         throw new OStorageException("Content of record for cluster with id " + id + " and position "+ clusterPosition+ " is broken.");
      }
      int fullContentPosition=0;
      byte recordType=fullContent[fullContentPosition];
      fullContentPosition++;
      int readContentSize=OIntegerSerializer.INSTANCE.deserializeNative(fullContent,fullContentPosition);
      fullContentPosition+=OIntegerSerializer.INT_SIZE;
      byte[] recordContent=compression.uncompress(fullContent,fullContentPosition,readContentSize);
      return new ORawBuffer(recordContent,recordVersion,recordType);
    }
  finally {
      releaseSharedLock();
    }
  }
  finally {
    atomicOperationsManager.releaseReadLock(this);
  }
}
