{
  checkOpeness();
  checkLowDiskSpaceFullCheckpointRequestsAndBackgroundDataFlushExceptions();
  final ODatabaseDocumentInternal databaseRecord=(ODatabaseDocumentInternal)clientTx.getDatabase();
  final Map<String,OIndexInternal<?>> indexesToCommit=getChangedIndexes(clientTx,databaseRecord.getMetadata().getIndexManager());
  ((OMetadataInternal)databaseRecord.getMetadata()).makeThreadLocalSchemaSnapshot();
  final Iterable<ORecordOperation> entries=(Iterable<ORecordOperation>)clientTx.getAllRecordEntries();
  final Set<ORecordOperation> newRecords=new TreeSet<ORecordOperation>(new Comparator<ORecordOperation>(){
    @Override public int compare(    final ORecordOperation o1,    final ORecordOperation o2){
      return o1.getRecord().getIdentity().compareTo(o2.getRecord().getIdentity());
    }
  }
);
  for (  ORecordOperation txEntry : entries) {
    if (txEntry.type == ORecordOperation.CREATED || txEntry.type == ORecordOperation.UPDATED) {
      final ORecord record=txEntry.getRecord();
      if (record instanceof ODocument)       ((ODocument)record).validate();
    }
    if (txEntry.type == ORecordOperation.CREATED) {
      newRecords.add(txEntry);
    }
  }
  final List<ORecordOperation> result=new ArrayList<ORecordOperation>();
  stateLock.acquireReadLock();
  try {
    try {
      dataLock.acquireExclusiveLock();
      try {
        checkOpeness();
        if (writeAheadLog == null && clientTx.isUsingLog())         throw new OStorageException("WAL mode is not active. Transactions are not supported in given mode");
        makeStorageDirty();
        startStorageTx(clientTx);
        Map<ORecordOperation,OPhysicalPosition> positions=new IdentityHashMap<ORecordOperation,OPhysicalPosition>();
        for (        ORecordOperation txEntry : newRecords) {
          ORecord rec=txEntry.getRecord();
          if (rec.isDirty()) {
            ORecordId rid=(ORecordId)rec.getIdentity().copy();
            ORecordId oldRID=rid.copy();
            int clusterId=rid.clusterId;
            if (rid.clusterId == ORID.CLUSTER_ID_INVALID && rec instanceof ODocument && ODocumentInternal.getImmutableSchemaClass(((ODocument)rec)) != null) {
              final OClass schemaClass=ODocumentInternal.getImmutableSchemaClass(((ODocument)rec));
              clusterId=schemaClass.getClusterForNewInstance((ODocument)rec);
            }
            final OCluster cluster=getClusterById(clusterId);
            OPhysicalPosition ppos=cluster.allocatePosition(ORecordInternal.getRecordType(rec));
            positions.put(txEntry,ppos);
            rid.clusterId=cluster.getId();
            if (rid.clusterPosition > -1 && rid.clusterPosition != ppos.clusterPosition)             throw new OTransactionException("New record allocated #" + rid.clusterId + ":"+ ppos.clusterPosition+ " but the expected was "+ rid);
            rid.clusterPosition=ppos.clusterPosition;
            clientTx.updateIdentityAfterCommit(oldRID,rid);
          }
        }
        for (        ORecordOperation txEntry : entries) {
          commitEntry(txEntry,positions.get(txEntry));
          result.add(txEntry);
        }
        commitIndexes(clientTx,indexesToCommit);
        endStorageTx();
        OTransactionAbstract.updateCacheFromEntries(clientTx,entries,true);
      }
 catch (      IOException ioe) {
        makeRollback(clientTx,ioe);
      }
catch (      RuntimeException e) {
        makeRollback(clientTx,e);
      }
 finally {
        transaction.set(null);
        dataLock.releaseExclusiveLock();
      }
    }
  finally {
      ((OMetadataInternal)databaseRecord.getMetadata()).clearThreadLocalSchemaSnapshot();
    }
  }
  finally {
    stateLock.releaseReadLock();
  }
  return result;
}
