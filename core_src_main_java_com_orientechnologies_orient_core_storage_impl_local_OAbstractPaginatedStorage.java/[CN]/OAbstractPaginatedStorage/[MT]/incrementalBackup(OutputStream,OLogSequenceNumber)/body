{
  OLogSequenceNumber lastLsn;
  checkOpeness();
  if (!backupInProgress.compareAndSet(false,true)) {
    throw new OBackupInProgressException("You are trying to start incremental backup but it is in progress now, please wait till it will be finished",getName(),OErrorCode.BACKUP_IN_PROGRESS);
  }
  stateLock.acquireReadLock();
  try {
    checkOpeness();
    final long freezeId;
    if (!isWritesAllowedDuringBackup())     freezeId=atomicOperationsManager.freezeAtomicOperations(OModificationOperationProhibitedException.class,"Incremental backup in progress");
 else     freezeId=-1;
    try {
      final BufferedOutputStream bufferedOutputStream=new BufferedOutputStream(stream);
      try {
        final ZipOutputStream zipOutputStream=new ZipOutputStream(bufferedOutputStream,Charset.forName(configuration.getCharset()));
        try {
          final long startSegment;
          final long newSegmentFreezeId=atomicOperationsManager.freezeAtomicOperations(null,null);
          try {
            final OLogSequenceNumber startLsn=writeAheadLog.end();
            writeAheadLog.preventCutTill(startLsn);
            writeAheadLog.newSegment();
            startSegment=writeAheadLog.activeSegment();
          }
  finally {
            atomicOperationsManager.releaseAtomicOperations(newSegmentFreezeId);
          }
          try {
            lastLsn=backupPagesWithChanges(fromLsn,zipOutputStream);
            final ZipEntry configurationEntry=new ZipEntry(CONF_ENTRY_NAME);
            zipOutputStream.putNextEntry(configurationEntry);
            final byte[] btConf=configuration.toStream();
            zipOutputStream.write(btConf);
            zipOutputStream.closeEntry();
            final OLogSequenceNumber lastWALLsn=copyWALToIncrementalBackup(zipOutputStream,startSegment);
            if (lastWALLsn != null && (lastLsn == null || lastWALLsn.compareTo(lastLsn) > 0)) {
              lastLsn=lastWALLsn;
            }
          }
  finally {
            writeAheadLog.preventCutTill(null);
          }
        }
  finally {
          zipOutputStream.flush();
        }
      }
  finally {
        bufferedOutputStream.flush();
      }
    }
  finally {
      if (!isWritesAllowedDuringBackup())       atomicOperationsManager.releaseAtomicOperations(freezeId);
    }
  }
  finally {
    stateLock.releaseReadLock();
    backupInProgress.set(false);
  }
  return lastLsn;
}
