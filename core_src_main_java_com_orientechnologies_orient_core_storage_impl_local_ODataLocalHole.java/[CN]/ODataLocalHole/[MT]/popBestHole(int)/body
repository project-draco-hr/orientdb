{
  if (maxHoleSize > -1 && iRecordSize > maxHoleSize)   return -1;
  final long timer=OProfiler.getInstance().startChrono();
  int tempMaxHoleSize=-1;
  int bestHoleIndex=-1;
  int bestHoleSizeGap=-1;
  long bestHolePosition=-1;
  final int holes=getHoles();
  for (int pos=0; pos < holes; ++pos) {
    final long recycledPosition=file.readLong(pos * RECORD_SIZE);
    if (recycledPosition > -1) {
      final int recordSize=file.readInt(pos * RECORD_SIZE + OConstants.SIZE_LONG);
      if (recordSize > tempMaxHoleSize)       tempMaxHoleSize=recordSize;
      if (recordSize == iRecordSize) {
        bestHoleIndex=pos;
        bestHolePosition=recycledPosition;
        bestHoleSizeGap=0;
        tempMaxHoleSize=-1;
        break;
      }
      if (recordSize > iRecordSize && (bestHoleSizeGap == -1 || recordSize - iRecordSize > bestHoleSizeGap)) {
        bestHoleIndex=pos;
        bestHoleSizeGap=recordSize - iRecordSize;
        bestHolePosition=recycledPosition;
      }
    }
  }
  maxHoleSize=tempMaxHoleSize;
  if (bestHoleIndex > -1) {
    if (OLogManager.instance().isDebugEnabled())     OLogManager.instance().debug(this,"Recycling hole data #%d",bestHoleIndex);
    if (bestHoleSizeGap == 0) {
      deleteHole(bestHoleIndex);
      OProfiler.getInstance().stopChrono("Storage.data.recycled.complete",timer);
    }
 else {
      updateHole(bestHoleIndex,bestHolePosition + iRecordSize,bestHoleSizeGap);
      OProfiler.getInstance().stopChrono("Storage.data.recycled.partial",timer);
    }
    return bestHolePosition;
  }
  OProfiler.getInstance().stopChrono("Storage.data.recycled.notfound",timer);
  return -1;
}
