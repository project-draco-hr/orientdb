{
  if (OLogManager.instance().isDebugEnabled())   OLogManager.instance().debug(this,"DISTRIBUTED <-[%s] %s %s v.%d",nodeSource,getName(),rid,version);
  if (status != STATUS.ALIGN && !getDistributedServerManager().checkStatus("online"))   throw new OServerOfflineException();
  final OStorageSynchronizer dbSynchronizer=getDatabaseSynchronizer();
  final long operationLogOffset;
  try {
    operationLogOffset=dbSynchronizer.getLog().journalOperation(runId,operationSerial,getOperationType(),this);
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"DISTRIBUTED <-[%s] error on logging operation %s %s v.%d",e,nodeSource,getName(),rid,version);
    throw new ODistributedException("Error on logging operation",e);
  }
  ODistributedThreadLocal.INSTANCE.distributedExecution=true;
  try {
    final T result=executeOnLocalNode(dbSynchronizer);
    try {
      setAsCompleted(dbSynchronizer,operationLogOffset);
    }
 catch (    IOException e) {
      OLogManager.instance().error(this,"DISTRIBUTED <-[%s] error on changing the log status for operation %s %s v.%d",e,nodeSource,getName(),rid,version);
      throw new ODistributedException("Error on changing the log status",e);
    }
    if (status == STATUS.DISTRIBUTE)     dbSynchronizer.distributeOperation(ORecordOperation.CREATED,rid,this);
    if (mode != EXECUTION_MODE.FIRE_AND_FORGET)     return result;
    return null;
  }
  finally {
    ODistributedThreadLocal.INSTANCE.distributedExecution=false;
  }
}
