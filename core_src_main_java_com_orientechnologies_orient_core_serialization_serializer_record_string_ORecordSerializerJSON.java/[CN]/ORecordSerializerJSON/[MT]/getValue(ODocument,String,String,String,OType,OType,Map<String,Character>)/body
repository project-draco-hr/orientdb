{
  if (iFieldValue.equals("null"))   return null;
  if (iFieldName != null)   if (iRecord.getSchemaClass() != null) {
    final OProperty p=iRecord.getSchemaClass().getProperty(iFieldName);
    if (p != null) {
      iType=p.getType();
      iLinkedType=p.getLinkedType();
    }
  }
  if (iFieldValue.startsWith("{") && iFieldValue.endsWith("}")) {
    iFieldValueAsString=iFieldValue.substring(1,iFieldValue.length() - 1);
    final String[] fields=OStringParser.getWords(iFieldValueAsString,":,",true);
    if (fields == null || fields.length == 0)     return new HashMap<String,Object>();
    if (hasTypeField(fields)) {
      final ORecordInternal<?> recordInternal=fromString(iFieldValue,null);
      if (recordInternal instanceof ODocument)       ((ODocument)recordInternal).addOwner(iRecord);
      return recordInternal;
    }
 else {
      if (fields.length % 2 == 1)       throw new OSerializationException("Bad JSON format on map. Expected pairs of field:value but received '" + iFieldValueAsString + "'");
      final Map<String,Object> embeddedMap=new LinkedHashMap<String,Object>();
      for (int i=0; i < fields.length; i+=2) {
        iFieldName=fields[i];
        if (iFieldName.length() >= 2)         iFieldName=iFieldName.substring(1,iFieldName.length() - 1);
        iFieldValue=fields[i + 1];
        iFieldValueAsString=OStringSerializerHelper.getStringContent(iFieldValue);
        embeddedMap.put(iFieldName,getValue(iRecord,null,iFieldValue,iFieldValueAsString,iLinkedType,null,iFieldTypes));
      }
      return embeddedMap;
    }
  }
 else   if (iFieldValue.startsWith("[") && iFieldValue.endsWith("]")) {
    final Collection<?> embeddedCollection;
    if (iType == OType.LINKSET)     embeddedCollection=new OMVRBTreeRIDSet(iRecord);
 else     if (iType == OType.EMBEDDEDSET)     embeddedCollection=new OTrackedSet<Object>(iRecord);
 else     if (iType == OType.LINKLIST)     embeddedCollection=new ORecordLazyList(iRecord);
 else     embeddedCollection=new OTrackedList<Object>(iRecord);
    iFieldValue=iFieldValue.substring(1,iFieldValue.length() - 1);
    if (!iFieldValue.isEmpty()) {
      List<String> items=OStringSerializerHelper.smartSplit(iFieldValue,',');
      Object collectionItem;
      for (      String item : items) {
        iFieldValue=item.trim();
        iFieldValueAsString=iFieldValue.length() >= 2 ? iFieldValue.substring(1,iFieldValue.length() - 1) : iFieldValue;
        collectionItem=getValue(iRecord,null,iFieldValue,iFieldValueAsString,iLinkedType,null,iFieldTypes);
        if (collectionItem instanceof ODocument && iRecord instanceof ODocument)         ((ODocument)collectionItem).addOwner(iRecord);
        if (collectionItem instanceof String && ((String)collectionItem).length() == 0)         continue;
        ((Collection<Object>)embeddedCollection).add(collectionItem);
      }
    }
    return embeddedCollection;
  }
  if (iType == null)   if (iFieldValue.charAt(0) != '\"' && iFieldValue.charAt(0) != '\'') {
    if (iFieldValue.equalsIgnoreCase("false") || iFieldValue.equalsIgnoreCase("true"))     iType=OType.BOOLEAN;
 else {
      Character c=null;
      if (iFieldTypes != null) {
        c=iFieldTypes.get(iFieldName);
        if (c != null)         iType=ORecordSerializerStringAbstract.getType(iFieldValue + c);
      }
      if (c == null && !iFieldValue.isEmpty()) {
        if (iFieldValue.charAt(0) == ORID.PREFIX && iFieldValue.contains(":"))         iType=OType.LINK;
 else         if (OStringSerializerHelper.contains(iFieldValue,'.'))         iType=OType.FLOAT;
 else {
          final Long v=new Long(OStringSerializerHelper.getStringContent(iFieldValue));
          if (v.longValue() > 0) {
            if (v.compareTo(MAX_INT) <= 0)             return v.intValue();
          }
 else           if (v.compareTo(MIN_INT) >= 0)           return v.intValue();
          return v;
        }
      }
    }
  }
 else   if (iFieldValueAsString.startsWith("{") && iFieldValueAsString.endsWith("}"))   iType=OType.EMBEDDED;
 else {
    if (iFieldValueAsString.length() >= 4 && iFieldValueAsString.charAt(0) == ORID.PREFIX && iFieldValueAsString.contains(":")) {
      final List<String> parts=OStringSerializerHelper.split(iFieldValueAsString,1,-1,':');
      if (parts.size() == 2)       try {
        Short.parseShort(parts.get(0));
        Long.parseLong(parts.get(1));
        iType=OType.LINK;
      }
 catch (      Exception e) {
      }
    }
    if (iFieldTypes != null) {
      Character c=null;
      c=iFieldTypes.get(iFieldName);
      if (c != null)       iType=ORecordSerializerStringAbstract.getType(iFieldValueAsString,c);
    }
    if (iType == null) {
      if (iFieldValueAsString.length() == DEF_DATE_FORMAT.length())       try {
synchronized (dateFormat) {
          return dateFormat.parseObject(iFieldValueAsString);
        }
      }
 catch (      Exception e) {
      }
      iType=OType.STRING;
    }
  }
  if (iType != null) switch (iType) {
case STRING:
    return decodeJSON(iFieldValueAsString);
case LINK:
  final int pos=iFieldValueAsString.indexOf('@');
if (pos > -1) return new ODocument(iFieldValueAsString.substring(1,pos),new ORecordId(iFieldValueAsString.substring(pos + 1)));
 else {
  return new ORecordId(iFieldValueAsString);
}
case EMBEDDED:
return fromString(iFieldValueAsString);
case DATE:
case DATETIME:
if (iFieldValueAsString == null || iFieldValueAsString.equals("")) return null;
try {
return Long.parseLong(iFieldValueAsString);
}
 catch (NumberFormatException e) {
try {
return dateFormat.parseObject(iFieldValueAsString);
}
 catch (ParseException ex) {
throw new OSerializationException("Unable to unmarshall date: " + iFieldValueAsString,e);
}
}
case BINARY:
return OStringSerializerHelper.fieldTypeFromStream(iRecord,iType,iFieldValueAsString);
default :
return OStringSerializerHelper.fieldTypeFromStream(iRecord,iType,iFieldValue);
}
return iFieldValueAsString;
}
