{
  OMVRBTreeEntry<K,V> parentNode=null;
  try {
    if (root == null) {
      root=createEntry(key,value);
      root.setColor(BLACK);
      size=1;
      modCount++;
      if (listener != null)       listener.signalTreeChanged(this);
      return null;
    }
    parentNode=getLastSearchNodeForSameKey(key);
    if (parentNode != null) {
      if (lastSearchFound) {
        pageIndex=lastSearchIndex;
        modCount++;
        return parentNode.setValue(value);
      }
    }
    parentNode=getEntry(key,true,PartialSearchMode.NONE);
    if (pageItemFound)     return parentNode.setValue(value);
    setLastSearchNode(null,null);
    if (parentNode == null) {
      parentNode=root;
      pageIndex=0;
    }
    if (parentNode.getFreeSpace() > 0) {
      parentNode.insert(pageIndex,key,value);
    }
 else {
      final OMVRBTreeEntry<K,V> newNode=createEntry(parentNode);
      if (pageIndex < parentNode.getPageSplitItems())       parentNode.insert(pageIndex,key,value);
 else       newNode.insert(pageIndex - parentNode.getPageSplitItems(),key,value);
      OMVRBTreeEntry<K,V> node=parentNode.getRight();
      OMVRBTreeEntry<K,V> prevNode=parentNode;
      int cmp=0;
      if (comparator != null)       while (node != null) {
        cmp=comparator.compare(newNode.getFirstKey(),node.getFirstKey());
        if (cmp < 0) {
          prevNode=node;
          node=node.getLeft();
        }
 else         if (cmp > 0) {
          prevNode=node;
          node=node.getRight();
        }
 else {
          throw new IllegalStateException();
        }
      }
 else       while (node != null) {
        cmp=((Comparable)newNode.getFirstKey()).compareTo((Comparable)node.getFirstKey());
        if (cmp < 0) {
          prevNode=node;
          node=node.getLeft();
        }
 else         if (cmp > 0) {
          prevNode=node;
          node=node.getRight();
        }
 else {
          throw new IllegalStateException();
        }
      }
      if (prevNode == parentNode)       parentNode.setRight(newNode);
 else       if (cmp < 0)       prevNode.setLeft(newNode);
 else       if (cmp > 0)       prevNode.setRight(newNode);
 else       throw new IllegalStateException();
      fixAfterInsertion(newNode);
    }
    modCount++;
    size++;
    if (listener != null)     listener.signalTreeChanged(this);
  }
  finally {
    checkTreeStructure(parentNode);
  }
  return null;
}
