{
  if (diskCache.getFilledUpTo(fileId) <= pageIndex)   return null;
  final List<byte[]> recordChunks=new ArrayList<byte[]>();
  int contentSize=0;
  long nextPagePointer=-1;
  boolean firstEntry=true;
  do {
    OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
    OCachePointer pointer=cacheEntry.getCachePointer();
    try {
      final OClusterPage localPage=new OClusterPage(pointer.getDataPointer(),false,ODurablePage.TrackMode.NONE);
      int recordPageOffset=localPage.getRecordPageOffset(recordPosition);
      if (recordPageOffset < 0) {
        if (recordChunks.isEmpty())         return null;
 else         throw new OStorageException("Content of record " + new ORecordId(id,clusterPosition) + " was broken.");
      }
      byte[] content=localPage.getBinaryValue(recordPageOffset,localPage.getRecordSize(recordPosition));
      if (firstEntry && content[content.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE] == 0)       return null;
      recordChunks.add(content);
      nextPagePointer=OLongSerializer.INSTANCE.deserializeNative(content,content.length - OLongSerializer.LONG_SIZE);
      contentSize+=content.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE;
      firstEntry=false;
    }
  finally {
      diskCache.release(cacheEntry);
    }
    pageIndex=nextPagePointer >>> PAGE_INDEX_OFFSET;
    recordPosition=(int)(nextPagePointer & RECORD_POSITION_MASK);
  }
 while (nextPagePointer >= 0);
  byte[] fullContent;
  if (recordChunks.size() == 1)   fullContent=recordChunks.get(0);
 else {
    fullContent=new byte[contentSize + OLongSerializer.LONG_SIZE + OByteSerializer.BYTE_SIZE];
    int fullContentPosition=0;
    for (    byte[] recordChuck : recordChunks) {
      System.arraycopy(recordChuck,0,fullContent,fullContentPosition,recordChuck.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE);
      fullContentPosition+=recordChuck.length - OLongSerializer.LONG_SIZE - OByteSerializer.BYTE_SIZE;
    }
  }
  return fullContent;
}
