{
  if (status == STATUS.CLOSED)   return;
  OChannelBinaryAsynchClient network=null;
  stateLock.acquireWriteLock();
  try {
    if (status == STATUS.CLOSED)     return;
    final OStorageRemoteSession session=getCurrentSession();
    if (session != null) {
      final Collection<OStorageRemoteNodeSession> nodes=session.getAll();
      if (!nodes.isEmpty()) {
        for (        OStorageRemoteNodeSession nodeSession : nodes) {
          try {
            network=getNetwork(nodeSession.getServerURL());
            network.beginRequest(OChannelBinaryProtocol.REQUEST_DB_CLOSE,session);
            endRequest(network);
            engine.getConnectionManager().release(network);
          }
 catch (          OIOException ex) {
            OLogManager.instance().debug(this,"Impossible to comunicate to the server for close: %s",ex);
          }
catch (          IOException ex) {
            OLogManager.instance().debug(this,"Impossible to comunicate to the server for close: %s",ex);
          }
        }
        session.close();
        if (!checkForClose(iForce))         return;
      }
 else {
        if (!iForce)         return;
      }
    }
    status=STATUS.CLOSING;
    engine.getConnectionManager().closePool(getCurrentServerURL());
    sbTreeCollectionManager.close();
    super.close(iForce,onDelete);
    status=STATUS.CLOSED;
    Orient.instance().unregisterStorage(this);
  }
 catch (  Exception e) {
    if (network != null) {
      OLogManager.instance().debug(this,"Error on closing remote connection: %s",e,network);
      try {
        network.close();
      }
 catch (      Exception e2) {
        OLogManager.instance().debug(this,"Error on closing socket: %s",e2,network);
      }
    }
  }
 finally {
    stateLock.releaseWriteLock();
  }
}
