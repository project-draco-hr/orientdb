{
  manageConflicts();
  final int bestResponsesGroupIndex=getBestResponsesGroup();
  final List<ODistributedResponse> bestResponsesGroup=responseGroups.get(bestResponsesGroupIndex);
  if (receivedResponses == 0)   throw new ODistributedException("No response received from any of nodes " + getExpectedNodes() + " for request "+ request);
  if (!isMinimumQuorumReached()) {
    request.undo();
    final StringBuilder msg=new StringBuilder();
    msg.append("Quorum " + getQuorum() + " not reached for request="+ request+ ". Servers in conflicts are:");
    final List<ODistributedResponse> res=getConflictResponses();
    if (res.isEmpty())     msg.append(" no server in conflict");
 else     for (    ODistributedResponse r : res) {
      msg.append("\n- ");
      msg.append(r.getExecutorNodeName());
      msg.append(": ");
      msg.append(r.getPayload());
    }
    throw new ODistributedException(msg.toString());
  }
switch (resultStrategy) {
case ANY:
    return bestResponsesGroup.get(0);
case MERGE:
  return bestResponsesGroup.get(0);
case UNION:
final Map<String,Object> payloads=new HashMap<String,Object>();
for (Map.Entry<String,Object> entry : responses.entrySet()) if (entry.getValue() != NO_RESPONSE) payloads.put(entry.getKey(),((ODistributedResponse)entry.getValue()).getPayload());
final ODistributedResponse response=bestResponsesGroup.get(0);
response.setExecutorNodeName(responses.keySet().toString());
response.setPayload(payloads);
return response;
}
return bestResponsesGroup.get(0);
}
