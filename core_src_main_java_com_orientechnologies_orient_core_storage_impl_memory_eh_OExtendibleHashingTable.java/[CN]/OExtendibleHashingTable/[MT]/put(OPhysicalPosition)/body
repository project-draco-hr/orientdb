{
  NodeInfo nodeInfo=getBucket(value.clusterPosition);
  long[] node=hashTree[nodeInfo.nodeIndex];
  long filePosition=node[nodeInfo.itemIndex + nodeInfo.hashMapOffset];
  final OExtendibleHashingBucket bucket;
  long newFilePosition;
  if (filePosition == 0) {
    bucket=new OExtendibleHashingBucket(nodeInfo.nodeGlobalDepth);
    file.add(bucket);
    newFilePosition=file.size();
    node[nodeInfo.itemIndex + nodeInfo.hashMapOffset]=newFilePosition;
  }
 else {
    bucket=file.get((int)filePosition - 1);
  }
  if (bucket.getPosition(value.clusterPosition) > -1)   return false;
  if (bucket.size() < OExtendibleHashingBucket.BUCKET_MAX_SIZE) {
    bucket.addEntry(value);
    size++;
    return true;
  }
  final OExtendibleHashingBucket newBucket=new OExtendibleHashingBucket(bucket.getDepth());
  int bucketDepth=bucket.getDepth();
  bucketDepth=splitBucket(bucket,newBucket,bucketDepth);
  file.add(newBucket);
  newFilePosition=file.size();
  if (bucketDepth <= nodeInfo.nodeGlobalDepth) {
    updateNodeAfterSplit(nodeInfo,bucketDepth,newFilePosition);
  }
 else {
    if (nodeLocalDepths[nodeInfo.nodeIndex] < MAX_LEVEL_DEPTH) {
      final long[] newNode=splitNode(nodeInfo,node);
      final int nodeLocalDepth=nodeLocalDepths[nodeInfo.nodeIndex];
      final int hashMapSize=1 << nodeLocalDepth;
      boolean allHashMapsEquals=checkAllMapsContainSameBucket(newNode,hashMapSize);
      int newNodeIndex=-1;
      if (!allHashMapsEquals) {
        newNodeIndex=addNewNode(newNode,nodeLocalDepth);
      }
      updateNodesAfterSplit(nodeInfo,newNode,nodeLocalDepth,hashMapSize,allHashMapsEquals,newNodeIndex);
      final int newIndex=nodeInfo.itemIndex << 1;
      final int newOffset=nodeInfo.hashMapOffset << 1;
      final int newGlobalDepth=nodeInfo.nodeGlobalDepth + 1;
      if (newOffset < MAX_LEVEL_SIZE) {
        final NodeInfo updatedNodeInfo=new NodeInfo(nodeInfo.parent,newOffset,newIndex,nodeInfo.nodeIndex,newGlobalDepth);
        updateNodeAfterSplit(updatedNodeInfo,bucketDepth,newFilePosition);
      }
 else {
        final NodeInfo newNodeInfo;
        if (!allHashMapsEquals) {
          newNodeInfo=new NodeInfo(nodeInfo.parent,newOffset - MAX_LEVEL_SIZE,newIndex,newNodeIndex,newGlobalDepth);
        }
 else {
          newNodeInfo=nodeInfo.parent;
        }
        updateNodeAfterSplit(newNodeInfo,bucketDepth,newFilePosition);
      }
    }
 else {
      addNewLevelNode(nodeInfo,node,newFilePosition);
    }
  }
  return put(value);
}
