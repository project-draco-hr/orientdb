{
  final GroupKey firstKey=new GroupKey(fileId,0);
  final GroupKey lastKey=new GroupKey(fileId,Long.MAX_VALUE);
  NavigableMap<GroupKey,OWriteGroup> subMap=writeGroups.subMap(firstKey,true,lastKey,true);
  Iterator<Map.Entry<GroupKey,OWriteGroup>> entryIterator=subMap.entrySet().iterator();
  while (entryIterator.hasNext()) {
    Map.Entry<GroupKey,OWriteGroup> entry=entryIterator.next();
    lockManager.acquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    try {
      OWriteGroup writeGroup=entry.getValue();
      for (      OCacheEntry cacheEntry : writeGroup.cacheEntries) {
        if (cacheEntry.usageCounter > 0)         throw new OException("Cache entry is used and can not be deleted. (page index : " + cacheEntry.pageIndex + " file id : "+ fileId+ ")");
        cacheEntry.inWriteCache=false;
        cacheSize.decrementAndGet();
        if (!cacheEntry.inReadCache)         directMemory.free(cacheEntry.dataPointer);
      }
      entryIterator.remove();
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    }
  }
  return null;
}
