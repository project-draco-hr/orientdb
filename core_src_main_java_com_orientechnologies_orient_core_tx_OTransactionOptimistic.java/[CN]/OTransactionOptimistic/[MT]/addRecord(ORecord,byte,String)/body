{
  checkTransaction();
  if (iStatus != ORecordOperation.LOADED)   changedDocuments.remove(iRecord);
  try {
switch (iStatus) {
case ORecordOperation.CREATED:
{
        database.checkSecurity(ORule.ResourceGeneric.CLUSTER,ORole.PERMISSION_CREATE,iClusterName);
        RESULT res=database.callbackHooks(TYPE.BEFORE_CREATE,iRecord);
        if (res == RESULT.RECORD_CHANGED && iRecord instanceof ODocument)         ((ODocument)iRecord).validate();
      }
    break;
case ORecordOperation.LOADED:
  break;
case ORecordOperation.UPDATED:
{
  database.checkSecurity(ORule.ResourceGeneric.CLUSTER,ORole.PERMISSION_UPDATE,iClusterName);
  RESULT res=database.callbackHooks(TYPE.BEFORE_UPDATE,iRecord);
  if (res == RESULT.RECORD_CHANGED && iRecord instanceof ODocument)   ((ODocument)iRecord).validate();
}
break;
case ORecordOperation.DELETED:
database.checkSecurity(ORule.ResourceGeneric.CLUSTER,ORole.PERMISSION_DELETE,iClusterName);
database.callbackHooks(TYPE.BEFORE_DELETE,iRecord);
break;
}
try {
if (iRecord.getIdentity().isTemporary()) temp2persistent.put(iRecord.getIdentity().copy(),iRecord);
final ORecordId rid=(ORecordId)iRecord.getIdentity();
if (!rid.isValid()) {
ORecordInternal.onBeforeIdentityChanged(iRecord);
if (database.getStorage().isAssigningClusterIds() || iClusterName != null) {
if (rid.clusterId == ORID.CLUSTER_ID_INVALID) rid.clusterId=iClusterName != null ? database.getClusterIdByName(iClusterName) : database.getDefaultClusterId();
if (database.getStorageVersions().classesAreDetectedByClusterId() && iRecord instanceof ODocument) {
final ODocument recordSchemaAware=(ODocument)iRecord;
final OClass recordClass=ODocumentInternal.getImmutableSchemaClass(recordSchemaAware);
final OClass clusterIdClass=((OMetadataInternal)database.getMetadata()).getImmutableSchemaSnapshot().getClassByClusterId(rid.clusterId);
if (recordClass == null && clusterIdClass != null || clusterIdClass == null && recordClass != null || (recordClass != null && !recordClass.equals(clusterIdClass))) throw new OSchemaException("Record saved into cluster " + iClusterName + " should be saved with class "+ clusterIdClass+ " but saved with class "+ recordClass);
}
}
rid.clusterPosition=newObjectCounter--;
ORecordInternal.onAfterIdentityChanged(iRecord);
}
ORecordOperation txEntry=getRecordEntry(rid);
if (txEntry == null) {
if (!(rid.isTemporary() && iStatus != ORecordOperation.CREATED)) {
txEntry=new ORecordOperation(iRecord,iStatus);
recordEntries.put(rid,txEntry);
}
}
 else {
txEntry.record=iRecord;
switch (txEntry.type) {
case ORecordOperation.LOADED:
switch (iStatus) {
case ORecordOperation.UPDATED:
txEntry.type=ORecordOperation.UPDATED;
break;
case ORecordOperation.DELETED:
txEntry.type=ORecordOperation.DELETED;
break;
}
break;
case ORecordOperation.UPDATED:
switch (iStatus) {
case ORecordOperation.DELETED:
txEntry.type=ORecordOperation.DELETED;
break;
}
break;
case ORecordOperation.DELETED:
break;
case ORecordOperation.CREATED:
switch (iStatus) {
case ORecordOperation.DELETED:
recordEntries.remove(rid);
break;
}
break;
}
}
switch (iStatus) {
case ORecordOperation.CREATED:
database.callbackHooks(TYPE.AFTER_CREATE,iRecord);
break;
case ORecordOperation.LOADED:
break;
case ORecordOperation.UPDATED:
database.callbackHooks(TYPE.AFTER_UPDATE,iRecord);
break;
case ORecordOperation.DELETED:
database.callbackHooks(TYPE.AFTER_DELETE,iRecord);
break;
}
if (iRecord instanceof ODocument && ((ODocument)iRecord).isTrackingChanges()) {
ODocumentInternal.clearTrackData(((ODocument)iRecord));
}
}
 catch (Throwable t) {
switch (iStatus) {
case ORecordOperation.CREATED:
database.callbackHooks(TYPE.CREATE_FAILED,iRecord);
break;
case ORecordOperation.UPDATED:
database.callbackHooks(TYPE.UPDATE_FAILED,iRecord);
break;
case ORecordOperation.DELETED:
database.callbackHooks(TYPE.DELETE_FAILED,iRecord);
break;
}
if (t instanceof RuntimeException) throw (RuntimeException)t;
 else throw new ODatabaseException("Error on saving record " + iRecord.getIdentity(),t);
}
}
  finally {
switch (iStatus) {
case ORecordOperation.CREATED:
database.callbackHooks(TYPE.FINALIZE_CREATION,iRecord);
break;
case ORecordOperation.UPDATED:
database.callbackHooks(TYPE.FINALIZE_UPDATE,iRecord);
break;
}
}
}
