{
  checkForRebuild();
  key=getCollatingValue(key);
  final ODatabase database=getDatabase();
  final boolean txIsActive=database.getTransaction().isActive();
  if (!txIsActive)   keyLockManager.acquireExclusiveLock(key);
  try {
    modificationLock.requestModificationLock();
    try {
      final Set<String> words=splitIntoWords(key.toString());
      boolean removed=false;
      for (      final String word : words) {
        acquireSharedLock();
        startStorageAtomicOperation();
        try {
          final Set<OIdentifiable> recs=indexEngine.get(word);
          if (recs != null && !recs.isEmpty()) {
            if (recs.remove(value)) {
              if (recs.isEmpty())               indexEngine.remove(word);
 else               indexEngine.put(word,recs);
              removed=true;
            }
          }
          commitStorageAtomicOperation();
        }
 catch (        RuntimeException e) {
          rollbackStorageAtomicOperation();
          throw new OIndexException("Error during removal of entry by key and value",e);
        }
 finally {
          releaseSharedLock();
        }
      }
      return removed;
    }
  finally {
      modificationLock.releaseModificationLock();
    }
  }
  finally {
    if (!txIsActive)     keyLockManager.releaseExclusiveLock(key);
  }
}
