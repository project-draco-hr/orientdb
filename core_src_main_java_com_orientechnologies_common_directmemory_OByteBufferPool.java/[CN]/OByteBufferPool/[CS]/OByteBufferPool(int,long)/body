{
  this.pageSize=pageSize;
  this.zeroPage=ByteBuffer.allocateDirect(pageSize).order(ByteOrder.nativeOrder());
  if (preallocatePages > 0) {
    int pagesPerArea=(Integer.MAX_VALUE / pageSize);
    pagesPerArea=closestPowerOfTwo(pagesPerArea);
    while ((long)pagesPerArea * pageSize > Integer.MAX_VALUE) {
      pagesPerArea=pagesPerArea >>> 1;
    }
    maxPagesPerSingleArea=pagesPerArea;
    final int arraySize=(int)((preallocatePages + maxPagesPerSingleArea - 1) / maxPagesPerSingleArea);
    preallocatedAreas=new AtomicReferenceArray<BufferHolder>(arraySize);
    final int allocationSize=(int)Math.min(maxPagesPerSingleArea,preallocatePages);
    final ByteBuffer buffer=ByteBuffer.allocateDirect(allocationSize * pageSize).order(ByteOrder.nativeOrder());
    final BufferHolder holder=new BufferHolder();
    preallocatedAreas.set(0,holder);
    try {
      holder.buffer=buffer;
    }
  finally {
      holder.latch.countDown();
    }
    this.preallocatedPages=preallocatePages;
  }
 else {
    preallocatedAreas=null;
    maxPagesPerSingleArea=-1;
    this.preallocatedPages=-1;
  }
}
