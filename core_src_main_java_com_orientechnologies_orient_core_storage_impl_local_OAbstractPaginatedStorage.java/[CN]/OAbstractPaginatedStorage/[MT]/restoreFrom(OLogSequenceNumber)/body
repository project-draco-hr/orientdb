{
  wereDataRestoredAfterOpen=true;
  long recordsProcessed=0;
  int reportInterval=OGlobalConfiguration.WAL_REPORT_AFTER_OPERATIONS_DURING_RESTORE.getValueAsInteger();
  final AtomicBoolean lowMemoryFlag=new AtomicBoolean(false);
  OMemoryWatchDog.Listener listener=new OMemoryWatchDog.Listener(){
    @Override public void lowMemory(    long iFreeMemory,    long iFreeMemoryPercentage){
      lowMemoryFlag.set(true);
    }
  }
;
  listener=Orient.instance().getMemoryWatchDog().addListener(listener);
  Map<OOperationUnitId,List<OLogSequenceNumber>> operationUnits=new HashMap<OOperationUnitId,List<OLogSequenceNumber>>();
  List<OWALRecord> batch=new ArrayList<OWALRecord>();
  try {
    while (lsn != null) {
      OWALRecord walRecord=writeAheadLog.read(lsn);
      batch.add(walRecord);
      if (lowMemoryFlag.get()) {
        OLogManager.instance().info(this,"Heap memory is low apply batch of operations are read from WAL.");
        recordsProcessed=restoreWALBatch(batch,operationUnits,recordsProcessed,reportInterval);
        batch=new ArrayList<OWALRecord>();
        lowMemoryFlag.set(false);
      }
      lsn=writeAheadLog.next(lsn);
    }
    if (!batch.isEmpty()) {
      OLogManager.instance().info(this,"Apply last batch of operations are read from WAL.");
      restoreWALBatch(batch,operationUnits,recordsProcessed,reportInterval);
      batch=null;
    }
  }
 catch (  OWALPageBrokenException e) {
    OLogManager.instance().error(this,"Data restore was paused because broken WAL page was found. The rest of changes will be rolled back.");
  }
  rollbackAllUnfinishedWALOperations(operationUnits);
  operationUnits.clear();
  Orient.instance().getMemoryWatchDog().removeListener(listener);
}
