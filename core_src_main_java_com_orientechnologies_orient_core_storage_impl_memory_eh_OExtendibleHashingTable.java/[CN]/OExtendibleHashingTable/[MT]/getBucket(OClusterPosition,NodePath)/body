{
  final long hash=key.longValueHigh();
  int nodeDepth;
  int localNodeDepth;
  NodePath parentNode;
  int nodeIndex;
  int offset;
  if (startNode != null) {
    nodeDepth=startNode.nodeGlobalDepth;
    localNodeDepth=nodesMetadata[startNode.nodeIndex].getNodeLocalDepth();
    parentNode=startNode;
    nodeIndex=startNode.nodeIndex;
    offset=startNode.hashMapOffset;
  }
 else {
    localNodeDepth=nodesMetadata[0].getNodeLocalDepth();
    nodeDepth=localNodeDepth;
    parentNode=null;
    nodeIndex=0;
    offset=0;
  }
  int index=(int)((hash >>> (64 - nodeDepth)) & (levelMask >>> (maxLevelDepth - localNodeDepth)));
  NodePath currentNode=new NodePath(parentNode,0,index,0,nodeDepth,localNodeDepth);
  do {
    final long position=hashTree[nodeIndex][index + offset];
    if (position >= 0)     return currentNode;
    nodeIndex=(int)((position & Long.MAX_VALUE) >>> 8);
    offset=(int)(position & 0xFF);
    localNodeDepth=nodesMetadata[nodeIndex].getNodeLocalDepth();
    nodeDepth+=localNodeDepth;
    index=(int)((hash >>> (64 - nodeDepth)) & (levelMask >>> (maxLevelDepth - localNodeDepth)));
    parentNode=currentNode;
    currentNode=new NodePath(parentNode,offset,index,nodeIndex,nodeDepth,localNodeDepth);
  }
 while (nodeDepth <= 64);
  throw new IllegalStateException("Extendible hashing tree in corrupted state.");
}
