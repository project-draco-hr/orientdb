{
  acquireExclusiveLock();
  final OStorageTransaction transaction=storage.getStorageTransaction();
  try {
    final int keySize=keySerializer.getObjectSize(key,(Object[])keyTypes);
    final int valueSize=valueSerializer.getObjectSize(value);
    if (keySize > MAX_KEY_SIZE)     throw new OSBTreeException("Key size is more than allowed, operation was canceled. Current key size " + keySize + ", allowed  "+ MAX_KEY_SIZE);
    final boolean createLinkToTheValue=valueSize > MAX_EMBEDDED_VALUE_SIZE;
    key=keySerializer.preprocess(key,(Object[])keyTypes);
    startAtomicOperation();
    long valueLink=-1;
    if (createLinkToTheValue)     valueLink=createLinkToTheValue(value);
    final OSBTreeValue<V> treeValue=new OSBTreeValue<V>(createLinkToTheValue,valueLink,createLinkToTheValue ? null : value);
    BucketSearchResult bucketSearchResult=findBucket(key,PartialSearchMode.NONE);
    OCacheEntry keyBucketCacheEntry=diskCache.load(fileId,bucketSearchResult.getLastPathItem(),false);
    OCachePointer keyBucketPointer=keyBucketCacheEntry.getCachePointer();
    keyBucketPointer.acquireExclusiveLock();
    OSBTreeBucket<K,V> keyBucket=new OSBTreeBucket<K,V>(keyBucketPointer.getDataPointer(),keySerializer,keyTypes,valueSerializer,getTrackMode());
    int insertionIndex;
    int sizeDiff;
    if (bucketSearchResult.itemIndex >= 0) {
      boolean canBeUpdated=keyBucket.updateValue(bucketSearchResult.itemIndex,treeValue);
      if (canBeUpdated) {
        logPageChanges(keyBucket,fileId,keyBucketCacheEntry.getPageIndex(),false);
        keyBucketCacheEntry.markDirty();
        keyBucketPointer.releaseExclusiveLock();
        diskCache.release(keyBucketCacheEntry);
        endAtomicOperation(false);
        return;
      }
 else {
        long removedLinkedValue=keyBucket.remove(bucketSearchResult.itemIndex);
        if (removedLinkedValue >= 0)         removeLinkedValue(removedLinkedValue);
        insertionIndex=bucketSearchResult.itemIndex;
        sizeDiff=0;
      }
    }
 else {
      insertionIndex=-bucketSearchResult.itemIndex - 1;
      sizeDiff=1;
    }
    while (!keyBucket.addEntry(insertionIndex,new OSBTreeBucket.SBTreeEntry<K,V>(-1,-1,key,treeValue),true)) {
      logPageChanges(keyBucket,fileId,keyBucketCacheEntry.getPageIndex(),false);
      keyBucketPointer.releaseExclusiveLock();
      diskCache.release(keyBucketCacheEntry);
      bucketSearchResult=splitBucket(bucketSearchResult.path,insertionIndex,key);
      insertionIndex=bucketSearchResult.itemIndex;
      keyBucketCacheEntry=diskCache.load(fileId,bucketSearchResult.getLastPathItem(),false);
      keyBucketPointer=keyBucketCacheEntry.getCachePointer();
      keyBucketPointer.acquireExclusiveLock();
      keyBucket=new OSBTreeBucket<K,V>(keyBucketPointer.getDataPointer(),keySerializer,keyTypes,valueSerializer,getTrackMode());
    }
    logPageChanges(keyBucket,fileId,bucketSearchResult.getLastPathItem(),false);
    keyBucketCacheEntry.markDirty();
    keyBucketPointer.releaseExclusiveLock();
    diskCache.release(keyBucketCacheEntry);
    setSize(size() + sizeDiff);
    endAtomicOperation(false);
  }
 catch (  IOException e) {
    rollback(transaction);
    throw new OSBTreeException("Error during index update with key " + key + " and value "+ value,e);
  }
 finally {
    releaseExclusiveLock();
  }
}
