{
  if (status == TXSTATUS.ROLLED_BACK || status == TXSTATUS.ROLLBACKING)   throw new ORollbackException("Given transaction was rolled back and can not be used.");
  status=TXSTATUS.COMMITTING;
  if (OScenarioThreadLocal.INSTANCE.get() != RUN_MODE.RUNNING_DISTRIBUTED && !(database.getStorage() instanceof OStorageEmbedded))   database.getStorage().commit(this,null);
 else {
    List<OIndexAbstract<?>> lockedIndexes=acquireIndexLocks();
    try {
      final Map<String,OIndex<?>> indexes=new HashMap<String,OIndex<?>>();
      for (      OIndex<?> index : database.getMetadata().getIndexManager().getIndexes())       indexes.put(index.getName(),index);
      final Runnable callback=new CommitIndexesCallback(indexes);
      final String storageType=database.getStorage().getType();
      if (storageType.equals(OEngineLocalPaginated.NAME) || storageType.equals(OEngineMemory.NAME))       database.getStorage().commit(OTransactionOptimistic.this,callback);
 else {
        database.getStorage().callInLock(new Callable<Object>(){
          @Override public Object call() throws Exception {
            database.getStorage().commit(OTransactionOptimistic.this,callback);
            return null;
          }
        }
,true);
      }
    }
  finally {
      releaseIndexLocks(lockedIndexes);
    }
  }
  close();
  status=TXSTATUS.COMPLETED;
}
