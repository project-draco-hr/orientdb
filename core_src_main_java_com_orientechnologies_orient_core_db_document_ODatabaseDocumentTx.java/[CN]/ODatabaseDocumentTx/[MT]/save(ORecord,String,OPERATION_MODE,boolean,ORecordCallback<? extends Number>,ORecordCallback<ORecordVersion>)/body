{
  checkOpeness();
  if (!(iRecord instanceof ODocument))   return (RET)currentTx.saveRecord(iRecord,iClusterName,iMode,iForceCreate,iRecordCreatedCallback,iRecordUpdatedCallback);
  ODocument doc=(ODocument)iRecord;
  if (iForceCreate || !doc.getIdentity().isValid()) {
    if (doc.getClassName() != null)     checkSecurity(ODatabaseSecurityResources.CLASS,ORole.PERMISSION_CREATE,doc.getClassName());
    final OClass schemaClass=doc.getImmutableSchemaClass();
    if (iClusterName == null && schemaClass != null) {
      if (schemaClass.isAbstract())       throw new OSchemaException("Document belongs to abstract class " + schemaClass.getName() + " and can not be saved");
      iClusterName=getClusterNameById(schemaClass.getClusterForNewInstance(doc));
    }
    int id=getClusterIdByName(iClusterName);
    if (id == -1)     throw new IllegalArgumentException("Cluster name " + iClusterName + " is not configured");
    final int[] clusterIds;
    if (schemaClass != null) {
      clusterIds=schemaClass.getClusterIds();
      int i=0;
      for (; i < clusterIds.length; ++i)       if (clusterIds[i] == id)       break;
      if (i == clusterIds.length)       throw new IllegalArgumentException("Cluster name " + iClusterName + " is not configured to store the class "+ doc.getClassName());
    }
 else     clusterIds=new int[]{id};
  }
 else {
    if (doc.getClassName() != null)     checkSecurity(ODatabaseSecurityResources.CLASS,ORole.PERMISSION_UPDATE,doc.getClassName());
  }
  doc.validate();
  ODocumentInternal.convertAllMultiValuesToTrackedVersions(doc);
  doc=(ODocument)currentTx.saveRecord(iRecord,iClusterName,iMode,iForceCreate,iRecordCreatedCallback,iRecordUpdatedCallback);
  return (RET)doc;
}
