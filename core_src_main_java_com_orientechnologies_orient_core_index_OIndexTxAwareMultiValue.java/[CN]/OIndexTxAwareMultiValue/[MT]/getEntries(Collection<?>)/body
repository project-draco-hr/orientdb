{
  final Collection<?> keys=new ArrayList<Object>(iKeys);
  final Set<ODocument> result=new ODocumentFieldsHashSet();
  final Set<Object> keysToRemove=new HashSet<Object>();
  final OTransactionIndexChanges indexChanges=database.getTransaction().getIndexChanges(delegate.getName());
  if (indexChanges == null) {
    return super.getEntries(keys);
  }
  for (  final Object key : keys) {
    final Set<OIdentifiable> keyResult;
    if (!indexChanges.cleared)     if (indexChanges.containsChangesPerKey(key))     keyResult=new TreeSet<OIdentifiable>(super.get(key));
 else     continue;
 else     keyResult=new TreeSet<OIdentifiable>();
    keysToRemove.add(key);
    filterIndexChanges(indexChanges,key,keyResult);
    for (    final OIdentifiable id : keyResult) {
      final ODocument document=new ODocument();
      document.field("key",key);
      document.field("rid",id.getIdentity());
      document.unsetDirty();
      result.add(document);
    }
  }
  keys.removeAll(keysToRemove);
  if (!keys.isEmpty())   result.addAll(super.getEntries(keys));
  return result;
}
