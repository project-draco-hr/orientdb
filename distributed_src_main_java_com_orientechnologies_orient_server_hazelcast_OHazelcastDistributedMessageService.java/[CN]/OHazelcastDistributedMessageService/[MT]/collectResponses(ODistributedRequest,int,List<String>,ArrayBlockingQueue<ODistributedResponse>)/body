{
  if (iRequest.getExecutionMode() == EXECUTION_MODE.NO_RESPONSE)   return null;
  final int queueSize=iNodes.size();
  final ODistributedResponse[] responses=new ODistributedResponse[queueSize];
  int receivedSynchResponses=0;
  ODistributedResponse firstResponse=null;
  int availableNodes=0;
  for (  String node : iNodes) {
    if (manager.isNodeAvailable(node))     availableNodes++;
 else     ODistributedServerLog.warn(this,getLocalNodeNameAndThread(),node,DIRECTION.OUT,"skip listening of response because node '%s' is not online",node);
  }
  final int expectedSynchronousResponses=Math.min(availableNodes,Math.min(queueSize,writeQuorum));
  final ODistributedResponseManager currentResponseMgr=new ODistributedResponseManager(iRequest.getId(),iNodes);
  asynchResponses.put(iRequest.getId(),currentResponseMgr);
  final long beginTime=System.currentTimeMillis();
  for (int i=0; i < expectedSynchronousResponses; ++i) {
    final long elapsed=System.currentTimeMillis() - beginTime;
    responses[i]=responseQueue.poll(MSG_RECEIVE_RESPONSE_TIMEOUT - elapsed,TimeUnit.MILLISECONDS);
    if (responses[i] != null) {
      if (responses[i].getRequestId() == iRequest.getId())       currentResponseMgr.addResponse(responses[i]);
 else {
        processAsynchResponse(responses[i]);
        --i;
        continue;
      }
      ODistributedServerLog.debug(this,getLocalNodeNameAndThread(),responses[i].getSenderNodeName(),DIRECTION.IN,"- received response: %s",responses[i]);
      if (firstResponse == null)       firstResponse=responses[i];
      receivedSynchResponses++;
    }
 else     ODistributedServerLog.warn(this,getLocalNodeNameAndThread(),null,DIRECTION.IN,"- timeout (%dms) on response for request: %s",elapsed,iRequest);
  }
  if (queueSize > writeQuorum) {
  }
  for (int i=0; i < responses.length; ++i) {
  }
  if (receivedSynchResponses < writeQuorum) {
    iRequest.undo();
  }
  return firstResponse;
}
