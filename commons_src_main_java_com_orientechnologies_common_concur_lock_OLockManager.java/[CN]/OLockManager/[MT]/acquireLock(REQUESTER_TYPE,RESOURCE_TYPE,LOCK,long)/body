{
  if (!enabled)   return;
  CountableLock lock;
  final Object internalLock=internalLock(iResourceId);
synchronized (internalLock) {
    lock=map.get(iResourceId);
    if (lock == null) {
      final CountableLock newLock=new CountableLock(iTimeout > 0);
      lock=map.putIfAbsent(getImmutableResourceId(iResourceId),newLock);
      if (lock == null)       lock=newLock;
    }
    lock.countLocks++;
  }
  try {
    if (iTimeout <= 0) {
      if (iLockType == LOCK.SHARED)       lock.readLock().lock();
 else       lock.writeLock().lock();
    }
 else {
      try {
        if (iLockType == LOCK.SHARED) {
          if (!lock.readLock().tryLock(iTimeout,TimeUnit.MILLISECONDS))           throw new OLockException("Timeout on acquiring resource '" + iResourceId + "' because is locked from another thread");
        }
 else {
          if (!lock.writeLock().tryLock(iTimeout,TimeUnit.MILLISECONDS))           throw new OLockException("Timeout on acquiring resource '" + iResourceId + "' because is locked from another thread");
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new OLockException("Thread interrupted while waiting for resource '" + iResourceId + "'");
      }
    }
  }
 catch (  RuntimeException e) {
synchronized (internalLock) {
      lock.countLocks--;
      if (lock.countLocks == 0)       map.remove(iResourceId);
    }
    throw e;
  }
}
