{
synchronized (syncObject) {
    OFileClassic fileClassic=files.get(fileId);
    if (fileClassic == null || !fileClassic.isOpen())     return;
    final Set<Long> pageIndexes=filePages.get(fileId);
    Long[] sortedPageIndexes=new Long[pageIndexes.size()];
    sortedPageIndexes=pageIndexes.toArray(sortedPageIndexes);
    Arrays.sort(sortedPageIndexes);
    final SortedMap<Long,OLogSequenceNumber> fileDirtyPages=dirtyPages.get(fileId);
    for (    Long pageIndex : sortedPageIndexes) {
      OCacheEntry cacheEntry=get(fileId,pageIndex,true);
      if (cacheEntry != null) {
        if (cacheEntry.usageCounter == 0) {
          cacheEntry=remove(fileId,pageIndex);
          fileDirtyPages.remove(pageIndex);
          if (cacheEntry.dataPointer != ODirectMemory.NULL_POINTER) {
            if (flush)             flushData(fileId,pageIndex,cacheEntry.dataPointer);
            directMemory.free(cacheEntry.dataPointer);
          }
        }
 else         throw new OStorageException("Page with index " + pageIndex + " for file with id "+ fileId+ "can not be freed because it is used.");
      }
 else {
        Long dataPointer=evictedPages.remove(new FileLockKey(fileId,pageIndex));
        if (dataPointer != null) {
          if (flush)           flushData(fileId,pageIndex,dataPointer);
          fileDirtyPages.remove(pageIndex);
        }
      }
    }
    pageIndexes.clear();
    fileClassic.close();
  }
}
