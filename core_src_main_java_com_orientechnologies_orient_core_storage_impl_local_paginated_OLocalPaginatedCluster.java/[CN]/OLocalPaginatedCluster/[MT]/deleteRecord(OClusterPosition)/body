{
  externalModificationLock.requestModificationLock();
  try {
    acquireExclusiveLock();
    try {
      long pagePointer=clusterPosition.longValue();
      int recordPosition=(int)(pagePointer & RECORD_POSITION_MASK);
      long pageIndex=pagePointer >>> PAGE_INDEX_OFFSET;
      if (diskCache.getFilledUpTo(fileId) <= pageIndex)       return false;
      boolean isRecordSpreadAcrossSeveralPages=isRecordSpreadAcrossSeveralPages(pageIndex,recordPosition);
      final OLocalPage.TrackMode trackMode;
      if (writeAheadLog == null)       trackMode=OLocalPage.TrackMode.NONE;
 else       if (isRecordSpreadAcrossSeveralPages)       trackMode=OLocalPage.TrackMode.BOTH;
 else       trackMode=OLocalPage.TrackMode.FORWARD;
      long nextPagePointer=-1;
      int removedContentSize=0;
      do {
        long pointer=diskCache.load(fileId,pageIndex);
        int initialFreePageIndex;
        try {
          final OLocalPage localPage=new OLocalPage(pointer,false,trackMode);
          initialFreePageIndex=calculateFreePageIndex(localPage);
          int recordPageOffset=localPage.getRecordPageOffset(recordPosition);
          if (recordPageOffset < 0) {
            if (removedContentSize == 0)             return false;
 else             throw new OStorageException("Content of record " + new ORecordId(id,clusterPosition) + " was broken.");
          }
 else           if (removedContentSize == 0 && writeAheadLog != null) {
            OLogSequenceNumber lsn=writeAheadLog.log(new OAtomicUnitStartRecord(isRecordSpreadAcrossSeveralPages));
            lastLsn.set(lsn);
          }
          byte[] content=localPage.getBinaryValue(recordPageOffset,localPage.getRecordSize(recordPosition));
          int initialFreeSpace=localPage.getFreeSpace();
          localPage.deleteRecord(recordPosition);
          removedContentSize+=localPage.getFreeSpace() - initialFreeSpace;
          nextPagePointer=OLongSerializer.INSTANCE.deserializeNative(content,content.length - OLongSerializer.LONG_SIZE);
          logPageChanges(localPage,pageIndex);
        }
  finally {
          diskCache.markDirty(fileId,pageIndex);
          diskCache.release(fileId,pageIndex);
        }
        updateFreePagesIndex(initialFreePageIndex,pageIndex,trackMode);
        pageIndex=nextPagePointer >>> PAGE_INDEX_OFFSET;
        recordPosition=(int)(nextPagePointer & RECORD_POSITION_MASK);
      }
 while (nextPagePointer >= 0);
      size--;
      recordsSize-=removedContentSize;
      logClusterState();
      if (writeAheadLog != null) {
        writeAheadLog.log(new OAtomicUnitEndRecord(lastLsn.get()));
        lastLsn.set(null);
      }
      return true;
    }
  finally {
      releaseExclusiveLock();
    }
  }
  finally {
    externalModificationLock.releaseModificationLock();
  }
}
