{
  acquireExclusiveLock();
  try {
    long holePositionOffset=iRecordOffset;
    int holeSize=iRecordSize + RECORD_FIX_SIZE;
    final int holes=holeSegment.getHoles();
    final int defragHoleDistance;
    if (defragMaxHoleDistance > 0)     defragHoleDistance=defragMaxHoleDistance;
 else {
      final long size=getSize();
      defragHoleDistance=Math.max(32768 * (int)(size / 10000000),32768);
    }
    if (holes > 0) {
      final OPhysicalPosition ppos=new OPhysicalPosition();
      long[] pos=getRelativePosition(iRecordOffset);
      final OFile file=files[(int)pos[0]];
      final int[] fileRanges;
      if (pos[0] == 0)       fileRanges=new int[]{0,file.getFilledUpTo()};
 else       fileRanges=new int[]{files[(int)pos[0] - 1].getFileSize(),file.getFilledUpTo()};
      int closestHoleIndex=-1;
      long closestHoleOffset=Integer.MAX_VALUE;
      OPhysicalPosition closestPpos=new OPhysicalPosition();
      for (int i=0; i < holes; ++i) {
        if (!holeSegment.getHole(i,ppos))         continue;
        boolean closest=false;
        if (ppos.dataPosition >= fileRanges[0] && ppos.dataPosition < fileRanges[1])         if (iRecordOffset > ppos.dataPosition) {
          if (closestHoleIndex == -1 || iRecordOffset - (ppos.dataPosition + ppos.recordSize) < Math.abs(closestHoleOffset)) {
            closestHoleOffset=(ppos.dataPosition + ppos.recordSize) - iRecordOffset;
            closest=true;
          }
        }
 else {
          if (closestHoleIndex == -1 || ppos.dataPosition - (iRecordOffset + iRecordSize) < Math.abs(closestHoleOffset)) {
            closestHoleOffset=ppos.dataPosition - (iRecordOffset + iRecordSize);
            closest=true;
          }
        }
        if (closest) {
          closestHoleIndex=i;
          ppos.copyTo(closestPpos);
        }
      }
      if (closestPpos.dataPosition + closestPpos.recordSize == iRecordOffset) {
        holeSize+=closestPpos.recordSize;
        holeSegment.updateHole(closestHoleIndex,closestPpos.dataPosition,holeSize);
      }
 else       if (holePositionOffset + holeSize == closestPpos.dataPosition) {
        holeSize+=closestPpos.recordSize;
        holeSegment.updateHole(closestHoleIndex,holePositionOffset,holeSize);
      }
 else {
        if (Math.abs(closestHoleOffset) < defragHoleDistance) {
          if (closestHoleOffset < 0) {
            closestHoleOffset*=-1;
            long moveFrom=closestPpos.dataPosition + closestPpos.recordSize;
            int recordSize;
            final long offsetLimit=iRecordOffset;
            final List<long[]> segmentPositions=new ArrayList<long[]>();
            while (moveFrom < offsetLimit) {
              pos=getRelativePosition(moveFrom);
              if (pos[1] >= file.getFilledUpTo())               break;
              recordSize=file.readInt(pos[1]) + RECORD_FIX_SIZE;
              segmentPositions.add(0,new long[]{moveFrom,recordSize});
              moveFrom+=recordSize;
            }
            long gap=offsetLimit + holeSize;
            for (            long[] item : segmentPositions) {
              final int sizeMoved=moveRecord(item[0],gap - item[1]);
              if (sizeMoved != item[1])               throw new IllegalStateException("Corrupted holes: Found size " + sizeMoved + " instead of "+ item[1]);
              gap-=sizeMoved;
            }
            holePositionOffset=closestPpos.dataPosition;
            holeSize+=closestPpos.recordSize;
          }
 else {
            long moveFrom=iRecordOffset + iRecordSize + RECORD_FIX_SIZE;
            long moveTo=iRecordOffset;
            final long moveUpTo=closestPpos.dataPosition;
            while (moveFrom < moveUpTo) {
              final int sizeMoved=moveRecord(moveFrom,moveTo);
              moveFrom+=sizeMoved;
              moveTo+=sizeMoved;
            }
            if (moveFrom != moveUpTo)             throw new IllegalStateException("Corrupted holes: Found offset " + moveFrom + " instead of "+ moveUpTo);
            holePositionOffset=moveTo;
            holeSize+=closestPpos.recordSize;
          }
          holeSegment.updateHole(closestHoleIndex,holePositionOffset,holeSize);
        }
 else {
          holeSegment.createHole(iRecordOffset,holeSize);
        }
      }
    }
 else     holeSegment.createHole(iRecordOffset,holeSize);
    final long[] pos=getRelativePosition(holePositionOffset);
    files[(int)pos[0]].writeInt(pos[1],holeSize * -1);
  }
  finally {
    releaseExclusiveLock();
  }
}
