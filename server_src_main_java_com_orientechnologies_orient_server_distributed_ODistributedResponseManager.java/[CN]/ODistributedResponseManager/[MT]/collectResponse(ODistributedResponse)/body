{
  final String executorNode=response.getExecutorNodeName();
synchronized (responseLock) {
    if (!responses.containsKey(executorNode)) {
      ODistributedServerLog.warn(this,response.getSenderNodeName(),executorNode,DIRECTION.IN,"received response for request (%s) from unexpected node. Expected are: %s",request,getExpectedNodes());
      Orient.instance().getProfiler().updateCounter("distributed.node.unexpectedNodeResponse","Number of responses from unexpected nodes",+1);
      return false;
    }
    Orient.instance().getProfiler().stopChrono("distributed.node.latency","Latency of distributed messages",sentOn,"distributed.node.latency");
    Orient.instance().getProfiler().stopChrono("distributed.node." + executorNode + ".latency","Latency of distributed messages per node",sentOn,"distributed.node.*.latency");
    boolean completed=false;
    responses.put(executorNode,response);
    receivedResponses++;
    if (waitForLocalNode && response.isExecutedOnLocalNode())     receivedCurrentNode=true;
    if (ODistributedServerLog.isDebugEnabled())     ODistributedServerLog.debug(this,response.getSenderNodeName(),executorNode,DIRECTION.IN,"received response '%s' for request (%s) (receivedCurrentNode=%s receivedResponses=%d expectedSynchronousResponses=%d quorum=%d)",response,request,receivedCurrentNode,receivedResponses,expectedSynchronousResponses,quorum);
    if (groupResponsesByResult) {
      boolean foundBucket=false;
      for (int i=0; i < responseGroups.size(); ++i) {
        final List<ODistributedResponse> sameResponse=responseGroups.get(i);
        if (sameResponse.isEmpty() || (sameResponse.get(0).getPayload() == null && response.getPayload() == null) || sameResponse.get(0).getPayload().equals(response.getPayload())) {
          sameResponse.add(response);
          foundBucket=true;
          break;
        }
      }
      if (!foundBucket) {
        final ArrayList<ODistributedResponse> newBucket=new ArrayList<ODistributedResponse>();
        responseGroups.add(newBucket);
        newBucket.add(response);
      }
    }
    completed=getExpectedResponses() == receivedResponses;
    if (receivedResponses >= expectedSynchronousResponses && (!waitForLocalNode || receivedCurrentNode)) {
      if (completed || isMinimumQuorumReached(false)) {
        notifyWaiters();
      }
    }
    return completed;
  }
}
