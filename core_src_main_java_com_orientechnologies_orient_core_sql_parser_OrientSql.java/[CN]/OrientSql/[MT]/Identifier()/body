{
  OIdentifier jjtn000=new OIdentifier(JJTIDENTIFIER);
  boolean jjtc000=true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
  Token quotedToken=null;
  Token token=null;
  try {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case IDENTIFIER:
      token=jj_consume_token(IDENTIFIER);
    break;
case IN:
  token=jj_consume_token(IN);
break;
case SET:
token=jj_consume_token(SET);
break;
case PUT:
token=jj_consume_token(PUT);
break;
case ADD:
token=jj_consume_token(ADD);
break;
case REMOVE:
token=jj_consume_token(REMOVE);
break;
case MERGE:
token=jj_consume_token(MERGE);
break;
case CONTENT:
token=jj_consume_token(CONTENT);
break;
case ORDER:
token=jj_consume_token(ORDER);
break;
case KEY:
token=jj_consume_token(KEY);
break;
case OFFSET:
token=jj_consume_token(OFFSET);
break;
case GROUP:
token=jj_consume_token(GROUP);
break;
case VALUES:
token=jj_consume_token(VALUES);
break;
case RECORD:
token=jj_consume_token(RECORD);
break;
case TO:
token=jj_consume_token(TO);
break;
case LUCENE:
token=jj_consume_token(LUCENE);
break;
case CLASS:
token=jj_consume_token(CLASS);
break;
case CLASSES:
token=jj_consume_token(CLASSES);
break;
case MINDEPTH:
token=jj_consume_token(MINDEPTH);
break;
case NEAR:
token=jj_consume_token(NEAR);
break;
case WITHIN:
token=jj_consume_token(WITHIN);
break;
case EXCEPTION:
token=jj_consume_token(EXCEPTION);
break;
case PROFILE:
token=jj_consume_token(PROFILE);
break;
case STORAGE:
token=jj_consume_token(STORAGE);
break;
case ON:
token=jj_consume_token(ON);
break;
case OFF:
token=jj_consume_token(OFF);
break;
case TRUNCATE:
token=jj_consume_token(TRUNCATE);
break;
case FIND:
token=jj_consume_token(FIND);
break;
case REFERENCES:
token=jj_consume_token(REFERENCES);
break;
case EXTENDS:
token=jj_consume_token(EXTENDS);
break;
case CLUSTERS:
token=jj_consume_token(CLUSTERS);
break;
case ABSTRACT:
token=jj_consume_token(ABSTRACT);
break;
case ALTER:
token=jj_consume_token(ALTER);
break;
case NAME:
token=jj_consume_token(NAME);
break;
case SHORTNAME:
token=jj_consume_token(SHORTNAME);
break;
case SUPERCLASS:
token=jj_consume_token(SUPERCLASS);
break;
case SUPERCLASSES:
token=jj_consume_token(SUPERCLASSES);
break;
case OVERSIZE:
token=jj_consume_token(OVERSIZE);
break;
case STRICTMODE:
token=jj_consume_token(STRICTMODE);
break;
case ADDCLUSTER:
token=jj_consume_token(ADDCLUSTER);
break;
case REMOVECLUSTER:
token=jj_consume_token(REMOVECLUSTER);
break;
case CUSTOM:
token=jj_consume_token(CUSTOM);
break;
case CLUSTERSELECTION:
token=jj_consume_token(CLUSTERSELECTION);
break;
case DESCRIPTION:
token=jj_consume_token(DESCRIPTION);
break;
case ENCRYPTION:
token=jj_consume_token(ENCRYPTION);
break;
case DROP:
token=jj_consume_token(DROP);
break;
case PROPERTY:
token=jj_consume_token(PROPERTY);
break;
case FORCE:
token=jj_consume_token(FORCE);
break;
case QUOTED_IDENTIFIER:
quotedToken=jj_consume_token(QUOTED_IDENTIFIER);
break;
default :
jj_la1[0]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
jjtree.closeNodeScope(jjtn000,true);
jjtc000=false;
jjtn000.jjtSetLastToken(getToken(0));
if (token != null) {
jjtn000.value=token.image;
}
 else {
jjtn000.quoted=true;
jjtn000.value=quotedToken.image;
jjtn000.value=jjtn000.value.substring(1,jjtn000.value.length() - 1);
}
{
if (true) return jjtn000;
}
}
  finally {
if (jjtc000) {
jjtree.closeNodeScope(jjtn000,true);
jjtn000.jjtSetLastToken(getToken(0));
}
}
throw new Error("Missing return statement in function");
}
