{
  final OModifiableBoolean atLeastOnePageUpdate=new OModifiableBoolean(false);
  long recordsProcessed=0;
  int reportInterval=OGlobalConfiguration.WAL_REPORT_AFTER_OPERATIONS_DURING_RESTORE.getValueAsInteger();
  int batchSize=OGlobalConfiguration.WAL_RESTORE_BATCH_SIZE.getValueAsInteger();
  Map<OOperationUnitId,List<OLogSequenceNumber>> operationUnits=new HashMap<OOperationUnitId,List<OLogSequenceNumber>>();
  ReferenceQueue<OWALRecord> batchQueue=new ReferenceQueue<OWALRecord>();
  List<SoftReference<OWALRecord>> batch=new ArrayList<SoftReference<OWALRecord>>();
  OLogSequenceNumber startLsn=lsn;
  try {
    restoreLoop:     while (lsn != null) {
      OWALRecord walRecord;
      try {
        walRecord=writeAheadLog.read(lsn);
      }
 catch (      Exception e) {
        OLogManager.instance().error(this,"Data restore was paused because of exception during reading of wal record.",e);
        break restoreLoop;
      }
      batch.add(new SoftReference<OWALRecord>(walRecord,batchQueue));
      if (batchQueue.poll() != null) {
        lsn=startLsn;
        batchSize=batchSize / 2;
        batch=new ArrayList<SoftReference<OWALRecord>>(batchSize);
        batchQueue=new ReferenceQueue<OWALRecord>();
        System.gc();
        OLogManager.instance().error(this,"You have not enough amount of heap to operate with restore buffer of size %d, size of buffer will be decreased too %d, " + "during next start of JVM please set this parameter %s to %d to avoid this message.",batchSize * 2,batchSize,OGlobalConfiguration.WAL_RESTORE_BATCH_SIZE.getKey(),batchSize);
        continue restoreLoop;
      }
      if (batch.size() >= batchSize) {
        OLogManager.instance().info(this,"WAL size exceed configured heap memory for recovery (%s=%d). Fetching WAL records in batch",OGlobalConfiguration.WAL_RESTORE_BATCH_SIZE.getKey(),batchSize);
        final List<OWALRecord> hardBatch=new ArrayList<OWALRecord>(batch.size());
        for (        SoftReference<OWALRecord> reference : batch) {
          final OWALRecord record=reference.get();
          if (batchQueue.poll() != null || record == null) {
            lsn=startLsn;
            batchSize=batchSize / 2;
            batch=new ArrayList<SoftReference<OWALRecord>>(batchSize);
            batchQueue=new ReferenceQueue<OWALRecord>();
            System.gc();
            OLogManager.instance().error(this,"You have not enough amount of heap to operate with restore buffer of size %d, size of buffer will be decreased too %d, " + "during next start of JVM please set this parameter %s to %d to avoid this message.",batchSize * 2,batchSize,OGlobalConfiguration.WAL_RESTORE_BATCH_SIZE.getKey(),batchSize);
            continue restoreLoop;
          }
 else {
            hardBatch.add(record);
          }
        }
        recordsProcessed=restoreWALBatch(hardBatch,operationUnits,recordsProcessed,reportInterval,atLeastOnePageUpdate);
        hardBatch.clear();
        batch=new ArrayList<SoftReference<OWALRecord>>();
        batchQueue=new ReferenceQueue<OWALRecord>();
      }
      lsn=writeAheadLog.next(lsn);
      if (lsn == null) {
        final List<OWALRecord> hardBatch=new ArrayList<OWALRecord>();
        for (        SoftReference<OWALRecord> reference : batch) {
          final OWALRecord record=reference.get();
          if (batchQueue.poll() != null || record == null) {
            lsn=startLsn;
            batchSize=batchSize / 2;
            batch=new ArrayList<SoftReference<OWALRecord>>(batchSize);
            batchQueue=new ReferenceQueue<OWALRecord>();
            System.gc();
            OLogManager.instance().error(this,"You have not enough amount of heap to operate with restore buffer of size %d, size of buffer will be decreased too %d, " + "during next start of JVM please set this parameter %s to %d to avoid this message.",batchSize * 2,batchSize,OGlobalConfiguration.WAL_RESTORE_BATCH_SIZE.getKey(),batchSize);
            continue restoreLoop;
          }
 else {
            hardBatch.add(record);
          }
        }
        OLogManager.instance().info(this,"Apply last batch of operations are read from WAL.");
        restoreWALBatch(hardBatch,operationUnits,recordsProcessed,reportInterval,atLeastOnePageUpdate);
        break;
      }
      startLsn=lsn;
    }
  }
 catch (  OWALPageBrokenException e) {
    OLogManager.instance().error(this,"Data restore was paused because broken WAL page was found. The rest of changes will be rolled back.");
  }
  rollbackAllUnfinishedWALOperations(operationUnits);
  operationUnits.clear();
  return atLeastOnePageUpdate.getValue();
}
