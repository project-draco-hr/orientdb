{
  if (!currentTx.isActive())   return this;
  if (!force && currentTx.amountOfNestedTxs() > 1) {
    currentTx.commit();
    return this;
  }
  setCurrentDatabaseinThreadLocal();
  for (  ODatabaseListener listener : underlying.browseListeners())   try {
    listener.onBeforeTxCommit(this);
  }
 catch (  Throwable t) {
    try {
      rollback(force);
    }
 catch (    RuntimeException e) {
      throw e;
    }
    OLogManager.instance().debug(this,"Cannot commit the transaction: caught exception on execution of %s.onBeforeTxCommit()",t,OTransactionBlockedException.class,listener.getClass());
  }
  try {
    currentTx.commit(force);
  }
 catch (  RuntimeException e) {
    for (    ODatabaseListener listener : underlying.browseListeners())     try {
      listener.onBeforeTxRollback(underlying);
    }
 catch (    Throwable t) {
      OLogManager.instance().error(this,"Error before tx rollback",t);
    }
    currentTx.rollback(false,0);
    for (    ODatabaseListener listener : underlying.browseListeners())     try {
      listener.onAfterTxRollback(underlying);
    }
 catch (    Throwable t) {
      OLogManager.instance().error(this,"Error after tx rollback",t);
    }
    throw e;
  }
  for (  ODatabaseListener listener : underlying.browseListeners())   try {
    listener.onAfterTxCommit(underlying);
  }
 catch (  Throwable t) {
    OLogManager.instance().debug(this,"Error after the transaction has been committed. The transaction remains valid. The exception caught was on execution of %s.onAfterTxCommit()",t,OTransactionBlockedException.class,listener.getClass());
  }
  return this;
}
