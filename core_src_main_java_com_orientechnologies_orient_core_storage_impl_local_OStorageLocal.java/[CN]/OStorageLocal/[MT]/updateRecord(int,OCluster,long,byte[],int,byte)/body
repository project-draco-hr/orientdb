{
  final long timer=OProfiler.getInstance().startChrono();
  final boolean locked=lock.acquireSharedLock();
  try {
    final OPhysicalPosition ppos=iClusterSegment.getPhysicalPosition(iPosition,new OPhysicalPosition());
    if (!checkForRecordValidity(ppos))     return -1;
    if (iVersion > -1 && iVersion < ppos.version)     throw new OConcurrentModificationException("Can't update record #" + iClusterSegment.getId() + ":"+ iPosition+ " because it has been modified by another user (v"+ ppos.version+ " != v"+ iVersion+ ") in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction");
    if (ppos.type != iRecordType)     iClusterSegment.updateRecordType(iPosition,iRecordType);
    iClusterSegment.updateVersion(iPosition,++ppos.version);
    final long newDataSegmentOffset=getDataSegment(ppos.dataSegment).setRecord(ppos.dataPosition,iClusterSegment.getId(),iPosition,iContent);
    if (newDataSegmentOffset != ppos.dataPosition)     iClusterSegment.setPhysicalPosition(iPosition,ppos.dataSegment,newDataSegmentOffset,iRecordType);
    incrementVersion();
    return ppos.version;
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"Error on updating record #" + iPosition + " in cluster: "+ iClusterSegment,e);
  }
 finally {
    lock.releaseSharedLock(locked);
    OProfiler.getInstance().stopChrono("OStorageLocal.updateRecord",timer);
  }
  return -1;
}
