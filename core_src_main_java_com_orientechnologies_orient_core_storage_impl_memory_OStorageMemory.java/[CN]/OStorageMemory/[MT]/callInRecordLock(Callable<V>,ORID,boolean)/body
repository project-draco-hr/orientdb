{
  lock.acquireSharedLock();
  try {
    lockManager.acquireLock(Thread.currentThread(),rid,exclusiveLock ? LOCK.EXCLUSIVE : LOCK.SHARED);
    try {
      return callable.call();
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),rid,exclusiveLock ? LOCK.EXCLUSIVE : LOCK.SHARED);
    }
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Exception e) {
    throw new OException("Error on nested call in lock",e);
  }
 finally {
    lock.releaseSharedLock();
  }
}
