{
  int offset=nodePath.nodeGlobalDepth - bucketDepth;
  NodePath currentNode=nodePath;
  int nodeLocalDepth=nodePath.nodeLocalDepth;
  while (offset > 0) {
    offset-=nodeLocalDepth;
    if (offset > 0) {
      currentNode=nodePath.parent;
      nodeLocalDepth=currentNode.nodeLocalDepth;
    }
  }
  final int diff=bucketDepth - (currentNode.nodeGlobalDepth - nodeLocalDepth);
  final int firstStartIndex=currentNode.itemIndex & ((levelMask << (nodeLocalDepth - diff)) & levelMask);
  final int globalIndex=firstStartIndex + currentNode.hashMapOffset - 1;
  final NodePath nodePathToFind;
  if (globalIndex < 0)   nodePathToFind=prevLevelUp(nodePath);
 else {
    final int hashMapSize=1 << currentNode.nodeLocalDepth;
    final int hashMapOffset=globalIndex / hashMapSize * hashMapSize;
    final int startIndex=globalIndex - hashMapOffset;
    nodePathToFind=new NodePath(currentNode.parent,hashMapOffset,startIndex,currentNode.nodeIndex,currentNode.nodeLocalDepth,currentNode.nodeGlobalDepth);
  }
  return prevNonEmptyNode(nodePathToFind);
}
