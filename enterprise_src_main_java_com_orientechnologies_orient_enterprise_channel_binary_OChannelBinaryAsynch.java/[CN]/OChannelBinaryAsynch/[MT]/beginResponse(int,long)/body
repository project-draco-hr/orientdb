{
  int unreadResponse=0;
  do {
    if (iTimeout <= 0)     lockRead.lock();
 else     if (!lockRead.tryLock(iTimeout,TimeUnit.MILLISECONDS))     throw new OTimeoutException("Cannot acquire read lock against channel: " + this);
    if (!channelRead) {
      channelRead=true;
      try {
        currentStatus=readByte();
        currentSessionId=readInt();
      }
 catch (      IOException e) {
        lockRead.unlock();
        channelRead=false;
        throw e;
      }
    }
    if (currentSessionId == iRequesterId)     break;
    if (unreadResponse > MAX_UNREAD_RESPONSES) {
      final StringBuilder dirtyBuffer=new StringBuilder();
      int i=0;
      while (in.available() > 0) {
        char c=(char)in.read();
        ++i;
        if (dirtyBuffer.length() < MAX_LENGTH_DEBUG) {
          if (dirtyBuffer.length() > 0)           dirtyBuffer.append('-');
          dirtyBuffer.append(c);
        }
      }
      OLogManager.instance().error(this,"Received unread response for session=" + currentSessionId + ", probably corrupted data from the network connection. Cleared dirty data in the buffer ("+ i+ " bytes): ["+ dirtyBuffer+ (i > dirtyBuffer.length() ? "..." : "")+ "]",OIOException.class);
    }
    lockRead.unlock();
synchronized (this) {
      try {
        final long start=System.currentTimeMillis();
        wait(1000);
        if (System.currentTimeMillis() - start >= 1000)         unreadResponse++;
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
 while (true);
  handleStatus(currentStatus,currentSessionId);
}
