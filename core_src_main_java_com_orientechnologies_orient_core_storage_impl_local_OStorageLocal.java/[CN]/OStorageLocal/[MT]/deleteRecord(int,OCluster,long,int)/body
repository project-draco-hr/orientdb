{
  final long timer=OProfiler.getInstance().startChrono();
  final String recId=ORecordId.generateString(iClusterSegment.getId(),iPosition);
  final boolean locked=lock.acquireSharedLock();
  try {
    final OPhysicalPosition ppos=iClusterSegment.getPhysicalPosition(iPosition,new OPhysicalPosition());
    if (!checkForRecordValidity(ppos))     return false;
    if (iVersion > -1 && ppos.version != iVersion)     throw new OConcurrentModificationException("Can't delete the record #" + recId + " because it was modified by another user in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction");
    iClusterSegment.removePhysicalPosition(iPosition,ppos);
    getDataSegment(ppos.dataSegment).deleteRecord(ppos.dataPosition);
    incrementVersion();
    return true;
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"Error on deleting record #" + iPosition + " in cluster: "+ iClusterSegment,e);
  }
 finally {
    lock.releaseSharedLock(locked);
    OProfiler.getInstance().stopChrono("OStorageLocal.deleteRecord",timer);
  }
  return false;
}
