{
  this.serverInstance=iServer;
  this.dManager=iServer.getDistributedManager();
  this.wrapped=wrapped;
  ODistributedServerLog.debug(this,dManager != null ? dManager.getLocalNodeName() : "?",null,ODistributedServerLog.DIRECTION.NONE,"Installing distributed storage on database '%s'",wrapped.getName());
  purgeDeletedRecordsTask=new TimerTask(){
    @Override public void run(){
      try {
        final long now=System.currentTimeMillis();
        for (Iterator<Map.Entry<ORecordId,OPair<Long,Integer>>> it=deletedRecords.entrySet().iterator(); it.hasNext(); ) {
          final Map.Entry<ORecordId,OPair<Long,Integer>> entry=it.next();
          try {
            final ORecordId rid=entry.getKey();
            final long time=entry.getValue().getKey();
            final int version=entry.getValue().getValue();
            if (now - time > (OGlobalConfiguration.DISTRIBUTED_ASYNCH_RESPONSES_TIMEOUT.getValueAsLong() * 2)) {
              final OStorageOperationResult<Boolean> result=wrapped.deleteRecord(rid,version,0,null);
              if (result == null || !result.getResult())               OLogManager.instance().error(this,"Error on deleting record %s v.%s",rid,version);
            }
          }
  finally {
            it.remove();
          }
        }
      }
 catch (      Throwable e) {
        OLogManager.instance().debug(this,"Error on purge deleted record tasks for database %s",e,getName());
      }
    }
  }
;
  Orient.instance().scheduleTask(purgeDeletedRecordsTask,OGlobalConfiguration.DISTRIBUTED_PURGE_RESPONSES_TIMER_DELAY.getValueAsLong(),OGlobalConfiguration.DISTRIBUTED_PURGE_RESPONSES_TIMER_DELAY.getValueAsLong());
  final int queueSize=OGlobalConfiguration.DISTRIBUTED_ASYNCH_QUEUE_SIZE.getValueAsInteger();
  if (queueSize <= 0)   asynchronousOperationsQueue=new LinkedBlockingQueue<OAsynchDistributedOperation>();
 else   asynchronousOperationsQueue=new LinkedBlockingQueue<OAsynchDistributedOperation>(queueSize);
  asynchWorker=new Thread(){
    @Override public void run(){
      while (running) {
        try {
          final OAsynchDistributedOperation operation=asynchronousOperationsQueue.take();
          ODistributedRequestId reqId=null;
          try {
            final ODistributedResponse dResponse=dManager.sendRequest(operation.getDatabaseName(),operation.getClusterNames(),operation.getNodes(),operation.getTask(),operation.getCallback() != null ? EXECUTION_MODE.RESPONSE : EXECUTION_MODE.NO_RESPONSE,operation.getLocalResult(),operation.getAfterRequestCallback());
            reqId=dResponse.getRequestId();
            if (operation.getCallback() != null)             operation.getCallback().call(new OPair<ODistributedRequestId,Object>(reqId,dResponse.getPayload()));
          }
  finally {
            if (operation.getAfterRequestCallback() != null)             operation.getAfterRequestCallback().call(reqId);
          }
        }
 catch (        InterruptedException e) {
          final int pendingMessages=asynchronousOperationsQueue.size();
          if (pendingMessages > 0)           ODistributedServerLog.info(this,dManager != null ? dManager.getLocalNodeName() : "?",null,ODistributedServerLog.DIRECTION.NONE,"Received shutdown signal, waiting for asynchronous queue is empty (pending msgs=%d)...",pendingMessages);
          Thread.interrupted();
        }
catch (        Throwable e) {
          if (running)           if (e instanceof ONeedRetryException)           ODistributedServerLog.debug(this,dManager != null ? dManager.getLocalNodeName() : "?",null,ODistributedServerLog.DIRECTION.OUT,"Error on executing asynchronous operation",e);
 else           ODistributedServerLog.error(this,dManager != null ? dManager.getLocalNodeName() : "?",null,ODistributedServerLog.DIRECTION.OUT,"Error on executing asynchronous operation",e);
        }
      }
      ODistributedServerLog.debug(this,dManager != null ? dManager.getLocalNodeName() : "?",null,ODistributedServerLog.DIRECTION.NONE,"Shutdown asynchronous queue worker for database '%s' completed",wrapped.getName());
    }
  }
;
  asynchWorker.setName("OrientDB Distributed asynch ops node=" + getNodeId() + " db="+ getName());
  asynchWorker.start();
  clusterLocks=new Semaphore[32];
  for (int i=0; i < clusterLocks.length; ++i)   clusterLocks[i]=new Semaphore(1);
}
