{
  ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.IN,"fixing %d conflicts found during committing transaction against db=%s...",tasks.size(),database.getName());
  ODatabaseRecordThreadLocal.INSTANCE.set(database);
  try {
    OScenarioThreadLocal.executeAsDistributed(new Callable<Object>(){
      @Override public Object call() throws Exception {
        for (        ORemoteTask task : tasks) {
          if (task instanceof OAbstractRecordReplicatedTask)           ((OAbstractRecordReplicatedTask)task).setLockRecord(false);
          task.execute(iServer,iManager,database);
        }
        return null;
      }
    }
);
  }
 catch (  Exception e) {
    OLogManager.instance().error(this,"Exception during attempt to fix inconsistency between nodes",e);
    return Boolean.FALSE;
  }
 finally {
    final ODistributedDatabase ddb=iManager.getMessageService().getDatabase(database.getName());
    if (locks != null)     for (    ORID r : locks)     ddb.unlockRecord(r);
  }
  return Boolean.TRUE;
}
