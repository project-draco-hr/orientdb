{
  if (rid != null && version != null)   ODistributedServerLog.info(this,getDistributedServerManager().getLocalNodeId(),getNodeSource(),DIRECTION.IN,"operation %s against record %s/%s v.%s",getName(),databaseName,rid.toString(),version.toString());
  final ODistributedServerManager dManager=getDistributedServerManager();
  if (status != STATUS.ALIGN && !dManager.checkStatus("online") && !getNodeSource().equals(dManager.getLocalNodeId()))   throw new OServerOfflineException(dManager.getLocalNodeId(),dManager.getStatus(),"Cannot execute the operation because the server is offline: current status: " + dManager.getStatus());
  final OStorageSynchronizer dbSynchronizer=getDatabaseSynchronizer();
  final OPERATION_TYPES opType=getOperationType();
  final long operationLogOffset;
  if (opType != null)   try {
    operationLogOffset=dbSynchronizer.getLog().journalOperation(runId,operationSerial,opType,this);
  }
 catch (  IOException e) {
    ODistributedServerLog.error(this,getDistributedServerManager().getLocalNodeId(),getNodeSource(),DIRECTION.IN,"error on logging operation %s %s/%s v.%s",e,getName(),databaseName,rid.toString(),version.toString());
    throw new ODistributedException("Error on logging operation",e);
  }
 else   operationLogOffset=-1;
  ODistributedThreadLocal.INSTANCE.set(getNodeSource());
  try {
    final T localResult=executeOnLocalNode(dbSynchronizer);
    if (opType != null)     try {
      setAsCompleted(dbSynchronizer,operationLogOffset);
    }
 catch (    IOException e) {
      ODistributedServerLog.error(this,getDistributedServerManager().getLocalNodeId(),getNodeSource(),DIRECTION.IN,"error on changing the log status for operation %s %s/%s v.%s",e,getName(),databaseName,rid.toString(),version.toString());
      throw new ODistributedException("Error on changing the log status",e);
    }
    if (status == STATUS.DISTRIBUTE && getDistributedServerManager().getLocalNodeId().equals(getNodeSource())) {
      final Map<String,Object> distributedResult=dbSynchronizer.distributeOperation(ORecordOperation.CREATED,rid,this);
      if (distributedResult != null)       for (      Entry<String,Object> entry : distributedResult.entrySet()) {
        final String remoteNode=entry.getKey();
        final Object remoteResult=entry.getValue();
        if ((localResult == null && remoteResult != null) || (localResult != null && remoteResult == null) || !localResult.equals(remoteResult)) {
          handleConflict(remoteNode,localResult,remoteResult);
        }
      }
    }
    if (mode != EXECUTION_MODE.FIRE_AND_FORGET)     return localResult;
    return null;
  }
  finally {
    ODistributedThreadLocal.INSTANCE.set(null);
  }
}
