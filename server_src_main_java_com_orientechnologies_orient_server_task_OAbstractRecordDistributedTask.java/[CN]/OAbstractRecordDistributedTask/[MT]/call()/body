{
  if (OLogManager.instance().isDebugEnabled()) {
    if (rid != null && version != null)     OLogManager.instance().debug(this,"DISTRIBUTED <-[%s] %s %s v.%s",nodeSource,getName(),rid.toString(),version.toString());
  }
  final ODistributedServerManager dManager=getDistributedServerManager();
  if (status != STATUS.ALIGN && !dManager.checkStatus("online") && !nodeSource.equals(dManager.getLocalNodeId()))   throw new OServerOfflineException(dManager.getLocalNodeId(),"Cannot execute the operation because the server is offline: current status: " + dManager.getStatus());
  final OStorageSynchronizer dbSynchronizer=getDatabaseSynchronizer();
  final OPERATION_TYPES opType=getOperationType();
  final long operationLogOffset;
  if (opType != null)   try {
    operationLogOffset=dbSynchronizer.getLog().journalOperation(runId,operationSerial,opType,this);
  }
 catch (  IOException e) {
    OLogManager.instance().error(this,"DISTRIBUTED <-[%s] error on logging operation %s %s v.%s",e,nodeSource,getName(),rid.toString(),version.toString());
    throw new ODistributedException("Error on logging operation",e);
  }
 else   operationLogOffset=-1;
  ODistributedThreadLocal.INSTANCE.distributedExecution=true;
  ODistributedThreadLocal.INSTANCE.distributedRequestSource=nodeSource;
  try {
    final T localResult=executeOnLocalNode(dbSynchronizer);
    if (opType != null)     try {
      setAsCompleted(dbSynchronizer,operationLogOffset);
    }
 catch (    IOException e) {
      OLogManager.instance().error(this,"DISTRIBUTED <-[%s] error on changing the log status for operation %s %s v.%s",e,nodeSource,getName(),rid.toString(),version.toString());
      throw new ODistributedException("Error on changing the log status",e);
    }
    if (status == STATUS.DISTRIBUTE) {
      final Map<String,Object> distributedResult=dbSynchronizer.distributeOperation(ORecordOperation.CREATED,rid,this);
      if (distributedResult != null)       for (      Entry<String,Object> entry : distributedResult.entrySet()) {
        final String remoteNode=entry.getKey();
        final Object remoteResult=entry.getValue();
        if (localResult != remoteResult && (localResult == null && remoteResult != null || localResult != null && remoteResult == null)) {
          handleConflict(remoteNode,localResult,remoteResult);
        }
      }
    }
    if (mode != EXECUTION_MODE.FIRE_AND_FORGET)     return localResult;
    return null;
  }
  finally {
    ODistributedThreadLocal.INSTANCE.distributedExecution=false;
  }
}
