{
  final boolean locked=lock.acquireSharedLock();
  try {
    final List<OTransactionEntry<? extends ORecord<?>>> allEntries=new ArrayList<OTransactionEntry<? extends ORecord<?>>>();
    final List<OTransactionEntry<? extends ORecord<?>>> tmpEntries=new ArrayList<OTransactionEntry<? extends ORecord<?>>>();
    while (iTx.getEntries().iterator().hasNext()) {
      for (      OTransactionEntry<? extends ORecord<?>> txEntry : iTx.getEntries())       tmpEntries.add(txEntry);
      iTx.clearEntries();
      for (      OTransactionEntry<? extends ORecord<?>> txEntry : tmpEntries)       commitEntry(iRequesterId,iTx.getId(),txEntry);
      allEntries.addAll(tmpEntries);
      tmpEntries.clear();
    }
    OTransactionAbstract.updateCacheFromEntries(this,iTx,allEntries);
    allEntries.clear();
  }
 catch (  IOException e) {
    rollback(iRequesterId,iTx);
  }
 finally {
    lock.releaseSharedLock(locked);
  }
}
