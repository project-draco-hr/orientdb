{
  if (rebuildIndexesThread != null)   return;
  final ODatabaseRecord db=getDatabase();
  final ODatabaseDocumentTx newDb=new ODatabaseDocumentTx(db.getURL());
  rebuildIndexesThread=new Runnable(){
    @Override public void run(){
      ODatabaseRecordThreadLocal.INSTANCE.set(newDb);
      try {
        newDb.getStorage().getDataSegmentIdByName(OMetadata.DATASEGMENT_INDEX_NAME);
        newDb.getStorage().dropDataSegment(OMetadata.DATASEGMENT_INDEX_NAME);
        newDb.getStorage().dropCluster(OMetadata.CLUSTER_INDEX_NAME,false);
        newDb.addDataSegment(OMetadata.DATASEGMENT_INDEX_NAME,null);
        newDb.getStorage().addCluster(OClusterLocal.TYPE,OMetadata.CLUSTER_INDEX_NAME,null,OMetadata.DATASEGMENT_INDEX_NAME,true);
      }
 catch (      IllegalArgumentException ex) {
        OLogManager.instance().info(this,"Creating 'index' data-segment to store all the index content...");
        newDb.addDataSegment(OMetadata.DATASEGMENT_INDEX_NAME,null);
        final OCluster indexCluster=newDb.getStorage().getClusterById(newDb.getStorage().getClusterIdByName(OMetadata.CLUSTER_INDEX_NAME));
        try {
          indexCluster.set(ATTRIBUTES.DATASEGMENT,OMetadata.DATASEGMENT_INDEX_NAME);
          OLogManager.instance().info(this,"Data-segment 'index' create correctly. Indexes will store content into this data-segment");
        }
 catch (        IOException e) {
          OLogManager.instance().error(this,"Error changing data segment for cluster 'index'",e);
        }
      }
      final Collection<? extends OIndex<?>> indexList=getIndexes();
      final List<OIndex<?>> automaticIndexes=new ArrayList<OIndex<?>>();
      for (      OIndex<?> idx : indexList)       if (idx.isAutomatic())       automaticIndexes.add(idx);
      OLogManager.instance().info(this,"Start rebuilding of %d automatic indexes in background. During this phase queries could be slower",automaticIndexes.size());
      int i=1;
      int ok=0;
      int errors=0;
      for (      final OIndex<?> idx : automaticIndexes)       try {
        OLogManager.instance().info(idx,"- rebuilding index %d/%d: '%s'...",i,automaticIndexes.size(),idx.getName());
        idx.rebuild(new OProgressListener(){
          long startTime;
          long lastDump;
          long lastCounter=0;
          @Override public void onBegin(          final Object iTask,          final long iTotal){
            startTime=System.currentTimeMillis();
            lastDump=startTime;
          }
          @Override public boolean onProgress(          final Object iTask,          final long iCounter,          final float iPercent){
            final long now=System.currentTimeMillis();
            if (now - lastDump > 10000) {
              OLogManager.instance().info(idx,"--> %3.2f%% progress, %,d indexed so far (%,d items/sec)",iPercent,iCounter,((iCounter - lastCounter) / 10));
              lastDump=now;
              lastCounter=iCounter;
            }
            return true;
          }
          @Override public void onCompletition(          final Object iTask,          final boolean iSucceed){
            OLogManager.instance().info(idx,"--> ok, indexed %,d items in %,d ms",idx.getSize(),(System.currentTimeMillis() - startTime));
          }
        }
);
        ok++;
      }
 catch (      Throwable e) {
        OLogManager.instance().info(idx,"--> error caught (" + e + "). Continue with remaining indexes...");
        errors++;
      }
 finally {
        ++i;
      }
      OLogManager.instance().info(this,"%d indexes rebuilt successfully, %d errors",ok,errors);
      rebuildIndexesThread=null;
    }
  }
;
  newDb.setProperty(ODatabase.OPTIONS.SECURITY.toString(),Boolean.FALSE);
  newDb.open("admin","nopass");
  new Thread(rebuildIndexesThread).start();
  ODatabaseRecordThreadLocal.INSTANCE.set(db);
}
