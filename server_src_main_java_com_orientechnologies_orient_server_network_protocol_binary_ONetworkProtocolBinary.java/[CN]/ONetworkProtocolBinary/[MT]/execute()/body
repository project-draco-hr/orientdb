{
  commandType=-1;
  data.commandInfo="Listening";
  data.commandDetail="-";
  int clientTxId=0;
  try {
    commandType=channel.readByte();
    clientTxId=channel.readInt();
    ++data.totalRequests;
    data.lastCommandReceived=System.currentTimeMillis();
switch (commandType) {
case OChannelBinaryProtocol.CONNECT:
{
        data.commandInfo="Connect";
        user=channel.readString();
        passwd=channel.readString();
        sendOk(clientTxId);
        channel.writeInt(connection.id);
        break;
      }
case OChannelBinaryProtocol.DB_OPEN:
{
      data.commandInfo="Open database";
      String dbURL=channel.readString();
      String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
      user=channel.readString();
      passwd=channel.readString();
      connection.database=(ODatabaseDocumentTx)OServerMain.server().getMemoryDatabases().get(dbName);
      if (connection.database == null)       connection.database=new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));
      if (connection.database.isClosed())       if (connection.database.getStorage() instanceof OStorageMemory)       connection.database.create();
 else       connection.database.open(user,passwd);
      underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
      if (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user,passwd)) {
        sendError(clientTxId,new OSecurityAccessException(connection.database.getName(),"Access denied to database '" + connection.database.getName() + "' for user: "+ user));
      }
 else {
        sendOk(clientTxId);
        channel.writeInt(connection.id);
        channel.writeInt(connection.database.getClusterNames().size());
        for (        OCluster c : (connection.database.getStorage()).getClusters()) {
          if (c != null) {
            channel.writeString(c.getName());
            channel.writeInt(c.getId());
            channel.writeString(c.getType());
          }
        }
      }
      break;
    }
case OChannelBinaryProtocol.DB_CREATE:
{
    data.commandInfo="Create database";
    String dbName=channel.readString();
    String storageMode=channel.readString();
    final String path;
    final String realPath;
    if (storageMode.equals(OEngineLocal.NAME)) {
      if (OServerMain.server().existsStoragePath(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":${ORIENTDB_HOME}/databases/" + dbName+ "/"+ dbName;
      realPath=OSystemVariableResolver.resolveSystemVariables(path);
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      if (OServerMain.server().getMemoryDatabases().containsKey(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":" + dbName;
      realPath=path;
    }
 else     throw new IllegalArgumentException("Can't create databse: storage mode '" + storageMode + "' is not supported.");
    connection.database=new ODatabaseDocumentTx(realPath);
    connection.database.create();
    if (storageMode.equals(OEngineLocal.NAME)) {
      connection.database.close();
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      OServerMain.server().getMemoryDatabases().put(dbName,connection.database);
    }
    underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
    sendOk(clientTxId);
    break;
  }
case OChannelBinaryProtocol.DB_CLOSE:
data.commandInfo="Close Database";
connection.database.close();
break;
case OChannelBinaryProtocol.DB_EXIST:
{
data.commandInfo="Exists database";
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk(clientTxId);
break;
}
case OChannelBinaryProtocol.DATACLUSTER_COUNT:
{
data.commandInfo="Count cluster elements";
int[] clusterIds=new int[channel.readShort()];
for (int i=0; i < clusterIds.length; ++i) clusterIds[i]=channel.readShort();
long count=connection.database.countClusterElements(clusterIds);
sendOk(clientTxId);
channel.writeLong(count);
break;
}
case OChannelBinaryProtocol.DATACLUSTER_DATARANGE:
{
data.commandInfo="Get the begin/end range of data in cluster";
long[] pos=connection.database.getStorage().getClusterDataRange(channel.readShort());
sendOk(clientTxId);
channel.writeLong(pos[0]);
channel.writeLong(pos[1]);
break;
}
case OChannelBinaryProtocol.DATACLUSTER_ADD:
{
data.commandInfo="Add cluster";
final String type=channel.readString();
final String name=channel.readString();
final int num;
OStorage.CLUSTER_TYPE t=OStorage.CLUSTER_TYPE.valueOf(type);
switch (t) {
case PHYSICAL:
num=connection.database.addPhysicalCluster(name,channel.readString(),channel.readInt());
break;
case MEMORY:
num=connection.database.getStorage().addCluster(name,t);
break;
case LOGICAL:
num=connection.database.addLogicalCluster(name,channel.readInt());
break;
default :
throw new IllegalArgumentException("Cluster type " + type + " is not supported");
}
sendOk(clientTxId);
channel.writeShort((short)num);
break;
}
case OChannelBinaryProtocol.DATACLUSTER_REMOVE:
{
data.commandInfo="remove cluster";
final int id=channel.readShort();
boolean result=connection.database.getStorage().removeCluster(id);
sendOk(clientTxId);
channel.writeByte((byte)(result ? '1' : '0'));
break;
}
case OChannelBinaryProtocol.RECORD_LOAD:
{
data.commandInfo="Load record";
final short clusterId=channel.readShort();
final long clusterPosition=channel.readLong();
final String fetchPlanString=channel.readString();
final ORawBuffer buffer=underlyingDatabase.read(clusterId,clusterPosition,null);
sendOk(clientTxId);
if (buffer != null) {
channel.writeByte((byte)1);
channel.writeBytes(buffer.buffer);
channel.writeInt(buffer.version);
channel.writeByte(buffer.recordType);
if (fetchPlanString.length() > 0) {
final ORecordInternal<?> record=ORecordFactory.newInstance(buffer.recordType);
record.fill(connection.database,clusterId,clusterPosition,buffer.version);
record.fromStream(buffer.buffer);
if (record instanceof ODocument) {
final Map<String,Integer> fetchPlan=OFetchHelper.buildFetchPlan(fetchPlanString);
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
OFetchHelper.fetch((ODocument)record,record,fetchPlan,null,0,-1,new OFetchListener(){
public int size(){
return recordsToSend.size();
}
public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
}
}
);
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
}
channel.writeByte((byte)0);
}
 else channel.writeByte((byte)0);
}
 else channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.RECORD_CREATE:
data.commandInfo="Create record";
final long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1,channel.readByte());
sendOk(clientTxId);
channel.writeLong(location);
break;
case OChannelBinaryProtocol.RECORD_UPDATE:
data.commandInfo="Update record";
final int clusterId=channel.readShort();
final long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt(),channel.readByte());
if (connection.database.getMetadata().getSchema().getDocument().getIdentity().getClusterId() == clusterId && connection.database.getMetadata().getSchema().getDocument().getIdentity().getClusterPosition() == position) connection.database.getMetadata().loadSchema();
 else if (((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterId() == clusterId && ((ODictionaryLocal<?>)connection.database.getDictionary()).getTree().getRecord().getIdentity().getClusterPosition() == position) ((ODictionaryLocal<?>)connection.database.getDictionary()).load();
sendOk(clientTxId);
channel.writeInt((int)newVersion);
break;
case OChannelBinaryProtocol.RECORD_DELETE:
data.commandInfo="Delete record";
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk(clientTxId);
channel.writeByte((byte)'1');
break;
case OChannelBinaryProtocol.COUNT:
{
data.commandInfo="Count cluster records";
final String clusterName=channel.readString();
final long size=connection.database.countClusterElements(clusterName);
sendOk(clientTxId);
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.COMMAND:
{
data.commandInfo="Execute remote command";
final boolean asynch=channel.readByte() == 'a';
final OCommandRequestText command=(OCommandRequestText)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
final OQuery<?> query=(OQuery<?>)(command instanceof OQuery<?> ? command : null);
data.commandDetail=command.getText();
if (asynch) {
final StringBuilder empty=new StringBuilder();
final Set<ODocument> recordsToSend=new HashSet<ODocument>();
final int txId=clientTxId;
final Map<String,Integer> fetchPlan=query != null ? OFetchHelper.buildFetchPlan(query.getFetchPlan()) : null;
command.setResultListener(new OCommandResultListener(){
public boolean result(final Object iRecord){
if (empty.length() == 0) try {
sendOk(txId);
empty.append("-");
}
 catch (IOException e1) {
}
try {
channel.writeByte((byte)1);
writeRecord((ORecordInternal<?>)iRecord);
channel.flush();
if (fetchPlan != null && iRecord instanceof ODocument) {
OFetchHelper.fetch((ODocument)iRecord,iRecord,fetchPlan,null,0,-1,new OFetchListener(){
public int size(){
return recordsToSend.size();
}
public Object fetchLinked(final ODocument iRoot,final Object iUserObject,final String iFieldName,final Object iLinked){
if (iLinked instanceof ODocument) return recordsToSend.add((ODocument)iLinked) ? iLinked : null;
 else return recordsToSend.addAll((Collection<? extends ODocument>)iLinked) ? iLinked : null;
}
}
);
}
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
((OCommandRequestInternal)connection.database.command(command)).execute();
if (empty.length() == 0) try {
sendOk(clientTxId);
}
 catch (IOException e1) {
}
for (ODocument doc : recordsToSend) {
channel.writeByte((byte)2);
writeRecord(doc);
}
channel.writeByte((byte)0);
}
 else {
final Object result=((OCommandRequestInternal)connection.database.command(command)).execute();
sendOk(clientTxId);
if (result == null) {
channel.writeByte((byte)'n');
channel.writeBytes(null);
}
 else if (result instanceof ORecord<?>) {
channel.writeByte((byte)'r');
writeRecord((ORecordInternal<?>)result);
}
 else {
channel.writeByte((byte)'a');
channel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(result));
}
}
break;
}
case OChannelBinaryProtocol.DICTIONARY_LOOKUP:
{
data.commandInfo="Dictionary lookup";
final String key=channel.readString();
final ORecordAbstract<?> value=connection.database.getDictionary().get(key);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(clientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_PUT:
{
data.commandInfo="Dictionary put";
String key=channel.readString();
ORecordInternal<?> value=ORecordFactory.newInstance(channel.readByte());
final ORecordId rid=new ORecordId(channel.readShort(),channel.readLong());
value.setIdentity(rid.clusterId,rid.clusterPosition);
value.setDatabase(connection.database);
value=connection.database.getDictionary().putRecord(key,value);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(clientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_REMOVE:
{
data.commandInfo="Dictionary remove";
final String key=channel.readString();
final ORecordInternal<?> value=connection.database.getDictionary().remove(key);
if (value != null) ((ODatabaseRecordTx<ORecordInternal<?>>)connection.database.getUnderlying()).load(value);
sendOk(clientTxId);
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_SIZE:
{
data.commandInfo="Dictionary size";
sendOk(clientTxId);
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.DICTIONARY_KEYS:
{
data.commandInfo="Dictionary keys";
sendOk(clientTxId);
channel.writeCollectionString(connection.database.getDictionary().keySet());
break;
}
case OChannelBinaryProtocol.TX_COMMIT:
data.commandInfo="Transaction commit";
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),new OTransactionOptimisticProxy((ODatabaseRecordTx<OTransactionRecordProxy>)connection.database.getUnderlying(),channel));
sendOk(clientTxId);
break;
default :
data.commandInfo="Command not supported";
OLogManager.instance().error(this,"Request not supported. Code: " + commandType);
channel.clearInput();
sendError(clientTxId,null);
}
}
 catch (EOFException eof) {
shutdown();
}
catch (SocketException e) {
shutdown();
}
catch (OException e) {
sendError(clientTxId,e);
}
catch (Throwable t) {
OLogManager.instance().error(this,"Error on executing request",t);
sendError(clientTxId,t);
}
 finally {
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
OSerializationThreadLocal.INSTANCE.get().clear();
data.lastCommandExecutionTime=System.currentTimeMillis() - data.lastCommandReceived;
data.totalCommandExecutionTime+=data.lastCommandExecutionTime;
data.lastCommandInfo=data.commandInfo;
data.lastCommandDetail=data.commandDetail;
}
}
