{
  final int[] clusterIds=iTarget.getClusterIds();
  final List<Integer> clusterList=new ArrayList<Integer>();
  for (int i=0; i < clusterIds.length; ++i)   if (db.getStorage().getClusterById(clusterIds[i]).getEntries() > 0)   clusterList.add(clusterIds[i]);
  final int threadNumber=clusterList.size();
  OLogManager.instance().debug(this,"Executing parallel query with strategy one thread per cluster. clusterIds=%d, threads=%d",clusterIds.length,threadNumber);
  final Thread[] threads=new Thread[threadNumber];
  final boolean[] results=new boolean[threadNumber];
  final RuntimeException[] exceptions=new RuntimeException[threadNumber];
  for (int i=0; i < threadNumber; ++i) {
    final int current=i;
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        exceptions[current]=null;
        results[current]=true;
        final ODatabaseDocumentTx localDatabase=db.copy();
        final OCommandContext threadContext=context.copy();
        try {
          db.getMetadata().getSchema().makeSnapshot();
          scanClusterWithIterator(localDatabase,threadContext,current,clusterList,results);
        }
 catch (        RuntimeException t) {
          exceptions[current]=t;
        }
 finally {
          mergeContext(threadContext);
          localDatabase.close();
        }
      }
    }
,"OrientDB SELECT " + getDatabase().getName() + "-"+ i);
    threads[i].start();
  }
  for (int i=0; i < threadNumber; ++i) {
    try {
      threads[i].join();
    }
 catch (    InterruptedException e) {
    }
  }
  for (int i=0; i < threadNumber; ++i)   if (exceptions[i] != null)   throw exceptions[i];
  for (int i=0; i < threadNumber; ++i) {
    if (!results[i])     return false;
  }
  return true;
}
