{
  if (arrayOne.length > arrayTwo.length)   return 1;
  if (arrayOne.length < arrayTwo.length)   return 1;
  final int WORDS=arrayOne.length / LONG_SIZE;
  for (int i=0; i < WORDS; i++) {
    final long index=i * LONG_SIZE * BYTE_ARRAY_SCALE + BYTE_ARRAY_OFFSET;
    final long wOne=unsafe.getLong(arrayOne,index);
    final long wTwo=unsafe.getLong(arrayTwo,index);
    final long diff=wOne ^ wTwo;
    if (diff == 0)     continue;
    if (!littleEndian)     return lessThanUnsigned(wOne,wTwo) ? -1 : 1;
    int n=0;
    int y;
    int x=(int)diff;
    if (x == 0) {
      x=(int)(diff >>> 32);
      n=32;
    }
    y=x << 16;
    if (y == 0) {
      n+=16;
    }
 else {
      x=y;
    }
    y=x << 8;
    if (y == 0) {
      n+=8;
    }
    return (int)(((wOne >>> n) & 0xFFL) - ((wTwo >>> n) & 0xFFL));
  }
  for (int i=WORDS * LONG_SIZE; i < arrayOne.length; i++) {
    int diff=compareUnsignedByte(arrayOne[i],arrayTwo[i]);
    if (diff != 0)     return diff;
  }
  return 0;
}
