{
  if (!(INDEX_TYPE.DICTIONARY.equals(iType) || INDEX_TYPE.FULLTEXT.equals(iType) || INDEX_TYPE.NOTUNIQUE.equals(iType)|| INDEX_TYPE.UNIQUE.equals(iType)))   throw new OIndexException("Index of this type (" + iType + ") cannot be used in class indexes.");
  if (fields.length == 0)   throw new OIndexException("List of fields to index cannot be empty.");
  if (fields.length > 1 && INDEX_TYPE.FULLTEXT.equals(iType))   throw new OIndexException(INDEX_TYPE.FULLTEXT + " indexes cannot be used as composite ones.");
  final Set<String> existingFieldNames=properties.keySet();
  final List<String> fieldsToIndex=new LinkedList<String>();
  for (  final String fieldToIndex : fields) {
    final String fieldName=extractFieldName(fieldToIndex);
    if (!existingFieldNames.contains(fieldName.toLowerCase()))     throw new OIndexException("Index with name : '" + iName + "' cannot be created on class : '"+ name+ "' because field: '"+ fieldName+ "' is absent in class definition.");
    fieldsToIndex.add(fieldName);
  }
  final OIndexDefinition indexDefinition;
  if (fieldsToIndex.size() == 1) {
    indexDefinition=createSingleFieldIndexDefinition(fields[0]);
  }
 else {
    indexDefinition=createMultipleFieldIndexDefinition(fieldsToIndex);
  }
  final OIndex<?> index=getDatabase().getMetadata().getIndexManager().createIndex(iName,iType.toString(),indexDefinition,clusterIds,iProgressListener);
  return index;
}
