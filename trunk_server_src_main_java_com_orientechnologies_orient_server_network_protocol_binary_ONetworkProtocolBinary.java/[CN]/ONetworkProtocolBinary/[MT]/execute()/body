{
  try {
    short type=channel.readByte();
switch (type) {
case OChannelBinaryProtocol.CONNECT:
{
        user=channel.readString();
        passwd=channel.readString();
        sendOk();
        channel.writeString(connection.id);
        break;
      }
case OChannelBinaryProtocol.DB_OPEN:
{
      String dbURL=channel.readString();
      String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
      user=channel.readString();
      passwd=channel.readString();
      connection.database=new ODatabaseVObjectTx("local:" + OServerMain.server().getStoragePath(dbName));
      if (connection.database.isClosed())       connection.database.open(user,passwd);
      underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
      if (!loadUserFromSchema(user,passwd)) {
        sendError(new OSecurityAccessException("Access denied to database '" + connection.database.getName() + "' for user: "+ user));
      }
 else {
        sendOk();
        channel.writeString(connection.id);
        channel.writeInt(connection.database.getClusterNames().size());
        for (        OCluster c : ((OStorageLocal)connection.database.getStorage()).getClusters()) {
          channel.writeString(c.getName());
          channel.writeInt(c.getId());
        }
      }
      break;
    }
case OChannelBinaryProtocol.DB_CREATE:
{
    String dbURL=channel.readString();
    String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
    String storageMode=channel.readString();
    connection.database=new ODatabaseVObjectTx("local:" + OServerMain.server().getStoragePath(dbName));
    connection.database.create(storageMode);
    underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
    sendOk();
    break;
  }
case OChannelBinaryProtocol.DB_CLOSE:
break;
case OChannelBinaryProtocol.DB_EXIST:
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk();
break;
case OChannelBinaryProtocol.CLUSTER_COUNT:
int[] ids=new int[channel.readShort()];
for (int i=0; i < ids.length; ++i) ids[i]=channel.readShort();
long count=connection.database.countClusterElements(ids);
sendOk();
channel.writeLong(count);
break;
case OChannelBinaryProtocol.CLUSTER_ADD:
int num=connection.database.addPhysicalCluster(channel.readString(),channel.readString(),channel.readInt());
sendOk();
channel.writeShort((short)num);
break;
case OChannelBinaryProtocol.RECORD_LOAD:
Object[] record=underlyingDatabase.read(channel.readShort(),channel.readLong());
sendOk();
channel.writeBytes((byte[])record[0]);
channel.writeInt((Integer)record[1]);
break;
case OChannelBinaryProtocol.RECORD_CREATE:
long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1);
sendOk();
channel.writeLong(location);
break;
case OChannelBinaryProtocol.RECORD_UPDATE:
int clusterId=channel.readShort();
long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt());
if (clusterId == connection.database.getMetadata().getSchemaClusterId()) if (position == OSchema.CLASSES_RECORD_NUM) connection.database.getMetadata().loadSchema();
 else if (position == OSecurity.SECURITY_RECORD_NUM) connection.database.getMetadata().loadSecurity();
sendOk();
channel.writeInt((int)(newVersion * -1 + 2));
break;
case OChannelBinaryProtocol.RECORD_DELETE:
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk();
break;
case OChannelBinaryProtocol.COUNT:
{
String clusterName=channel.readString();
long size=connection.database.countClusterElements(clusterName);
sendOk();
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.QUERY:
{
final int limit=channel.readInt();
OAsynchQuery<ORecordInternal<?>> query=(OAsynchQuery<ORecordInternal<?>>)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
final StringBuilder empty=new StringBuilder();
query.setResultListener(new OAsynchQueryResultListener<ORecordInternal<?>>(){
private int items=0;
public boolean result(ORecordInternal<?> iRecord){
if (items == 0) try {
sendOk();
empty.append("-");
}
 catch (IOException e1) {
}
if (items > limit) return false;
try {
channel.writeByte((byte)1);
items++;
writeRecord(iRecord);
channel.flush();
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
connection.database.query((OQuery<ORecordVObject>)query).execute(limit);
if (empty.length() == 0) try {
sendOk();
}
 catch (IOException e1) {
}
channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.QUERY_FIRST:
{
String queryText=channel.readString();
OSQLSynchQuery<ORecordVObject> query=new OSQLSynchQuery<ORecordVObject>(queryText);
query.setRecord(new ORecordVObject());
query.setDatabase(connection.database);
ORecordInternal<?> result=connection.database.query(query).executeFirst();
sendOk();
writeRecord(result);
break;
}
case OChannelBinaryProtocol.DICTIONARY_LOOKUP:
{
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().get(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_PUT:
{
String key=channel.readString();
ORecordVObject value=new ORecordVObject(connection.database,new ORecordId(channel.readString()));
value=connection.database.getDictionary().put(key,value);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_REMOVE:
{
String key=channel.readString();
ORecordInternal<?> value=new ORecordFlat(connection.database,new ORecordId(channel.readString()));
value=connection.database.getDictionary().remove(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_SIZE:
{
sendOk();
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.TX_COMMIT:
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),new OTransactionOptimisticProxy((ODatabaseRecordTx)connection.database.getUnderlying(),channel));
sendOk();
break;
default :
OLogManager.instance().error(this,"Request not supported. Code: " + type);
channel.clearInput();
sendError(null);
}
}
 catch (EOFException eof) {
shutdown();
}
catch (SocketException e) {
shutdown();
}
catch (Throwable t) {
OLogManager.instance().error(this,"Error on executing request",t);
sendError(t);
}
 finally {
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
}
OSerializationThreadLocal.INSTANCE.get().clear();
}
