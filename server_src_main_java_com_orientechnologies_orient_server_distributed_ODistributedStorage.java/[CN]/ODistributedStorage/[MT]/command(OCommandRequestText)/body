{
  List<String> servers=(List<String>)iCommand.getContext().getVariable("servers");
  if (servers == null) {
    servers=new ArrayList<String>();
    iCommand.getContext().setVariable("servers",servers);
  }
  final String localNodeName=dManager.getLocalNodeName();
  servers.add(localNodeName);
  if (OScenarioThreadLocal.INSTANCE.get() == RUN_MODE.RUNNING_DISTRIBUTED)   return wrapped.command(iCommand);
  final ODistributedConfiguration dbCfg=dManager.getDatabaseConfiguration(getName());
  if (!dbCfg.isReplicationActive(null,localNodeName))   return wrapped.command(iCommand);
  final OCommandExecutor executor=OCommandManager.instance().getExecutor(iCommand);
  executor.setProgressListener(iCommand.getProgressListener());
  executor.parse(iCommand);
  final OCommandExecutor exec=executor instanceof OCommandExecutorSQLDelegate ? ((OCommandExecutorSQLDelegate)executor).getDelegate() : executor;
  if (!exec.isIdempotent())   checkNodeIsMaster(localNodeName,dbCfg);
  try {
    final OAbstractCommandTask task=iCommand instanceof OCommandScript ? new OScriptTask(iCommand) : new OSQLCommandTask(iCommand);
    Object result=null;
    OCommandDistributedReplicateRequest.DISTRIBUTED_EXECUTION_MODE executionMode=OCommandDistributedReplicateRequest.DISTRIBUTED_EXECUTION_MODE.LOCAL;
    OCommandDistributedReplicateRequest.DISTRIBUTED_RESULT_MGMT resultMgmt=OCommandDistributedReplicateRequest.DISTRIBUTED_RESULT_MGMT.CHECK_FOR_EQUALS;
    if (OScenarioThreadLocal.INSTANCE.get() != RUN_MODE.RUNNING_DISTRIBUTED) {
      if (exec instanceof OCommandDistributedReplicateRequest) {
        executionMode=((OCommandDistributedReplicateRequest)exec).getDistributedExecutionMode();
        resultMgmt=((OCommandDistributedReplicateRequest)exec).getDistributedResultManagement();
      }
    }
switch (executionMode) {
case LOCAL:
      return wrapped.command(iCommand);
case REPLICATE:
{
      if (exec.isLocalExecution())       return wrapped.command(iCommand);
      final Collection<String> involvedClusters=exec.getInvolvedClusters();
      final Collection<String> nodes;
      if (resultMgmt == OCommandDistributedReplicateRequest.DISTRIBUTED_RESULT_MGMT.MERGE) {
        nodes=dbCfg.getOneServerPerCluster(involvedClusters,localNodeName);
        task.setResultStrategy(OAbstractRemoteTask.RESULT_STRATEGY.UNION);
      }
 else {
        nodes=dbCfg.getServers(involvedClusters);
        task.setResultStrategy(OAbstractRemoteTask.RESULT_STRATEGY.ANY);
      }
      if (iCommand instanceof ODistributedCommand)       nodes.removeAll(((ODistributedCommand)iCommand).nodesToExclude());
      if (nodes.isEmpty())       return null;
      if (executeLocally(localNodeName,dbCfg,exec,involvedClusters,nodes))       return wrapped.command(iCommand);
      result=dManager.sendRequest(getName(),involvedClusters,nodes,task,EXECUTION_MODE.RESPONSE);
      if (exec.involveSchema())       dManager.propagateSchemaChanges(ODatabaseRecordThreadLocal.INSTANCE.get());
      if (resultMgmt == OCommandDistributedReplicateRequest.DISTRIBUTED_RESULT_MGMT.MERGE && result instanceof Map) {
        if (executor instanceof OCommandExecutorSQLDelegate && ((OCommandExecutorSQLDelegate)executor).getDelegate() instanceof OCommandExecutorSQLSelect) {
          final OCommandExecutorSQLSelect cmd=(OCommandExecutorSQLSelect)((OCommandExecutorSQLDelegate)executor).getDelegate();
          if (((Map<String,Object>)result).size() == 1)           result=((Map<String,Object>)result).values().iterator().next();
 else {
            if (cmd.isAnyFunctionAggregates()) {
              final Map<String,Object> proj=cmd.getProjections();
              final List<Object> list=new ArrayList<Object>();
              final ODocument doc=new ODocument();
              list.add(doc);
              boolean hasNonAggregates=false;
              for (              Map.Entry<String,Object> p : proj.entrySet()) {
                if (!(p.getValue() instanceof OSQLFunctionRuntime)) {
                  hasNonAggregates=true;
                  break;
                }
              }
              if (hasNonAggregates) {
                for (                Map.Entry<String,Object> entry : ((Map<String,Object>)result).entrySet()) {
                  final List<Object> resultSet=(List<Object>)entry.getValue();
                  for (                  Object r : resultSet) {
                    if (r instanceof ODocument) {
                      final ODocument d=(ODocument)r;
                      for (                      Map.Entry<String,Object> p : proj.entrySet()) {
                        if (!(p.getValue() instanceof OSQLFunctionRuntime))                         doc.field(p.getKey(),p.getValue());
                      }
                    }
                  }
                }
              }
              final List<Object> toMerge=new ArrayList<Object>();
              for (              Map.Entry<String,Object> p : proj.entrySet()) {
                if (p.getValue() instanceof OSQLFunctionRuntime) {
                  final OSQLFunctionRuntime f=(OSQLFunctionRuntime)p.getValue();
                  toMerge.clear();
                  for (                  Map.Entry<String,Object> entry : ((Map<String,Object>)result).entrySet()) {
                    final List<Object> resultSet=(List<Object>)entry.getValue();
                    for (                    Object r : resultSet) {
                      if (r instanceof ODocument) {
                        final ODocument d=(ODocument)r;
                        toMerge.add(d.rawField(p.getKey()));
                      }
                    }
                  }
                  doc.field(p.getKey(),f.getFunction().mergeDistributedResult(toMerge));
                }
              }
              result=list;
            }
 else {
              final Set<Object> set=new HashSet<Object>();
              for (              Map.Entry<String,Object> entry : ((Map<String,Object>)result).entrySet()) {
                final Object nodeResult=entry.getValue();
                if (nodeResult instanceof Collection)                 set.addAll((Collection<?>)nodeResult);
 else                 if (nodeResult instanceof Exception)                 throw (Exception)nodeResult;
              }
              result=new ArrayList<Object>(set);
            }
          }
        }
      }
      break;
    }
}
if (result instanceof ONeedRetryException) throw (ONeedRetryException)result;
 else if (result instanceof Throwable) throw new ODistributedException("Error on execution distributed COMMAND",(Throwable)result);
return result;
}
 catch (ONeedRetryException e) {
throw e;
}
catch (Exception e) {
handleDistributedException("Cannot route COMMAND operation to the distributed node",e);
return null;
}
}
