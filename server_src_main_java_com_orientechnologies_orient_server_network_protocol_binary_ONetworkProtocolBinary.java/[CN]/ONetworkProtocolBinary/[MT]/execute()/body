{
  try {
    short type=channel.readByte();
switch (type) {
case OChannelBinaryProtocol.CONNECT:
{
        user=channel.readString();
        passwd=channel.readString();
        sendOk();
        channel.writeString(connection.id);
        break;
      }
case OChannelBinaryProtocol.DB_OPEN:
{
      String dbURL=channel.readString();
      String dbName=dbURL.substring(dbURL.lastIndexOf(":") + 1);
      user=channel.readString();
      passwd=channel.readString();
      connection.database=(ODatabaseDocumentTx)OServerMain.server().getMemoryDatabases().get(dbName);
      if (connection.database == null)       connection.database=new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));
      if (connection.database.isClosed())       if (connection.database.getStorage() instanceof OStorageMemory)       connection.database.create();
 else       connection.database.open(user,passwd);
      underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
      if (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user,passwd)) {
        sendError(new OSecurityAccessException("Access denied to database '" + connection.database.getName() + "' for user: "+ user));
      }
 else {
        sendOk();
        channel.writeString(connection.id);
        channel.writeInt(connection.database.getClusterNames().size());
        for (        OCluster c : ((OStorage)connection.database.getStorage()).getClusters()) {
          channel.writeString(c.getName());
          channel.writeInt(c.getId());
        }
      }
      break;
    }
case OChannelBinaryProtocol.DB_CREATE:
{
    String dbURL=channel.readString();
    String dbName=dbURL.substring(channel.readString().lastIndexOf(":") + 1);
    String storageMode=channel.readString();
    final String path;
    final String realPath;
    if (storageMode.equals(OEngineLocal.NAME)) {
      if (OServerMain.server().existsStoragePath(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":${ORIENT_HOME}/databases/" + dbName+ "/"+ dbName;
      realPath=OSystemVariableResolver.resolveSystemVariables(path);
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      if (OServerMain.server().getMemoryDatabases().containsKey(dbName))       throw new IllegalArgumentException("Database '" + dbName + "' already exists.");
      path=storageMode + ":" + dbName;
      realPath=path;
    }
 else     throw new IllegalArgumentException("Can't create databse: storage mode '" + storageMode + "' is not supported.");
    connection.database=new ODatabaseDocumentTx(realPath);
    connection.database.create();
    if (storageMode.equals(OEngineLocal.NAME)) {
      connection.database.close();
      OServerMain.server().getConfiguration().storages.add(new OServerStorageConfiguration(dbName,path));
      OServerMain.server().saveConfiguration();
    }
 else     if (storageMode.equals(OEngineMemory.NAME)) {
      OServerMain.server().getMemoryDatabases().put(dbName,connection.database);
    }
    underlyingDatabase=((ODatabaseRaw)((ODatabaseComplex<?>)connection.database.getUnderlying()).getUnderlying());
    sendOk();
    break;
  }
case OChannelBinaryProtocol.DB_CLOSE:
break;
case OChannelBinaryProtocol.DB_EXIST:
channel.writeByte((byte)(connection.database.exists() ? 1 : 0));
sendOk();
break;
case OChannelBinaryProtocol.CLUSTER_COUNT:
int[] ids=new int[channel.readShort()];
for (int i=0; i < ids.length; ++i) ids[i]=channel.readShort();
long count=connection.database.countClusterElements(ids);
sendOk();
channel.writeLong(count);
break;
case OChannelBinaryProtocol.CLUSTER_ADD:
int num=connection.database.addPhysicalCluster(channel.readString(),channel.readString(),channel.readInt());
sendOk();
channel.writeShort((short)num);
break;
case OChannelBinaryProtocol.RECORD_LOAD:
ORawBuffer record=underlyingDatabase.read(channel.readShort(),channel.readLong());
sendOk();
if (record != null) {
channel.writeByte((byte)1);
channel.writeBytes(record.buffer);
channel.writeInt(record.version);
channel.writeByte(record.recordType);
}
 else channel.writeByte((byte)0);
break;
case OChannelBinaryProtocol.RECORD_CREATE:
long location=underlyingDatabase.save(channel.readShort(),ORID.CLUSTER_POS_INVALID,channel.readBytes(),-1,channel.readByte());
sendOk();
channel.writeLong(location);
break;
case OChannelBinaryProtocol.RECORD_UPDATE:
int clusterId=channel.readShort();
long position=channel.readLong();
long newVersion=underlyingDatabase.save(clusterId,position,channel.readBytes(),channel.readInt(),channel.readByte());
if (clusterId == connection.database.getMetadata().getSchemaClusterId()) if (position == OSchema.CLASSES_RECORD_NUM) connection.database.getMetadata().loadSchema();
 else if (position == OSecurity.SECURITY_RECORD_NUM) connection.database.getMetadata().loadSecurity();
sendOk();
channel.writeInt((int)(newVersion * -1 + 2));
break;
case OChannelBinaryProtocol.RECORD_DELETE:
underlyingDatabase.delete(channel.readShort(),channel.readLong(),channel.readInt());
sendOk();
break;
case OChannelBinaryProtocol.COUNT:
{
String clusterName=channel.readString();
long size=connection.database.countClusterElements(clusterName);
sendOk();
channel.writeLong(size);
break;
}
case OChannelBinaryProtocol.QUERY:
{
final int limit=channel.readInt();
OAsynchQuery<ORecordInternal<?>> query=(OAsynchQuery<ORecordInternal<?>>)OStreamSerializerAnyStreamable.INSTANCE.fromStream(channel.readBytes());
final StringBuilder empty=new StringBuilder();
query.setResultListener(new OAsynchQueryResultListener<ORecordInternal<?>>(){
private int items=0;
public boolean result(ORecordInternal<?> iRecord){
if (items == 0) try {
sendOk();
empty.append("-");
}
 catch (IOException e1) {
}
if (items > limit) return false;
try {
channel.writeByte((byte)1);
items++;
writeRecord(iRecord);
channel.flush();
}
 catch (IOException e) {
return false;
}
return true;
}
}
);
connection.database.query((OQuery<ODocument>)query).execute(limit);
if (empty.length() == 0) try {
sendOk();
}
 catch (IOException e1) {
}
channel.writeByte((byte)0);
break;
}
case OChannelBinaryProtocol.QUERY_FIRST:
{
String queryText=channel.readString();
OSQLSynchQuery<ODocument> query=new OSQLSynchQuery<ODocument>(queryText);
query.setRecord(new ODocument());
query.setDatabase(connection.database);
ORecordInternal<?> result=connection.database.query(query).executeFirst();
sendOk();
writeRecord(result);
break;
}
case OChannelBinaryProtocol.DICTIONARY_LOOKUP:
{
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().get(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_PUT:
{
String key=channel.readString();
ODocument value=new ODocument(connection.database,new ORecordId(channel.readString()));
value=connection.database.getDictionary().put(key,value);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_REMOVE:
{
String key=channel.readString();
ORecordInternal<?> value=connection.database.getDictionary().remove(key);
sendOk();
writeRecord(value);
break;
}
case OChannelBinaryProtocol.DICTIONARY_SIZE:
{
sendOk();
channel.writeInt(connection.database.getDictionary().size());
break;
}
case OChannelBinaryProtocol.DICTIONARY_KEYS:
{
sendOk();
channel.writeCollectionString(connection.database.getDictionary().keySet());
break;
}
case OChannelBinaryProtocol.TX_COMMIT:
((OStorageLocal)connection.database.getStorage()).commit(connection.database.getId(),new OTransactionOptimisticProxy((ODatabaseRecordTx)connection.database.getUnderlying(),channel));
sendOk();
break;
default :
OLogManager.instance().error(this,"Request not supported. Code: " + type);
channel.clearInput();
sendError(null);
}
}
 catch (EOFException eof) {
shutdown();
}
catch (SocketException e) {
shutdown();
}
catch (OQueryParsingException e) {
sendError(e);
}
catch (OQueryExecutionException e) {
sendError(e);
}
catch (Throwable t) {
OLogManager.instance().error(this,"Error on executing request",t);
sendError(t);
}
 finally {
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
}
OSerializationThreadLocal.INSTANCE.get().clear();
}
