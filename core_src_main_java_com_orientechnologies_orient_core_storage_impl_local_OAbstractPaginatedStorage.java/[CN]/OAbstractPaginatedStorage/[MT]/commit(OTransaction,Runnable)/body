{
  checkOpeness();
  checkLowDiskSpaceAndFullCheckpointRequests();
  final ODatabaseDocumentInternal databaseRecord=(ODatabaseDocumentInternal)clientTx.getDatabase();
  ((OMetadataInternal)databaseRecord.getMetadata()).makeThreadLocalSchemaSnapshot();
  stateLock.acquireReadLock();
  try {
    try {
      dataLock.acquireExclusiveLock();
      try {
        checkOpeness();
        if (writeAheadLog == null && clientTx.isUsingLog())         throw new OStorageException("WAL mode is not active. Transactions are not supported in given mode");
        makeStorageDirty();
        startStorageTx(clientTx);
        final Iterable<ORecordOperation> entries=(Iterable<ORecordOperation>)clientTx.getAllRecordEntries();
        for (        ORecordOperation txEntry : entries) {
          if (txEntry.type == ORecordOperation.CREATED || txEntry.type == ORecordOperation.UPDATED) {
            final ORecord record=txEntry.getRecord();
            if (record instanceof ODocument)             ((ODocument)record).validate();
          }
        }
        Map<ORecordOperation,OPhysicalPosition> positions=new IdentityHashMap<ORecordOperation,OPhysicalPosition>();
        for (        ORecordOperation txEntry : entries) {
          ORecord rec=txEntry.getRecord();
          if (rec.getIdentity().isNew() && rec.isDirty()) {
            ORecordId rid=(ORecordId)rec.getIdentity().copy();
            ORecordId oldRID=rid.copy();
            int clusterId=rid.clusterId;
            if (rid.clusterId == ORID.CLUSTER_ID_INVALID && rec instanceof ODocument && ODocumentInternal.getImmutableSchemaClass(((ODocument)rec)) != null) {
              final OClass schemaClass=ODocumentInternal.getImmutableSchemaClass(((ODocument)rec));
              clusterId=schemaClass.getClusterForNewInstance((ODocument)rec);
            }
            final OCluster cluster=getClusterById(clusterId);
            OPhysicalPosition ppos=cluster.allocatePosition(ORecordInternal.getRecordType(rec));
            positions.put(txEntry,ppos);
            rid.clusterId=cluster.getId();
            ;
            rid.clusterPosition=ppos.clusterPosition;
            clientTx.updateIdentityAfterCommit(oldRID,rid);
          }
        }
        for (        ORecordOperation txEntry : entries) {
          commitEntry(clientTx,txEntry,positions.get(txEntry));
        }
        if (callback != null)         callback.run();
        endStorageTx();
        OTransactionAbstract.updateCacheFromEntries(clientTx,entries,true);
      }
 catch (      IOException ioe) {
        makeRollback(clientTx,ioe);
      }
catch (      RuntimeException e) {
        makeRollback(clientTx,e);
      }
 finally {
        transaction.set(null);
        dataLock.releaseExclusiveLock();
      }
    }
  finally {
      ((OMetadataInternal)databaseRecord.getMetadata()).clearThreadLocalSchemaSnapshot();
    }
  }
  finally {
    stateLock.releaseReadLock();
  }
}
