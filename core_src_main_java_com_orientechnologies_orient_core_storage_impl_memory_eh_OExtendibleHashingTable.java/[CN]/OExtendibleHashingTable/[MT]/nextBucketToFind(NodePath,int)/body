{
  int offset=nodePath.nodeGlobalDepth - bucketDepth;
  NodePath currentNode=nodePath;
  int nodeLocalDepth=nodesMetadata[nodePath.nodeIndex].getNodeLocalDepth();
  while (offset > 0) {
    offset-=nodeLocalDepth;
    if (offset > 0) {
      currentNode=nodePath.parent;
      nodeLocalDepth=nodesMetadata[currentNode.nodeIndex].getNodeLocalDepth();
    }
  }
  final int diff=bucketDepth - (currentNode.nodeGlobalDepth - nodeLocalDepth);
  final int interval=(1 << (nodeLocalDepth - diff));
  final int firstStartIndex=currentNode.itemIndex & ((levelMask << (nodeLocalDepth - diff)) & levelMask);
  final NodePath nodePathToFind;
  final int globalIndex=firstStartIndex + interval + currentNode.hashMapOffset;
  if (globalIndex >= maxLevelSize)   nodePathToFind=nextLevelUp(currentNode);
 else {
    final int hashMapSize=1 << currentNode.nodeLocalDepth;
    final int hashMapOffset=globalIndex / hashMapSize * hashMapSize;
    final int startIndex=globalIndex - hashMapOffset;
    nodePathToFind=new NodePath(currentNode.parent,hashMapOffset,startIndex,currentNode.nodeIndex,currentNode.nodeLocalDepth,currentNode.nodeGlobalDepth);
  }
  return nextNonEmptyNode(nodePathToFind);
}
