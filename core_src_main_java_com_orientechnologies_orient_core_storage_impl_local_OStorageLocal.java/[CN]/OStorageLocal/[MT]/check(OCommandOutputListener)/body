{
  int errors=0;
  int warnings=0;
  lock.acquireSharedLock();
  try {
    long totalRecors=0;
    final long start=System.currentTimeMillis();
    iListener.onMessage("\nChecking database '" + getName() + "'...\n");
    iListener.onMessage("\n- Checking cluster coherence...\n");
    final OPhysicalPosition ppos=new OPhysicalPosition();
    for (    OCluster c : clusters) {
      if (!(c instanceof OClusterLocal))       continue;
      iListener.onMessage(" +- Checking cluster '" + c.getName() + "' (id="+ c.getId()+ ")...\n");
      for (final OClusterPositionIterator it=c.absoluteIterator(); it.hasNext(); ) {
        final Long pos=it.next();
        totalRecors++;
        try {
          c.getPhysicalPosition(pos,ppos);
          if (ppos.dataSegmentId >= dataSegments.length) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong data segment %d",ppos.dataSegmentId);
            warnings++;
          }
          if (ppos.recordSize < 0) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong record size %d",ppos.recordSize);
            warnings++;
          }
          if (ppos.recordSize >= 1000000) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found suspected big record size %d. Is it corrupted?",ppos.recordSize);
            warnings++;
          }
          if (ppos.dataChunkPosition > dataSegments[ppos.dataSegmentId].getFilledUpTo()) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong pointer to data chunk %d out of data segment size (%d)",ppos.dataChunkPosition,dataSegments[ppos.dataSegmentId].getFilledUpTo());
            warnings++;
          }
          if (ppos.version < -1) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong record version %d",ppos.version);
            warnings++;
          }
 else           if (ppos.version == -1) {
            boolean found=false;
            int tot=((OClusterLocal)c).holeSegment.getHoles();
            for (int i=0; i < tot; ++i) {
              final long recycledPosition=((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE;
              if (recycledPosition == pos) {
                found=true;
                break;
              }
            }
            if (!found) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Cannot find hole for deleted record %d:%d",c.getId(),pos);
              warnings++;
            }
          }
        }
 catch (        IOException e) {
          OLogManager.instance().warn(this,"[OStorageLocal.check] Error while reading record #%d:%d",e,c.getId(),pos);
          warnings++;
        }
      }
      final int tot=((OClusterLocal)c).holeSegment.getHoles();
      if (tot > 0) {
        iListener.onMessage("  +- Checking " + tot + " hole(s)...\n");
        for (int i=0; i < tot; ++i) {
          long recycledPosition=-1;
          try {
            recycledPosition=((OClusterLocal)c).holeSegment.getEntryPosition(i) / OClusterLocal.RECORD_SIZE;
            c.getPhysicalPosition(recycledPosition,ppos);
            if (ppos.version != -1) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong hole %d/%d for deleted record %d:%d. The record seems good",i,tot - 1,c.getId(),recycledPosition);
              warnings++;
            }
          }
 catch (          Exception e) {
            OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong hole %d/%d for deleted record %d:%d. The record not exists",i,tot - 1,c.getId(),recycledPosition);
            warnings++;
          }
        }
      }
    }
    int totalChunks=0;
    iListener.onMessage("\n- Checking data chunks integrity...\n");
    for (    ODataLocal d : dataSegments) {
      int pos=0;
      while (pos < d.getFilledUpTo()) {
        totalChunks++;
        int recordSize=Integer.MIN_VALUE;
        try {
          recordSize=d.getRecordSize(pos);
          final ORecordId rid=d.getRecordRid(pos);
          if (recordSize < 0) {
            boolean found=false;
            for (            ODataHoleInfo hole : getHolesList()) {
              if (hole.dataOffset == pos) {
                found=true;
                break;
              }
            }
            if (!found) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Cannot find hole for deleted chunk %d",pos);
              warnings++;
            }
            if (rid.isValid()) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Deleted chunk at position %d (recordSize=%d) points to the valid RID %s instead of #-1:-1",pos,recordSize,rid);
              warnings++;
            }
            recordSize*=-1;
            pos+=recordSize;
          }
 else {
            final byte[] buffer=d.getRecord(pos);
            if (buffer.length != recordSize) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong record size: found %d but record length is %d",recordSize,buffer.length);
              warnings++;
            }
            if (!rid.isValid()) {
              OLogManager.instance().warn(this,"[OStorageLocal.check] Chunk at position %d points to invalid RID %s",pos,rid);
              warnings++;
            }
 else {
              if (clusters[rid.clusterId] == null) {
                OLogManager.instance().warn(this,"[OStorageLocal.check] Found ghost chunk at position %d pointed from %s. The cluster %d not exists",pos,rid,rid.clusterId);
                warnings++;
              }
 else {
                clusters[rid.clusterId].getPhysicalPosition(rid.clusterPosition,ppos);
                if (ppos.dataSegmentId != d.getId()) {
                  OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong record chunk data segment: found %d but current id is %d",ppos.dataSegmentId,d.getId());
                  warnings++;
                }
                if (ppos.dataChunkPosition != pos) {
                  OLogManager.instance().warn(this,"[OStorageLocal.check] Wrong chunk position: cluster record points to %d, but current chunk is at %d",ppos.dataChunkPosition,pos);
                  warnings++;
                }
              }
            }
            pos+=OBinaryProtocol.SIZE_INT + OBinaryProtocol.SIZE_SHORT + OBinaryProtocol.SIZE_LONG+ recordSize;
          }
        }
 catch (        Exception e) {
          OLogManager.instance().warn(this,"[OStorageLocal.check] Found wrong chunk %d",pos);
          errors++;
          break;
        }
      }
    }
    iListener.onMessage("\nCheck of database completed in " + (System.currentTimeMillis() - start) + "ms:\n- Total records checked: "+ totalRecors+ "\n- Total chunks checked.: "+ totalChunks+ "\n- Warnings.............: "+ warnings+ "\n- Errors...............: "+ errors+ "\n");
  }
  finally {
    lock.releaseSharedLock();
  }
}
