{
synchronized (syncObject) {
    final OFileClassic fileClassic=files.get(fileId);
    if (fileClassic == null || !fileClassic.isOpen())     return;
    final SortedMap<Long,OLogSequenceNumber> dirtyPages=this.dirtyPages.get(fileId);
    for (Iterator<Long> iterator=dirtyPages.keySet().iterator(); iterator.hasNext(); ) {
      Long pageIndex=iterator.next();
      OCacheEntry cacheEntry=get(fileId,pageIndex,false);
      if (cacheEntry == null) {
        final Long dataPointer=evictedPages.remove(new FileLockKey(fileId,pageIndex));
        if (dataPointer != null) {
          flushData(fileId,pageIndex,dataPointer);
          iterator.remove();
        }
      }
 else {
        if (cacheEntry.usageCounter == 0) {
          flushData(fileId,cacheEntry.pageIndex,cacheEntry.dataPointer);
          iterator.remove();
          cacheEntry.isDirty=false;
        }
 else {
          throw new OBlockedPageException("Unable to perform flush file because some pages is in use.");
        }
      }
    }
    fileClassic.synch();
  }
}
