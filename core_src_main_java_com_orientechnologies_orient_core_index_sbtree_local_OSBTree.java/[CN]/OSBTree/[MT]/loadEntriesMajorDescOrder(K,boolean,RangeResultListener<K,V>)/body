{
  final BucketSearchResult lastItem=lastItem();
  if (lastItem == null)   return;
  key=keySerializer.preprocess(key,(Object[])keyTypes);
  final PartialSearchMode partialSearchMode;
  if (inclusive)   partialSearchMode=PartialSearchMode.LOWEST_BOUNDARY;
 else   partialSearchMode=PartialSearchMode.HIGHEST_BOUNDARY;
  BucketSearchResult bucketSearchResult=findBucket(key,partialSearchMode);
  final long endPageIndex=bucketSearchResult.getLastPathItem();
  final int endIndex;
  if (bucketSearchResult.itemIndex >= 0) {
    endIndex=inclusive ? bucketSearchResult.itemIndex : bucketSearchResult.itemIndex + 1;
  }
 else {
    endIndex=-bucketSearchResult.itemIndex - 1;
  }
  long pageIndex=lastItem.getLastPathItem();
  resultsLoop:   while (true) {
    long prevPageIndex=-1;
    final OCacheEntry cacheEntry=diskCache.load(fileId,pageIndex,false);
    final OCachePointer pointer=cacheEntry.getCachePointer();
    try {
      OSBTreeBucket<K,V> bucket=new OSBTreeBucket<K,V>(pointer.getDataPointer(),keySerializer,keyTypes,valueSerializer,ODurablePage.TrackMode.NONE);
      final int start=bucket.size() - 1;
      final int end;
      if (pageIndex == endPageIndex)       end=endIndex;
 else       end=0;
      for (int i=start; i >= end; i--) {
        if (!listener.addResult(convertToMapEntry(bucket.getEntry(i))))         break resultsLoop;
      }
      if (pageIndex == endPageIndex)       break;
      if (bucket.getLeftSibling() >= 0)       prevPageIndex=bucket.getLeftSibling();
 else       break;
    }
  finally {
      diskCache.release(cacheEntry);
    }
    pageIndex=prevPageIndex;
  }
}
