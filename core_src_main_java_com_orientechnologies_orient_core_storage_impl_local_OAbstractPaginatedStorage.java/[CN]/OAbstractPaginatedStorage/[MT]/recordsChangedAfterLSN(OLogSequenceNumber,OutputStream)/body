{
  stateLock.acquireReadLock();
  try {
    if (writeAheadLog == null) {
      return null;
    }
    final OLogSequenceNumber lastLsn=writeAheadLog.end();
    if (lastLsn == null) {
      return null;
    }
    writeAheadLog.newSegment();
    OWALRecord walRecord=writeAheadLog.read(lsn);
    if (walRecord == null) {
      return null;
    }
    final Set<ORID> rids=new HashSet<ORID>();
    dataLock.acquireSharedLock();
    try {
      while (lsn != null && lsn.compareTo(lastLsn) <= 0) {
        walRecord=writeAheadLog.read(lsn);
        if (walRecord instanceof OAtomicUnitEndRecord) {
          final OAtomicUnitEndRecord atomicUnitEndRecord=(OAtomicUnitEndRecord)walRecord;
          final Map<String,OAtomicOperationMetadata<?>> atomicOperationMetadata=atomicUnitEndRecord.getAtomicOperationMetadata();
          if (atomicOperationMetadata.containsKey(ORecordOperationMetadata.RID_METADATA_KEY)) {
            final ORecordOperationMetadata recordOperationMetadata=(ORecordOperationMetadata)atomicOperationMetadata.get(ORecordOperationMetadata.RID_METADATA_KEY);
            rids.addAll(recordOperationMetadata.getValue());
          }
        }
        lsn=writeAheadLog.next(lsn);
      }
      for (      ORID rid : rids) {
        final OCluster cluster=clusters.get(rid.getClusterId());
        final ORawBuffer rawBuffer=cluster.readRecord(rid.getClusterPosition());
        if (rawBuffer != null) {
          final int entrySize=OIntegerSerializer.INT_SIZE + OIntegerSerializer.INT_SIZE + OLongSerializer.LONG_SIZE+ OByteSerializer.BYTE_SIZE+ OIntegerSerializer.INT_SIZE+ OByteSerializer.BYTE_SIZE+ rawBuffer.buffer.length;
          int offset=0;
          final byte[] data=new byte[entrySize];
          OIntegerSerializer.INSTANCE.serialize(entrySize - OIntegerSerializer.INT_SIZE,data,offset);
          offset+=OIntegerSerializer.INT_SIZE;
          OIntegerSerializer.INSTANCE.serialize(rid.getClusterId(),data,offset);
          offset+=OIntegerSerializer.INT_SIZE;
          OLongSerializer.INSTANCE.serialize(rid.getClusterPosition(),data,offset);
          offset+=OLongSerializer.LONG_SIZE;
          data[offset]=1;
          offset++;
          OIntegerSerializer.INSTANCE.serialize(rawBuffer.version,data,offset);
          offset+=OIntegerSerializer.INT_SIZE;
          data[offset]=rawBuffer.recordType;
          offset++;
          System.arraycopy(rawBuffer.buffer,0,data,offset,rawBuffer.buffer.length);
          stream.write(data);
        }
 else {
          final int entrySize=OIntegerSerializer.INT_SIZE + OIntegerSerializer.INT_SIZE + OLongSerializer.LONG_SIZE+ OByteSerializer.BYTE_SIZE;
          int offset=0;
          final byte[] data=new byte[entrySize];
          OIntegerSerializer.INSTANCE.serialize(entrySize,data,offset);
          offset+=OIntegerSerializer.INT_SIZE;
          OIntegerSerializer.INSTANCE.serialize(rid.getClusterId(),data,offset);
          offset+=OIntegerSerializer.INT_SIZE;
          OLongSerializer.INSTANCE.serialize(rid.getClusterPosition(),data,offset);
          offset+=OLongSerializer.LONG_SIZE;
          data[offset]=0;
          stream.write(data);
        }
      }
    }
  finally {
      dataLock.releaseSharedLock();
    }
    return lastLsn;
  }
 catch (  IOException e) {
    throw OException.wrapException(new OStorageException("Error of reading of records changed after LSN " + lsn),e);
  }
 finally {
    stateLock.releaseReadLock();
  }
}
