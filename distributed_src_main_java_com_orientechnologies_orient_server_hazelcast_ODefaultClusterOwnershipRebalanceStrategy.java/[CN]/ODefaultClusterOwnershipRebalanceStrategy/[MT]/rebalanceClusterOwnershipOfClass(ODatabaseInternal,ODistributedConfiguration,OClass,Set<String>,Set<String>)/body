{
  if (availableNodes.isEmpty())   return false;
  ((OClassImpl)iClass).setClusterSelectionInternal(new OLocalClusterStrategy(manager,iDatabase.getName(),iClass));
  if (iClass.isAbstract())   return false;
  final Set<String> clustersOfClassToReassign=new HashSet<String>();
  final int[] clusterIds=iClass.getClusterIds();
  final Set<String> clusterNames=new HashSet<String>(clusterIds.length);
  for (  int clusterId : clusterIds) {
    final String clusterName=iDatabase.getClusterNameById(clusterId);
    clusterNames.add(clusterName);
    if (clustersToReassign.remove(clusterName))     clustersOfClassToReassign.add(clusterName);
  }
  final Map<String,String> clusterToAssignOwnership=new HashMap<String,String>();
  int targetClustersPerNode=clusterNames.size() / availableNodes.size();
  if (targetClustersPerNode == 0 || clusterNames.size() % availableNodes.size() > 0)   targetClustersPerNode+=1;
  final List<OPair<String,List<String>>> nodeOwners=new ArrayList<OPair<String,List<String>>>(availableNodes.size());
  for (  String server : availableNodes) {
    final List<String> ownedClusters=cfg.getOwnedClusters(clusterNames,server);
    nodeOwners.add(new OPair<String,List<String>>(server,ownedClusters));
  }
  Collections.sort(nodeOwners,new Comparator<OPair<String,List<String>>>(){
    @Override public int compare(    OPair<String,List<String>> o1,    OPair<String,List<String>> o2){
      return o2.getValue().size() - o1.getValue().size();
    }
  }
);
  for (  OPair<String,List<String>> owner : nodeOwners) {
    final String server=owner.getKey();
    final List<String> ownedClusters=owner.getValue();
    if (ownedClusters.size() > targetClustersPerNode) {
      while (ownedClusters.size() > targetClustersPerNode) {
        clustersOfClassToReassign.add(ownedClusters.remove(ownedClusters.size() - 1));
      }
    }
 else     if (ownedClusters.size() < targetClustersPerNode) {
      while (ownedClusters.size() < targetClustersPerNode && !clustersOfClassToReassign.isEmpty()) {
        final Iterator<String> it=clustersOfClassToReassign.iterator();
        final String cluster=it.next();
        it.remove();
        clusterToAssignOwnership.put(cluster,server);
        ownedClusters.add(cluster);
      }
    }
  }
  boolean cfgChanged=!clusterToAssignOwnership.isEmpty();
  for (  Map.Entry<String,String> entry : clusterToAssignOwnership.entrySet()) {
    final String cluster=entry.getKey();
    final String node=entry.getValue();
    assignClusterOwnerswhip(iDatabase,cfg,iClass,cluster,node);
  }
  clustersToReassign.addAll(clustersOfClassToReassign);
  final Collection<String> allClusterNames=iDatabase.getClusterNames();
  for (  String server : availableNodes) {
    final List<String> ownedClusters=cfg.getOwnedClusters(clusterNames,server);
    if (ownedClusters.isEmpty()) {
      String newClusterName;
      for (int i=0; ; ++i) {
        newClusterName=iClass.getName().toLowerCase() + "_" + i;
        if (!allClusterNames.contains(newClusterName))         break;
      }
      ODistributedServerLog.info(this,manager.getLocalNodeName(),null,ODistributedServerLog.DIRECTION.NONE,"class '%s', creation of new local cluster '%s' (id=%d)",iClass,newClusterName,iDatabase.getClusterIdByName(newClusterName));
      final OScenarioThreadLocal.RUN_MODE currentDistributedMode=OScenarioThreadLocal.INSTANCE.get();
      if (currentDistributedMode != OScenarioThreadLocal.RUN_MODE.DEFAULT)       OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.DEFAULT);
      try {
        iClass.addCluster(newClusterName);
      }
 catch (      OCommandSQLParsingException e) {
        if (!e.getMessage().endsWith("already exists"))         throw e;
      }
catch (      Exception e) {
        ODistributedServerLog.error(this,manager.getLocalNodeName(),null,ODistributedServerLog.DIRECTION.NONE,"error on creating cluster '%s' in class '%s': ",newClusterName,iClass,e);
        throw OException.wrapException(new ODistributedException("Error on creating cluster '" + newClusterName + "' in class '"+ iClass+ "'"),e);
      }
 finally {
        if (currentDistributedMode != OScenarioThreadLocal.RUN_MODE.DEFAULT)         OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.RUNNING_DISTRIBUTED);
      }
      assignClusterOwnerswhip(iDatabase,cfg,iClass,newClusterName,server);
      cfgChanged=true;
    }
  }
  return cfgChanged;
}
