{
  final OStorage storage=openStorage(storageName);
  ODistributedServerLog.info(this,iCluster.getLocalNodeName(),"*",DIRECTION.OUT,"recovering uncommitted operations...");
  int updated=0;
  int deleted=0;
  try {
    for (    Entry<ORecordId,Long> entry : log.getUncommittedOperations().entrySet()) {
      final ORecordId rid=entry.getKey();
      final long offset=entry.getValue();
      try {
        if (getConflictResolver().existConflictsForRecord(rid))         continue;
        final OCluster recordCluster=storage.getClusterById(rid.getClusterId());
        if (recordCluster == null) {
          ODistributedServerLog.warn(this,iCluster.getLocalNodeName(),null,DIRECTION.NONE,"Cannot find cluster for RID %s, skip it",rid);
          continue;
        }
        final ORawBuffer record=(ORawBuffer)iCluster.sendRequest(storageName,new OReadRecordTask(rid));
        if (record == null) {
          storage.deleteRecord(rid,OVersionFactory.instance().createUntrackedVersion(),0,null);
          ODistributedServerLog.info(this,iCluster.getLocalNodeName(),"?",DIRECTION.IN,"restored record %s (delete)",rid);
          deleted++;
        }
 else {
          storage.updateRecord(rid,record.buffer,record.version,record.recordType,0,null);
          ODistributedServerLog.info(this,iCluster.getLocalNodeName(),"?",DIRECTION.IN,"restored record %s (update)",rid);
          updated++;
        }
        log.setOperationStatus(offset,null,ODatabaseJournal.OPERATION_STATUS.CANCELED);
      }
 catch (      Exception e) {
        ODistributedServerLog.error(this,iCluster.getLocalNodeName(),null,DIRECTION.NONE,"error on acquiring uncommitted record %s from other servers. The database could not be unaligned with others nodes!",e,rid);
      }
    }
  }
  finally {
    ODistributedServerLog.info(this,iCluster.getLocalNodeName(),"*",DIRECTION.OUT,"recovered %d operations: updated=%d deleted=%d",(updated + deleted),updated,deleted);
  }
  return updated + deleted;
}
