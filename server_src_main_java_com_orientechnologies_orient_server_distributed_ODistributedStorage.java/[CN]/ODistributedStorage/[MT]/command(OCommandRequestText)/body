{
  final OCommandExecutor executor=OCommandManager.instance().getExecutor(iCommand);
  executor.setProgressListener(iCommand.getProgressListener());
  executor.parse(iCommand);
  boolean distribute=false;
  final OCommandExecutor exec=executor instanceof OCommandExecutorSQLDelegate ? ((OCommandExecutorSQLDelegate)executor).getDelegate() : executor;
  if (!ODistributedThreadLocal.INSTANCE.distributedExecution)   if (exec instanceof OCommandDistributedConditionalReplicateRequest)   distribute=((OCommandDistributedConditionalReplicateRequest)exec).isReplicated();
 else   if (exec instanceof OCommandDistributedReplicateRequest)   distribute=true;
  if (distribute)   ODistributedThreadLocal.INSTANCE.distributedExecution=true;
  try {
    final Object localResult=wrapped.executeCommand(iCommand,executor);
    if (distribute) {
      final Map<String,Object> distributedResult=dManager.sendOperation2Nodes(dManager.getRemoteNodeIds(),new OSQLCommandDistributedTask(dManager.getLocalNodeId(),wrapped.getName(),createRecordMode,iCommand.getText()));
      for (      Entry<String,Object> entry : distributedResult.entrySet()) {
        final Object remoteResult=entry.getValue();
        if (localResult != remoteResult && (localResult == null && remoteResult != null || localResult != null && remoteResult == null || remoteResult.equals(localResult))) {
          final OReplicationConflictResolver resolver=dbSynchronizer.getConflictResolver();
          resolver.handleCommandConflict(entry.getKey(),iCommand,localResult,remoteResult);
        }
      }
    }
    return localResult;
  }
  finally {
    if (distribute)     ODistributedThreadLocal.INSTANCE.distributedExecution=false;
  }
}
