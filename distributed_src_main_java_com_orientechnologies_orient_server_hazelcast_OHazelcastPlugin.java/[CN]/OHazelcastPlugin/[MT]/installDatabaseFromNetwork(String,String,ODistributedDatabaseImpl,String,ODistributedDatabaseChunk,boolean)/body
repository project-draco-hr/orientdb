{
  final String fileName=Orient.getTempPath() + "install_" + databaseName+ ".zip";
  final String localNodeName=nodeName;
  ODistributedServerLog.info(this,localNodeName,iNode,DIRECTION.IN,"Copying remote database '%s' to: %s",databaseName,fileName);
  final File file=new File(fileName);
  if (file.exists())   file.delete();
  try {
    file.getParentFile().mkdirs();
    file.createNewFile();
  }
 catch (  IOException e) {
    throw OException.wrapException(new ODistributedException("Error on creating temp database file to install locally"),e);
  }
  final File completedFile=new File(file.getAbsolutePath() + ".completed");
  if (completedFile.exists())   completedFile.delete();
  final AtomicReference<OLogSequenceNumber> lsn=new AtomicReference<OLogSequenceNumber>();
  try {
    new Thread(new Runnable(){
      @Override public void run(){
        try {
          Thread.currentThread().setName("OrientDB installDatabase node=" + nodeName + " db="+ databaseName);
          ODistributedDatabaseChunk chunk=firstChunk;
          lsn.set(chunk.lsn);
          final OutputStream fOut=new FileOutputStream(fileName,false);
          try {
            long fileSize=writeDatabaseChunk(1,chunk,fOut);
            for (int chunkNum=2; !chunk.last; chunkNum++) {
              final ODistributedResponse response=sendRequest(databaseName,null,OMultiValue.getSingletonList(iNode),new OCopyDatabaseChunkTask(chunk.filePath,chunkNum,chunk.offset + chunk.buffer.length,false),EXECUTION_MODE.RESPONSE,null,null);
              final Object result=response.getPayload();
              if (result instanceof Boolean)               continue;
 else               if (result instanceof Exception) {
                ODistributedServerLog.error(this,nodeName,iNode,DIRECTION.IN,"error on installing database %s in %s (chunk #%d)",(Exception)result,databaseName,dbPath,chunkNum);
              }
 else               if (result instanceof ODistributedDatabaseChunk) {
                chunk=(ODistributedDatabaseChunk)result;
                fileSize+=writeDatabaseChunk(chunkNum,chunk,fOut);
              }
            }
            fOut.flush();
            new File(file.getAbsolutePath() + ".completed").createNewFile();
            if (lsn.get() != null) {
              try {
                final ODistributedDatabase distrDatabase=getMessageService().getDatabase(databaseName);
                distrDatabase.getSyncConfiguration().setLSN(iNode,lsn.get());
              }
 catch (              IOException e) {
                ODistributedServerLog.error(this,nodeName,iNode,DIRECTION.IN,"Error on updating distributed-sync.json file for database '%s'. Next request of delta of changes will contains old records too",e,databaseName);
              }
            }
 else             ODistributedServerLog.warn(this,nodeName,iNode,DIRECTION.IN,"LSN not found in database from network, database delta sync will be not available for database '%s'",databaseName);
            ODistributedServerLog.info(this,nodeName,null,DIRECTION.NONE,"Database copied correctly, size=%s",OFileUtils.getSizeAsString(fileSize));
          }
  finally {
            try {
              fOut.flush();
              fOut.close();
            }
 catch (            IOException e) {
            }
          }
        }
 catch (        Exception e) {
          ODistributedServerLog.error(this,nodeName,null,DIRECTION.NONE,"Error on transferring database '%s' to '%s'",e,databaseName,fileName);
          throw OException.wrapException(new ODistributedException("Error on transferring database"),e);
        }
      }
    }
).start();
  }
 catch (  Exception e) {
    ODistributedServerLog.error(this,nodeName,null,DIRECTION.NONE,"Error on transferring database '%s' to '%s'",e,databaseName,fileName);
    throw OException.wrapException(new ODistributedException("Error on transferring database"),e);
  }
  final ODatabaseDocumentTx db=installDatabaseOnLocalNode(databaseName,dbPath,iNode,fileName,delta);
  if (db != null) {
    db.activateOnCurrentThread();
    db.close();
    final OStorage stg=Orient.instance().getStorage(databaseName);
    if (stg != null)     stg.close();
    final Lock lock=getLock(databaseName + ".cfg");
    lock.lock();
    try {
      final ODistributedConfiguration cfg=getDatabaseConfiguration(db.getName());
      final boolean distribCfgDirty=rebalanceClusterOwnership(nodeName,db,cfg,new HashSet<String>(),true);
      if (distribCfgDirty) {
        ODistributedServerLog.info(this,nodeName,null,DIRECTION.NONE,"Distributed configuration modified");
        updateCachedDatabaseConfiguration(db.getName(),cfg.serialize(),true,true);
      }
      distrDatabase.setOnline();
    }
  finally {
      lock.unlock();
    }
    db.activateOnCurrentThread();
    db.close();
  }
  final ODistributedConfiguration cfg=getDatabaseConfiguration(db.getName());
  final Set<String> localManagedClusters=cfg.getClustersOnServer(localNodeName);
  final Set<String> sourceNodeClusters=cfg.getClustersOnServer(iNode);
  localManagedClusters.removeAll(sourceNodeClusters);
  final HashSet<String> toSynchClusters=new HashSet<String>();
  for (  String cl : localManagedClusters) {
    if (!cfg.getServers(cl,localNodeName).isEmpty())     toSynchClusters.add(cl);
  }
  return toSynchClusters;
}
