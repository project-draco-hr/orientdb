{
  listener.onMessage("\nImporting database schema...");
  jsonReader.readNext(OJSONReader.BEGIN_OBJECT).checkContent("\"schema\":").readNext(OJSONReader.FIELD_ASSIGNMENT);
  @SuppressWarnings("unused") int schemaVersion=jsonReader.checkContent("\"version\"").readNumber(OJSONReader.ANY_NUMBER,true);
  jsonReader.readNext(OJSONReader.COMMA_SEPARATOR).readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"classes\"");
  jsonReader.readNext(OJSONReader.BEGIN_COLLECTION);
  long classImported=0;
  String className;
  int classId;
  int classDefClusterId;
  String classClusterIds;
  String classSuper=null;
  OClass cls;
  try {
    do {
      jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"class\"").readString(OJSONReader.BEGIN_OBJECT);
      className=jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"name\"").readString(OJSONReader.COMMA_SEPARATOR);
      classId=jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"id\"").readInteger(OJSONReader.COMMA_SEPARATOR);
      classDefClusterId=jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"default-cluster-id\"").readInteger(OJSONReader.COMMA_SEPARATOR);
      classClusterIds=jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent("\"cluster-ids\"").readString(OJSONReader.NEXT_IN_OBJECT).trim();
      cls=database.getMetadata().getSchema().getClass(className);
      if (cls != null) {
        if (cls.getDefaultClusterId() != classDefClusterId)         cls.setDefaultClusterId(classDefClusterId);
      }
 else       cls=database.getMetadata().getSchema().createClass(className,classDefClusterId);
      if (classId != cls.getId())       throw new OSchemaException("Imported class '" + className + "' has id="+ cls.getId()+ " different from the original: "+ classId);
      if (classClusterIds != null) {
        classClusterIds=classClusterIds.substring(1,classClusterIds.length() - 1);
        for (        int i : OStringSerializerHelper.splitIntArray(classClusterIds)) {
          cls.addClusterIds(i);
        }
      }
      String value;
      while (jsonReader.lastChar() == ',') {
        jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);
        value=jsonReader.getValue();
        if (value.equals("\"super-class\"")) {
          classSuper=jsonReader.readString(OJSONReader.NEXT_IN_OBJECT);
          superClasses.put(cls,classSuper);
        }
 else         if (value.equals("\"properties\"")) {
          jsonReader.readString(OJSONReader.BEGIN_COLLECTION);
          while (jsonReader.lastChar() != ']') {
            importProperty(cls);
            if (jsonReader.lastChar() == '}')             jsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);
          }
          jsonReader.readNext(OJSONReader.END_OBJECT);
        }
      }
      classImported++;
      jsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);
    }
 while (jsonReader.lastChar() == ',');
    for (    Map.Entry<OClass,String> entry : superClasses.entrySet()) {
      cls.setSuperClass(database.getMetadata().getSchema().getClass(entry.getValue()));
    }
    for (    Map.Entry<OProperty,String> entry : linkedClasses.entrySet()) {
      entry.getKey().setLinkedClass(database.getMetadata().getSchema().getClass(entry.getValue()));
    }
    listener.onMessage("OK (" + classImported + " entries)");
    jsonReader.readNext(OJSONReader.END_OBJECT);
    jsonReader.readNext(OJSONReader.COMMA_SEPARATOR);
  }
 catch (  Exception e) {
    e.printStackTrace();
    listener.onMessage("ERROR (" + classImported + " entries): "+ e);
  }
}
