{
  if (status == TXSTATUS.ROLLED_BACK || status == TXSTATUS.ROLLBACKING)   throw new ORollbackException("Given transaction was rolled back and cannot be used.");
  status=TXSTATUS.COMMITTING;
  if (!recordEntries.isEmpty() || !indexEntries.isEmpty()) {
    if (OScenarioThreadLocal.INSTANCE.get() != RUN_MODE.RUNNING_DISTRIBUTED && !(database.getStorage().getUnderlying() instanceof OAbstractPaginatedStorage))     database.getStorage().commit(this,null);
 else {
      List<OIndexAbstract<?>> lockedIndexes=acquireIndexLocks();
      try {
        final Map<String,OIndex<?>> indexes=new HashMap<String,OIndex<?>>();
        for (        OIndex<?> index : database.getMetadata().getIndexManager().getIndexes())         indexes.put(index.getName(),index);
        final Runnable callback=new CommitIndexesCallback(indexes);
        final String storageType=database.getStorage().getUnderlying().getType();
        if (storageType.equals(OEngineLocalPaginated.NAME) || storageType.equals(OEngineMemory.NAME))         database.getStorage().commit(OTransactionOptimistic.this,callback);
 else {
          database.getStorage().callInLock(new Callable<Object>(){
            @Override public Object call() throws Exception {
              database.getStorage().commit(OTransactionOptimistic.this,callback);
              return null;
            }
          }
,true);
        }
      }
  finally {
        releaseIndexLocks(lockedIndexes);
      }
    }
  }
  close();
  status=TXSTATUS.COMPLETED;
}
