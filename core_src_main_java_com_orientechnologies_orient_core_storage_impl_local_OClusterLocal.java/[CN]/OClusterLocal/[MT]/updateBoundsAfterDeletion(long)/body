{
  final long position=iPosition * RECORD_SIZE;
  if (iPosition == beginOffsetData) {
    if (getEntries() == 0)     beginOffsetData=-1;
 else {
      beginOffsetData++;
      long[] fetchPos;
      for (long currentPos=position + RECORD_SIZE; currentPos < getFilledUpTo(); currentPos+=RECORD_SIZE) {
        fetchPos=getRelativePosition(currentPos);
        if (files[(int)fetchPos[0]].readShort(fetchPos[1]) != -1)         break;
        beginOffsetData++;
      }
    }
    files[0].writeHeaderLong(0,beginOffsetData);
  }
  if (iPosition == endOffsetData) {
    if (getEntries() == 0)     endOffsetData=-1;
 else {
      endOffsetData--;
      long[] fetchPos;
      for (long currentPos=position - RECORD_SIZE; currentPos >= beginOffsetData; currentPos-=RECORD_SIZE) {
        fetchPos=getRelativePosition(currentPos);
        if (files[(int)fetchPos[0]].readShort(fetchPos[1]) != -1)         break;
        endOffsetData--;
      }
    }
    files[0].writeHeaderLong(OBinaryProtocol.SIZE_LONG,endOffsetData);
  }
}
