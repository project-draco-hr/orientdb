{
  if (iValue == null)   return null;
  if (iType == null)   iType=OType.EMBEDDED;
switch (iType) {
case STRING:
    return "\"" + OStringSerializerHelper.encode(iValue.toString()) + "\"";
case BOOLEAN:
case INTEGER:
  return String.valueOf(iValue);
case FLOAT:
return String.valueOf(iValue) + 'f';
case LONG:
return String.valueOf(iValue) + 'l';
case DOUBLE:
return String.valueOf(iValue) + 'd';
case SHORT:
return String.valueOf(iValue) + 's';
case BYTE:
if (iValue instanceof Character) return String.valueOf((int)((Character)iValue).charValue()) + 'b';
 else if (iValue instanceof String) return String.valueOf((int)((String)iValue).charAt(0)) + 'b';
 else return String.valueOf(iValue) + 'b';
case BINARY:
final String str;
if (iValue instanceof Byte) str=new String(new byte[]{((Byte)iValue).byteValue()});
 else str=OBase64Utils.encodeBytes((byte[])iValue);
return "\"" + str + "\"";
case DATE:
if (iValue instanceof Date) return String.valueOf(((Date)iValue).getTime()) + 't';
 else return String.valueOf(iValue) + 't';
case LINK:
if (iValue instanceof ORID) return iValue.toString();
 else return ((ORecord<?>)iValue).getIdentity().toString();
case EMBEDDEDMAP:
return ORecordSerializerSchemaAware2CSV.INSTANCE.embeddedMapToStream(iDatabase,null,null,null,iValue,null,true);
case EMBEDDED:
return OStringSerializerAnyStreamable.INSTANCE.toStream(iDatabase,iValue);
}
throw new IllegalArgumentException("Type " + iType + " not supported to convert value: "+ iValue);
}
