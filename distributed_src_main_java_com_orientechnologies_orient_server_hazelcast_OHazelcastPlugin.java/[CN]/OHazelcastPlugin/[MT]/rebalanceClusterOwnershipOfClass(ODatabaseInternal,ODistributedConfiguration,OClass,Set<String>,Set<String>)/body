{
  if (availableNodes.isEmpty())   return false;
  ((OClassImpl)iClass).setClusterSelectionInternal(new OLocalClusterStrategy(this,iDatabase.getName(),iClass));
  if (iClass.isAbstract())   return false;
  final int[] clusterIds=iClass.getClusterIds();
  final Set<String> clusterNames=new HashSet<String>(clusterIds.length);
  for (  int clusterId : clusterIds)   clusterNames.add(iDatabase.getClusterNameById(clusterId));
  final Map<String,String> clusterToAssignOwnership=new HashMap<String,String>();
  int targetClustersPerNode=clusterNames.size() / availableNodes.size();
  if (targetClustersPerNode == 0)   targetClustersPerNode=1;
  for (  String server : availableNodes) {
    final List<String> ownedClusters=cfg.getOwnedClusters(clusterNames,server);
    if (ownedClusters.size() > targetClustersPerNode) {
      while (ownedClusters.size() > targetClustersPerNode) {
        clustersToReassign.add(ownedClusters.remove(ownedClusters.size() - 1));
      }
    }
 else     if (ownedClusters.size() < targetClustersPerNode) {
      while (ownedClusters.size() < targetClustersPerNode && !clustersToReassign.isEmpty()) {
        final Iterator<String> it=clustersToReassign.iterator();
        final String cluster=it.next();
        it.remove();
        clusterToAssignOwnership.put(cluster,server);
        ownedClusters.add(cluster);
      }
    }
  }
  final Collection<String> allClusterNames=iDatabase.getClusterNames();
  for (  String server : availableNodes) {
    final List<String> ownedClusters=cfg.getOwnedClusters(clusterNames,server);
    if (ownedClusters.isEmpty()) {
      String newClusterName;
      for (int i=0; ; ++i) {
        newClusterName=iClass.getName().toLowerCase() + "_" + i;
        if (!allClusterNames.contains(newClusterName))         break;
      }
      ODistributedServerLog.info(this,nodeName,null,DIRECTION.NONE,"class '%s', creation of new local cluster '%s' (id=%d)",iClass,newClusterName,iDatabase.getClusterIdByName(newClusterName));
      final OScenarioThreadLocal.RUN_MODE currentDistributedMode=OScenarioThreadLocal.INSTANCE.get();
      if (currentDistributedMode != OScenarioThreadLocal.RUN_MODE.DEFAULT)       OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.DEFAULT);
      try {
        iClass.addCluster(newClusterName);
      }
 catch (      OCommandSQLParsingException e) {
        if (!e.getMessage().endsWith("already exists"))         throw e;
      }
catch (      Exception e) {
        ODistributedServerLog.error(this,nodeName,null,DIRECTION.NONE,"error on creating cluster '%s' in class '%s': ",newClusterName,iClass,e);
        throw OException.wrapException(new ODistributedException("Error on creating cluster '" + newClusterName + "' in class '"+ iClass+ "'"),e);
      }
 finally {
        if (currentDistributedMode != OScenarioThreadLocal.RUN_MODE.DEFAULT)         OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.RUNNING_DISTRIBUTED);
      }
      clusterToAssignOwnership.put(newClusterName,server);
    }
  }
  for (  Map.Entry<String,String> entry : clusterToAssignOwnership.entrySet()) {
    final String cluster=entry.getKey();
    final String node=entry.getValue();
    ODistributedServerLog.info(this,node,null,DIRECTION.NONE,"Class '%s': change mastership of cluster '%s' (id=%d) to node '%s'",iClass,cluster,iDatabase.getClusterIdByName(cluster),node);
    cfg.setServerOwner(cluster,node);
  }
  return !clusterToAssignOwnership.isEmpty();
}
