{
  final OTransactionIndexChanges indexChanges=database.getTransaction().getIndexChanges(delegate.getName());
  if (indexChanges == null)   return super.getValues(iKeys,ascSortOrder);
  final Collection<?> keys=new ArrayList<Object>(iKeys);
  final Comparator<Object> comparator;
  if (ascSortOrder)   comparator=ODefaultComparator.INSTANCE;
 else   comparator=Collections.reverseOrder(ODefaultComparator.INSTANCE);
  final TreeMap<Object,List<OIdentifiable>> result=new TreeMap<Object,List<OIdentifiable>>(comparator);
  final Set<Object> keysToRemove=new HashSet<Object>();
  for (  final Object key : keys) {
    final List<OIdentifiable> keyResult;
    if (!indexChanges.cleared)     if (indexChanges.containsChangesPerKey(key))     keyResult=new ArrayList<OIdentifiable>(super.get(key));
 else     continue;
 else     keyResult=new ArrayList<OIdentifiable>();
    keysToRemove.add(key);
    filterIndexChanges(indexChanges,key,keyResult);
    result.put(key,keyResult);
  }
  keys.removeAll(keysToRemove);
  if (!keys.isEmpty()) {
    Collection<ODocument> entries=super.getEntries(keys);
    for (    ODocument entry : entries) {
      final Object key=entry.field("key");
      final OIdentifiable identifiable=entry.field("rid",OType.LINK);
      List<OIdentifiable> keyResult=result.get(key);
      if (keyResult == null) {
        keyResult=new ArrayList<OIdentifiable>();
        result.put(key,keyResult);
      }
      keyResult.add(identifiable);
    }
  }
  final List<OIdentifiable> returnedCollection=new ArrayList<OIdentifiable>();
  for (  List<OIdentifiable> values : result.values())   returnedCollection.addAll(values);
  return returnedCollection;
}
