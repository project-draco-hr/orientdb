{
  if (!groupResponsesByResult || request.getTask().getQuorumType() == OCommandDistributedReplicateRequest.QUORUM_TYPE.NONE)   return null;
  if (dManager.getNodeStatus() != ODistributedServerManager.NODE_STATUS.ONLINE)   return null;
  final int bestResponsesGroupIndex=getBestResponsesGroup();
  final List<ODistributedResponse> bestResponsesGroup=responseGroups.get(bestResponsesGroupIndex);
  final int maxCoherentResponses=bestResponsesGroup.size();
  final int conflicts=getExpectedResponses() - (maxCoherentResponses + discardedResponses);
  boolean requireUndo=false;
  if (isMinimumQuorumReached()) {
    if (responseGroups.size() == 1)     return null;
    if (checkNoWinnerCase(bestResponsesGroup))     return null;
    if (fixNodesInConflict(bestResponsesGroup,conflicts))     return null;
  }
  ODistributedServerLog.warn(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,"detected %d node(s) in timeout or in conflict and quorum (%d) has not been reached, rolling back changes for request (%s)",conflicts,quorum,request);
  if (ODistributedServerLog.isDebugEnabled())   ODistributedServerLog.debug(this,dManager.getLocalNodeName(),null,DIRECTION.NONE,composeConflictMessage());
  undoRequest();
  final Object goodResponsePayload=bestResponsesGroup.isEmpty() ? null : bestResponsesGroup.get(0).getPayload();
  if (goodResponsePayload instanceof RuntimeException)   return (RuntimeException)goodResponsePayload;
 else   if (goodResponsePayload instanceof Throwable)   return OException.wrapException(new ODistributedException(composeConflictMessage()),(Throwable)goodResponsePayload);
 else   return new ODistributedOperationException(composeConflictMessage());
}
