{
  final long timer=Orient.instance().getProfiler().startChrono();
  lock.acquireSharedLock();
  try {
switch (iLockingStrategy) {
case DEFAULT:
case KEEP_SHARED_LOCK:
      iRid.lock(false);
    break;
case NONE:
  break;
case KEEP_EXCLUSIVE_LOCK:
iRid.lock(true);
}
try {
final OClusterPosition lastPos=iClusterSegment.getLastPosition();
if (!iClusterSegment.isHashBased()) {
if (iRid.clusterPosition.compareTo(lastPos) > 0) return null;
}
final OPhysicalPosition ppos=iClusterSegment.getPhysicalPosition(new OPhysicalPosition(iRid.clusterPosition));
if (ppos != null && loadTombstones && ppos.recordVersion.isTombstone()) return new ORawBuffer(null,ppos.recordVersion,ppos.recordType);
if (ppos == null || ppos.recordVersion.isTombstone()) return null;
final ODataSegmentMemory dataSegment=getDataSegmentById(ppos.dataSegmentId);
return new ORawBuffer(dataSegment.readRecord(ppos.dataSegmentPos),ppos.recordVersion,ppos.recordType);
}
  finally {
switch (iLockingStrategy) {
case DEFAULT:
iRid.unlock();
break;
case NONE:
case KEEP_SHARED_LOCK:
case KEEP_EXCLUSIVE_LOCK:
break;
}
}
}
 catch (IOException e) {
throw new OStorageException("Error on read record in cluster: " + iClusterSegment.getId(),e);
}
 finally {
lock.releaseSharedLock();
Orient.instance().getProfiler().stopChrono(PROFILER_READ_RECORD,"Read a record from database",timer,"db.*.readRecord");
}
}
