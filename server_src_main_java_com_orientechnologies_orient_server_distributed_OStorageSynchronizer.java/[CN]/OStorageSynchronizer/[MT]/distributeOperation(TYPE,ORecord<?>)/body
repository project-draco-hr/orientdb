{
  OPERATION operation=null;
switch (iType) {
case AFTER_CREATE:
    operation=OPERATION.RECORD_CREATE;
  break;
case AFTER_UPDATE:
operation=OPERATION.RECORD_UPDATE;
break;
case AFTER_DELETE:
operation=OPERATION.RECORD_DELETE;
break;
}
if (operation != null) {
final ORecordId rid=(ORecordId)iRecord.getIdentity();
final String clusterName=storage.getClusterById(rid.getClusterId()).getName();
if (!canExecuteOperation(clusterName,operation,"out")) {
OLogManager.instance().debug(this,"DISTRIBUTED -> skip sending operation %s against cluster '%s' to remote nodes because of the distributed configuration",operation,clusterName);
return false;
}
final EXECUTION_MODE mode=getOperationMode(clusterName,operation);
for (OSynchronizationLog localLog : logs.values()) {
try {
if (localLog.appendLog(operation,rid,iRecord.getVersion()) == -1) {
OLogManager.instance().warn(this,"DISTRIBUTED -> replication log limit reached for file: %s. The node will be offline and a manual alignment will be needed",localLog);
}
}
 catch (IOException e) {
OLogManager.instance().error(this,"DISTRIBUTED -> Error on appending log in file: %s. The coherence of the cluster is not more guaranteed",e,localLog);
}
}
final Set<String> members=cluster.getRemoteNodeIds();
if (!members.isEmpty()) {
cluster.executeOperation(members,operation,storageName,rid,iRecord.getVersion(),new ORawBuffer((ORecordInternal<?>)iRecord),mode);
for (String member : members) {
final OSynchronizationLog log=getLog(member);
try {
log.success();
}
 catch (IOException e) {
OLogManager.instance().error(this,"DISTRIBUTED -> Error on reset log file: %s",e,log);
}
}
}
}
return false;
}
