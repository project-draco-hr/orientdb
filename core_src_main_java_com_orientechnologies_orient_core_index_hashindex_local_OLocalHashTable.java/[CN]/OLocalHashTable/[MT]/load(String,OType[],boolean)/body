{
  acquireExclusiveLock();
  try {
    if (keyTypes != null)     this.keyTypes=Arrays.copyOf(keyTypes,keyTypes.length);
 else     this.keyTypes=null;
    this.nullKeyIsSupported=nullKeyIsSupported;
    OAtomicOperation atomicOperation=atomicOperationsManager.getCurrentOperation();
    fileStateId=openFile(atomicOperation,name + metadataConfigurationFileExtension);
    final OCacheEntry hashStateEntry=loadPage(atomicOperation,fileStateId,0,true);
    hashStateEntryIndex=hashStateEntry.getPageIndex();
    directory=new OHashTableDirectory(treeStateFileExtension,name,durableInNonTxMode,storage);
    directory.open();
    pinPage(atomicOperation,hashStateEntry);
    try {
      OHashIndexFileLevelMetadataPage page=new OHashIndexFileLevelMetadataPage(hashStateEntry,getChangesTree(atomicOperation,hashStateEntry),false);
      keySerializer=(OBinarySerializer<K>)OBinarySerializerFactory.getInstance().getObjectSerializer(page.getKeySerializerId());
      valueSerializer=(OBinarySerializer<V>)OBinarySerializerFactory.getInstance().getObjectSerializer(page.getValueSerializerId());
    }
  finally {
      releasePage(atomicOperation,hashStateEntry);
    }
    if (nullKeyIsSupported)     nullBucketFileId=openFile(atomicOperation,name + nullBucketFileExtension);
    fileId=openFile(atomicOperation,getFullName());
  }
 catch (  IOException e) {
    throw new OIndexException("Exception during hash table loading",e);
  }
 finally {
    releaseExclusiveLock();
  }
}
