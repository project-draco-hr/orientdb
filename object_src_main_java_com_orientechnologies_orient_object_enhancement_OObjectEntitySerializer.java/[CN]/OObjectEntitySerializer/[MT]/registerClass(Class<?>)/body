{
  if (Proxy.class.isAssignableFrom(iClass) || classes.contains(iClass))   return;
  if (ODatabaseRecordThreadLocal.INSTANCE.isDefined() && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed() && !ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().existsClass(iClass.getSimpleName()))   ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().createClass(iClass.getSimpleName());
  for (Class<?> currentClass=iClass; currentClass != Object.class; ) {
    if (!classes.contains(currentClass)) {
      classes.add(currentClass);
      Class<?> fieldType;
      for (      Field f : currentClass.getDeclaredFields()) {
        final String fieldName=f.getName();
        final int fieldModifier=f.getModifiers();
        List<String> allClassFields=allFields.get(currentClass);
        if (allClassFields == null)         allClassFields=new ArrayList<String>();
        allClassFields.add(fieldName);
        allFields.put(currentClass,allClassFields);
        if (Modifier.isStatic(fieldModifier) || Modifier.isFinal(fieldModifier) || Modifier.isNative(fieldModifier)|| Modifier.isTransient(fieldModifier)) {
          List<String> classTransientFields=transientFields.get(currentClass);
          if (classTransientFields == null)           classTransientFields=new ArrayList<String>();
          classTransientFields.add(fieldName);
          transientFields.put(currentClass,classTransientFields);
        }
        if (fieldName.equals("this$0")) {
          List<String> classTransientFields=transientFields.get(currentClass);
          if (classTransientFields == null)           classTransientFields=new ArrayList<String>();
          classTransientFields.add(fieldName);
          transientFields.put(currentClass,classTransientFields);
        }
        if (OObjectSerializerHelper.jpaTransientClass != null) {
          Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaTransientClass);
          if (ann != null) {
            List<String> classTransientFields=transientFields.get(currentClass);
            if (classTransientFields == null)             classTransientFields=new ArrayList<String>();
            classTransientFields.add(fieldName);
            transientFields.put(currentClass,classTransientFields);
          }
        }
        if (OObjectSerializerHelper.jpaOneToOneClass != null) {
          Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaOneToOneClass);
          if (ann != null) {
            OneToOne oneToOne=((OneToOne)ann);
            if (checkCascadeDelete(oneToOne)) {
              addCascadeDeleteField(currentClass,fieldName);
            }
          }
        }
        if (OObjectSerializerHelper.jpaOneToManyClass != null) {
          Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaOneToManyClass);
          if (ann != null) {
            OneToMany oneToMany=((OneToMany)ann);
            if (checkCascadeDelete(oneToMany)) {
              addCascadeDeleteField(currentClass,fieldName);
            }
          }
        }
        if (OObjectSerializerHelper.jpaManyToManyClass != null) {
          Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaManyToManyClass);
          if (ann != null) {
            ManyToMany manyToMany=((ManyToMany)ann);
            if (checkCascadeDelete(manyToMany)) {
              addCascadeDeleteField(currentClass,fieldName);
            }
          }
        }
        fieldType=f.getType();
        if (Collection.class.isAssignableFrom(fieldType) || fieldType.isArray() || Map.class.isAssignableFrom(fieldType)) {
          fieldType=OReflectionHelper.getGenericMultivalueType(f);
        }
        if (isToSerialize(fieldType)) {
          Map<Field,Class<?>> serializeClass=serializedFields.get(currentClass);
          if (serializeClass == null)           serializeClass=new HashMap<Field,Class<?>>();
          serializeClass.put(f,fieldType);
          serializedFields.put(currentClass,serializeClass);
        }
        boolean directBinding=true;
        if (f.getAnnotation(OAccess.class) == null || f.getAnnotation(OAccess.class).value() == OAccess.OAccessType.PROPERTY)         directBinding=true;
 else         if (OObjectSerializerHelper.jpaAccessClass != null) {
          Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaAccessClass);
          if (ann != null) {
            directBinding=true;
          }
        }
        if (directBinding) {
          List<String> classDirectAccessFields=directAccessFields.get(currentClass);
          if (classDirectAccessFields == null)           classDirectAccessFields=new ArrayList<String>();
          classDirectAccessFields.add(fieldName);
          directAccessFields.put(currentClass,classDirectAccessFields);
        }
        if (f.getAnnotation(ODocumentInstance.class) != null)         boundDocumentFields.put(currentClass,f);
        boolean idFound=false;
        if (f.getAnnotation(OId.class) != null) {
          fieldIds.put(currentClass,f);
          idFound=true;
        }
 else         if (OObjectSerializerHelper.jpaIdClass != null && f.getAnnotation(OObjectSerializerHelper.jpaIdClass) != null) {
          fieldIds.put(currentClass,f);
          idFound=true;
        }
        if (idFound) {
          if (fieldType.isPrimitive())           OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be a literal to manage the Record Id",f.toString());
 else           if (!ORID.class.isAssignableFrom(fieldType) && fieldType != String.class && fieldType != Object.class && !Number.class.isAssignableFrom(fieldType))           OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be managed as type: %s",f.toString(),fieldType);
        }
        boolean vFound=false;
        if (f.getAnnotation(OVersion.class) != null) {
          fieldVersions.put(currentClass,f);
          vFound=true;
        }
 else         if (OObjectSerializerHelper.jpaVersionClass != null && f.getAnnotation(OObjectSerializerHelper.jpaVersionClass) != null) {
          fieldVersions.put(currentClass,f);
          vFound=true;
        }
        if (vFound) {
          if (fieldType.isPrimitive())           OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be a literal to manage the Version",f.toString());
 else           if (fieldType != String.class && fieldType != Object.class && !Number.class.isAssignableFrom(fieldType))           OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be managed as type: %s",f.toString(),fieldType);
        }
        if (OObjectSerializerHelper.jpaEmbeddedClass != null && f.getAnnotation(OObjectSerializerHelper.jpaEmbeddedClass) != null) {
          List<String> classEmbeddedFields=embeddedFields.get(currentClass);
          if (classEmbeddedFields == null)           classEmbeddedFields=new ArrayList<String>();
          classEmbeddedFields.add(fieldName);
          embeddedFields.put(currentClass,classEmbeddedFields);
        }
      }
      registerCallbacks(currentClass);
    }
    String iClassName=iClass.getSimpleName();
    currentClass=currentClass.getSuperclass();
    if (currentClass == null || currentClass.equals(ODocument.class))     currentClass=Object.class;
    if (ODatabaseRecordThreadLocal.INSTANCE.get() != null && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed() && !currentClass.equals(Object.class)) {
      OClass oSuperClass;
      OClass currentOClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().getClass(iClassName);
      if (!ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().existsClass(currentClass.getSimpleName()))       oSuperClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().createClass(currentClass.getSimpleName());
 else       oSuperClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().getClass(currentClass.getSimpleName());
      if (currentOClass.getSuperClass() == null || !currentOClass.getSuperClass().equals(oSuperClass))       currentOClass.setSuperClass(oSuperClass);
    }
  }
  if (ODatabaseRecordThreadLocal.INSTANCE.get() != null && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed())   ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().save();
}
