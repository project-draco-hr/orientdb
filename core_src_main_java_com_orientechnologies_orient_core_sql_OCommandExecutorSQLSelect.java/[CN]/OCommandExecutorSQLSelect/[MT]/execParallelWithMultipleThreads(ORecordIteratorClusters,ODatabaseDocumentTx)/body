{
  final int[] clusterIds=iTarget.getClusterIds();
  final List<Integer> clusterList=new ArrayList<Integer>();
  for (int i=0; i < clusterIds.length; ++i)   if (db.getStorage().getClusterById(clusterIds[i]).getEntries() > 0)   clusterList.add(clusterIds[i]);
  final int threadNumber=clusterList.size();
  OLogManager.instance().debug(this,"Executing parallel query with strategy one thread per cluster. clusterIds=%d, threads=%d",clusterIds.length,threadNumber);
  final Thread[] threads=new Thread[threadNumber];
  final boolean[] results=new boolean[threadNumber];
  final OCommandContext[] contexts=new OCommandContext[threadNumber];
  final RuntimeException[] exceptions=new RuntimeException[threadNumber];
  parallelRunning=true;
  final AtomicInteger runningThreads=new AtomicInteger(threadNumber);
  for (int i=0; i < threadNumber; ++i) {
    final int current=i;
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        try {
          ODatabaseDocumentTx localDatabase=null;
          try {
            exceptions[current]=null;
            results[current]=true;
            final OCommandContext threadContext=context.copy();
            contexts[current]=threadContext;
            localDatabase=db.copy();
            localDatabase.activateOnCurrentThread();
            db.getMetadata().getSchema().makeSnapshot();
            scanClusterWithIterator(localDatabase,threadContext,current,clusterList,results);
          }
 catch (          RuntimeException t) {
            exceptions[current]=t;
          }
 finally {
            runningThreads.decrementAndGet();
            resultQueue.offer(PARALLEL_END_EXECUTION_THREAD);
            if (localDatabase != null)             localDatabase.close();
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
,"OrientDB SELECT " + getDatabase().getName() + "-"+ i);
    threads[i].start();
  }
  while (runningThreads.get() > 0 || !resultQueue.isEmpty()) {
    try {
      final AsyncResult result=resultQueue.take();
      if (OExecutionThreadLocal.isInterruptCurrentOperation())       throw new InterruptedException("Operation has been interrupted");
      if (result != PARALLEL_END_EXECUTION_THREAD) {
        if (!handleResult(result.record,result.context)) {
          parallelRunning=false;
          break;
        }
      }
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
      break;
    }
  }
  parallelRunning=false;
  for (int i=0; i < threadNumber; ++i) {
    try {
      threads[i].join();
      context.merge(contexts[i]);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  for (int i=0; i < threadNumber; ++i)   if (exceptions[i] != null)   throw exceptions[i];
  for (int i=0; i < threadNumber; ++i) {
    if (!results[i])     return false;
  }
  return true;
}
