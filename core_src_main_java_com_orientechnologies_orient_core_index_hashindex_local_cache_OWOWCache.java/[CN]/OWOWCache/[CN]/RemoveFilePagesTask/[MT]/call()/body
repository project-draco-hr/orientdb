{
  final GroupKey firstKey=new GroupKey(fileId,0);
  final GroupKey lastKey=new GroupKey(fileId,Long.MAX_VALUE);
  NavigableMap<GroupKey,WriteGroup> subMap=writeGroups.subMap(firstKey,true,lastKey,true);
  Iterator<Map.Entry<GroupKey,WriteGroup>> entryIterator=subMap.entrySet().iterator();
  while (entryIterator.hasNext()) {
    Map.Entry<GroupKey,WriteGroup> entry=entryIterator.next();
    lockManager.acquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    try {
      WriteGroup writeGroup=entry.getValue();
      GroupKey groupKey=entry.getKey();
      List<PageKey> lockedPages=new ArrayList<PageKey>();
      for (int i=0; i < 16; i++) {
        final PageKey pageKey=new PageKey(groupKey.fileId,(groupKey.groupIndex << 4) + i);
        pageFlushLockManger.acquireLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED);
        lockedPages.add(pageKey);
      }
      try {
        for (        OCachePointer pagePointer : writeGroup.pages) {
          if (pagePointer != null && pagePointer.getUsagesCount() > 0)           throw new OException("Pages in write group with index " + groupKey.groupIndex + " are used and can not be removed.");
        }
        for (        OCachePointer pagePointer : writeGroup.pages) {
          if (pagePointer != null) {
            pagePointer.decrementReferrer();
            cacheSize.decrementAndGet();
          }
        }
      }
  finally {
        for (        PageKey pageKey : lockedPages)         pageFlushLockManger.releaseLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED);
      }
      entryIterator.remove();
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    }
  }
  return null;
}
