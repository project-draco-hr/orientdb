{
  if (!getNodeSource().equals(iManager.getLocalNodeName())) {
    if (database == null)     throw new ODistributedException("Database instance is null");
    final String databaseName=database.getName();
    final Lock lock=iManager.getLock(databaseName);
    if (lock.tryLock()) {
      try {
        final Long lastDeployment=(Long)iManager.getConfigurationMap().get(DEPLOYDB + databaseName);
        if (lastDeployment != null && lastDeployment.longValue() == random) {
          ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.NONE,"skip deploying database because already executed");
          return Boolean.FALSE;
        }
        iManager.getConfigurationMap().put(DEPLOYDB + databaseName,random);
        while (database.getStorage().getLastOperationId() >= iManager.getMessageService().getLastMessageId()) {
          ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"pausing deploy of database %s until all pending operations are completed...",databaseName);
          Thread.sleep(300);
        }
        iManager.setDatabaseStatus(databaseName,ODistributedServerManager.DB_STATUS.SYNCHRONIZING);
        ODistributedServerLog.warn(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"deploying database %s...",databaseName);
        final File f=new File(Orient.getTempPath() + "/backup_" + database.getName()+ ".zip");
        if (f.exists())         f.delete();
 else         f.getParentFile().mkdirs();
        f.createNewFile();
        ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"creating backup of database '%s' in directory: %s...",databaseName,f.getAbsolutePath());
        final AtomicLong lastOperationId=new AtomicLong(-1);
        FileOutputStream fileOutputStream=new FileOutputStream(f);
        try {
          database.backup(fileOutputStream,null,new Callable<Object>(){
            @Override public Object call() throws Exception {
              lastOperationId.set(database.getStorage().getLastOperationId());
              return null;
            }
          }
,this,OGlobalConfiguration.DISTRIBUTED_DEPLOYDB_TASK_COMPRESSION.getValueAsInteger(),CHUNK_MAX_SIZE);
          final long fileSize=f.length();
          ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.OUT,"sending the compressed database '%s' over the NETWORK to node '%s', size=%s, lastOperationId=%d...",databaseName,getNodeSource(),OFileUtils.getSizeAsString(fileSize),lastOperationId.get());
          final ODistributedDatabaseChunk chunk=new ODistributedDatabaseChunk(lastOperationId.get(),f,0,CHUNK_MAX_SIZE);
          ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),ODistributedServerLog.DIRECTION.OUT,"- transferring chunk #%d offset=%d size=%s...",1,0,OFileUtils.getSizeAsNumber(chunk.buffer.length));
          if (chunk.last)           iManager.setDatabaseStatus(databaseName,ODistributedServerManager.DB_STATUS.ONLINE);
          return chunk;
        }
  finally {
          fileOutputStream.close();
        }
      }
  finally {
        lock.unlock();
        ODistributedServerLog.info(this,iManager.getLocalNodeName(),getNodeSource(),ODistributedServerLog.DIRECTION.OUT,"deploy database task completed");
      }
    }
 else     ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.NONE,"skip deploying database %s because another node is doing it",databaseName);
  }
 else   ODistributedServerLog.debug(this,iManager.getLocalNodeName(),getNodeSource(),DIRECTION.NONE,"skip deploying database from the same node");
  return Boolean.FALSE;
}
