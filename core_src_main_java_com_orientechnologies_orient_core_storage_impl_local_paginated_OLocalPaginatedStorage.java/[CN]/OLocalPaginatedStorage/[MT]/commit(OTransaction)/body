{
  modificationLock.requestModificationLock();
  try {
    lock.acquireExclusiveLock();
    try {
      if (writeAheadLog == null)       throw new OStorageException("WAL mode is not active. Transactions are not supported in given mode");
      if (transaction != null && transaction.getClientTx().getId() != clientTx.getId())       rollback(clientTx);
      transaction=new OStorageTransaction(clientTx,OOperationUnitId.generateId());
      OLogSequenceNumber startLSN=writeAheadLog.log(new OAtomicUnitStartRecord(true,transaction.getOperationUnitId()));
      transaction.setStartLSN(startLSN);
      final List<ORecordOperation> tmpEntries=new ArrayList<ORecordOperation>();
      while (clientTx.getCurrentRecordEntries().iterator().hasNext()) {
        for (        ORecordOperation txEntry : clientTx.getCurrentRecordEntries())         tmpEntries.add(txEntry);
        clientTx.clearRecordEntries();
        if (!tmpEntries.isEmpty()) {
          for (          ORecordOperation txEntry : tmpEntries)           commitEntry(clientTx,txEntry);
        }
      }
      writeAheadLog.log(new OAtomicUnitEndRecord(transaction.getOperationUnitId(),false));
      OTransactionAbstract.updateCacheFromEntries(clientTx,clientTx.getAllRecordEntries(),true);
    }
 catch (    Exception e) {
      OLogManager.instance().info(this,"Error during transaction commit, transaction will be rolled back (tx-id=%d)",e,clientTx.getId());
      rollback(clientTx);
      if (e instanceof OException)       throw ((OException)e);
 else       throw new OStorageException("Error during transaction commit.",e);
    }
 finally {
      transaction=null;
      lock.releaseExclusiveLock();
    }
  }
  finally {
    modificationLock.releaseModificationLock();
  }
}
