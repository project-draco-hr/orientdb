{
  resetLastValidBackup();
  if (OScenarioThreadLocal.INSTANCE.get() == RUN_MODE.RUNNING_DISTRIBUTED) {
    wrapped.commit(iTx,callback);
    return;
  }
  final ODistributedConfiguration dbCfg=dManager.getDatabaseConfiguration(getName());
  final String localNodeName=dManager.getLocalNodeName();
  checkNodeIsMaster(localNodeName,dbCfg);
  try {
    if (!dbCfg.isReplicationActive(null,localNodeName)) {
      ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
        @Override public Object call() throws Exception {
          wrapped.commit(iTx,callback);
          return null;
        }
      }
);
      return;
    }
    OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.BEGUN);
    final OTxTask txTask=new OTxTask();
    final Set<String> involvedClusters=new HashSet<String>();
    Boolean executionModeSynch=dbCfg.isExecutionModeSynchronous(null);
    if (executionModeSynch == null)     executionModeSynch=Boolean.TRUE;
    final Iterable<ORecordOperation> tmpEntries=(Iterable<ORecordOperation>)iTx.getAllRecordEntries();
    for (    ORecordOperation op : tmpEntries) {
      final OAbstractRecordReplicatedTask task;
      final ORecord record=op.getRecord();
      final ORecordId rid=(ORecordId)record.getIdentity();
switch (op.type) {
case ORecordOperation.CREATED:
{
          if (rid.isNew()) {
            final ORecord rec=executionModeSynch ? record : record.copy();
            task=new OCreateRecordTask(rec);
            if (record instanceof ODocument)             ((ODocument)record).validate();
            break;
          }
        }
case ORecordOperation.UPDATED:
{
        if (record instanceof ODocument)         ((ODocument)record).validate();
        final OStorageOperationResult<ORawBuffer> previousContent=wrapped.readRecord(rid,null,false,null);
        if (previousContent.getResult() == null)         throw new ORecordNotFoundException("Cannot update record '" + rid + "' because has been deleted");
        final int v=executionModeSynch ? record.getVersion() : record.getVersion();
        task=new OUpdateRecordTask(rid,previousContent.getResult().getBuffer(),previousContent.getResult().version,record.toStream(),v,ORecordInternal.getRecordType(record));
        break;
      }
case ORecordOperation.DELETED:
{
      final int v=executionModeSynch ? record.getVersion() : record.getVersion();
      task=new ODeleteRecordTask(rid,v);
      break;
    }
default :
  continue;
}
involvedClusters.add(getClusterNameByRID(rid));
txTask.add(task);
}
OTransactionInternal.setStatus((OTransactionAbstract)iTx,OTransaction.TXSTATUS.COMMITTING);
final List<String> nodes=dbCfg.getServers(involvedClusters);
if (executionModeSynch) {
final int maxAutoRetry=OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_MAX_AUTORETRY.getValueAsInteger();
final int autoRetryDelay=OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_AUTORETRY_DELAY.getValueAsInteger();
Object result=null;
for (int retry=1; retry <= maxAutoRetry; ++retry) {
result=dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE,0);
if (!processCommitResult(localNodeName,iTx,txTask,involvedClusters,tmpEntries,nodes,autoRetryDelay,result)) continue;
return;
}
if (ODistributedServerLog.isDebugEnabled()) ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"distributed transaction retries exceed maximum auto-retries (%d)",maxAutoRetry);
throw (ODistributedRecordLockedException)result;
}
ODistributedAbstractPlugin.runInDistributedMode(new Callable(){
@Override public Object call() throws Exception {
iTx.restore();
wrapped.commit(iTx,callback);
return null;
}
}
);
for (ORecordOperation ent : iTx.getAllRecordEntries()) {
ORecordInternal.getDirtyManager(ent.getRecord()).clear();
}
nodes.remove(localNodeName);
if (!nodes.isEmpty()) {
if (executionModeSynch) dManager.sendRequest(getName(),involvedClusters,nodes,txTask,EXECUTION_MODE.RESPONSE,0);
 else {
final OAsyncReplicationOk onAsyncReplicationOk=OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationOk;
final OAsyncReplicationError onAsyncReplicationError=getAsyncReplicationError();
asynchronousExecution(new OAsynchDistributedOperation(getName(),involvedClusters,nodes,txTask,new OCallable(){
  @Override public Object call(  final Object iArgument){
    if (iArgument instanceof OTxTaskResult) {
      sendTxCompleted(localNodeName,involvedClusters,nodes,(OTxTaskResult)iArgument);
      if (onAsyncReplicationOk != null)       onAsyncReplicationOk.onAsyncReplicationOk();
      return null;
    }
 else     if (iArgument instanceof Exception) {
      try {
        final ORemoteTask undo=txTask.getUndoTaskForLocalStorage(iArgument);
        if (undo != null)         try {
          final ODatabaseDocumentTx database=new ODatabaseDocumentTx(getURL());
          database.setProperty(ODatabase.OPTIONS.SECURITY.toString(),OSecurityServerUser.class);
          database.open("system","system");
          try {
            undo.execute(0,serverInstance,dManager,database);
          }
  finally {
            database.close();
          }
        }
 catch (        Exception e) {
          ODistributedServerLog.error(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"async distributed transaction failed, cannot revert local transaction. Current node could have a not aligned database. Remote answer: %s",e,iArgument);
          throw OException.wrapException(new OTransactionException("Error on execution async distributed transaction, the database could be inconsistent"),(Exception)iArgument);
        }
        if (ODistributedServerLog.isDebugEnabled())         ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"async distributed transaction failed: %s",iArgument);
        if (iArgument instanceof RuntimeException)         throw (RuntimeException)iArgument;
 else         throw OException.wrapException(new OTransactionException("Error on execution async distributed transaction"),(Exception)iArgument);
      }
  finally {
        if (onAsyncReplicationError != null)         onAsyncReplicationError.onAsyncReplicationError((Throwable)iArgument,0);
      }
    }
    if (ODistributedServerLog.isDebugEnabled())     ODistributedServerLog.debug(this,localNodeName,null,ODistributedServerLog.DIRECTION.NONE,"async distributed transaction error, received unknown response type: %s",iArgument);
    throw new OTransactionException("Error on committing async distributed transaction, received unknown response type " + iArgument);
  }
}
,0));
}
}
}
 catch (OValidationException e) {
throw e;
}
catch (Exception e) {
handleDistributedException("Cannot route TX operation against distributed node",e);
}
}
