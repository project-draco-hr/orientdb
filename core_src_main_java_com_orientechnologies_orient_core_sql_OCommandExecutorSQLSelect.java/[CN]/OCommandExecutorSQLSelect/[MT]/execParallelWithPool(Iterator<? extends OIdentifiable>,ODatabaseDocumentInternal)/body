{
  final int cores=Runtime.getRuntime().availableProcessors();
  OLogManager.instance().debug(this,"Executing parallel query with strategy thread pool=%d",cores);
  executing=true;
  final List<Future<?>> jobs=new ArrayList<Future<?>>();
  while (executing && iTarget.hasNext()) {
    final OIdentifiable next=iTarget.next();
    if (next == null) {
      break;
    }
    final Runnable job=new Runnable(){
      @Override public void run(){
        ODatabaseRecordThreadLocal.INSTANCE.set(db);
        if (!executeSearchRecord(next))         executing=false;
      }
    }
;
    jobs.add(Orient.instance().submit(job));
  }
  if (OLogManager.instance().isDebugEnabled()) {
    OLogManager.instance().debug(this,"Parallel query '%s' split in %d jobs, waiting for completion...",parserText,jobs.size());
  }
  int processed=0;
  int total=jobs.size();
  try {
    for (    Future<?> j : jobs) {
      j.get();
      processed++;
      if (OLogManager.instance().isDebugEnabled()) {
        if (processed % (total / 10) == 0) {
          OLogManager.instance().debug(this,"Executed parallel query %d/%d",processed,total);
        }
      }
    }
  }
 catch (  Exception e) {
    OLogManager.instance().error(this,"Error on executing parallel query: %s",e,parserText);
  }
  return executing;
}
