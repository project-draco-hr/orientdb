{
  if (!pagesCache.isEmpty())   throw new IllegalStateException("WAL cache is not empty, we can not verify WAL after it was started to be used");
synchronized (rndFile) {
    long pagesCount=rndFile.length() / OWALPage.PAGE_SIZE;
    if (rndFile.length() % OWALPage.PAGE_SIZE > 0) {
      OLogManager.instance().error(this,"Last WAL page was written partially, auto fix.");
      rndFile.setLength(OWALPage.PAGE_SIZE * pagesCount);
    }
    long currentPage=pagesCount - 1;
    CRC32 crc32=new CRC32();
    while (currentPage >= 0) {
      crc32.reset();
      byte[] content=new byte[OWALPage.PAGE_SIZE];
      rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
      rndFile.readFully(content);
      int pageCRC=OIntegerSerializer.INSTANCE.deserializeNative(content,0);
      crc32.update(content,OIntegerSerializer.INT_SIZE,OWALPage.PAGE_SIZE - OIntegerSerializer.INT_SIZE);
      int calculatedCRC=(int)crc32.getValue();
      if (pageCRC != calculatedCRC) {
        OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage);
        currentPage--;
        pagesCount=currentPage + 1;
        rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
      }
 else       break;
    }
    if (currentPage < 0)     return;
    byte[] content=new byte[OWALPage.PAGE_SIZE];
    rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
    rndFile.readFully(content);
    currentPage--;
    long intialFlushId=OLongSerializer.INSTANCE.deserializeNative(content,OWALPage.FLUSH_ID_OFFSET);
    long loadedFlushId=intialFlushId;
    int flushedPagesCount=1;
    while (currentPage >= 0) {
      content=new byte[OWALPage.PAGE_SIZE];
      rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
      rndFile.readFully(content);
      crc32.reset();
      crc32.update(content,OIntegerSerializer.INT_SIZE,OWALPage.PAGE_SIZE - OIntegerSerializer.INT_SIZE);
      int calculatedCRC=(int)crc32.getValue();
      int pageCRC=OIntegerSerializer.INSTANCE.deserializeNative(content,0);
      if (pageCRC != calculatedCRC) {
        OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage);
        currentPage--;
        pagesCount=currentPage + 1;
        rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
        flushedPagesCount=0;
      }
 else {
        loadedFlushId=OLongSerializer.INSTANCE.deserializeNative(content,OWALPage.FLUSH_ID_OFFSET);
        if (loadedFlushId == intialFlushId) {
          flushedPagesCount++;
          currentPage--;
        }
 else         break;
      }
    }
    if (flushedPagesCount != 0) {
      content=new byte[OWALPage.PAGE_SIZE];
      rndFile.seek((currentPage + 1) * OWALPage.PAGE_SIZE);
      rndFile.readFully(content);
      final int firstFlushIndex=OIntegerSerializer.INSTANCE.deserializeNative(content,OWALPage.FLUSH_INDEX_OFFSET);
      if (firstFlushIndex != 0) {
        OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage + 1);
        pagesCount=currentPage + 1;
        rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
        flushedPagesCount=0;
      }
    }
    currentPage+=flushedPagesCount;
    while (currentPage >= 0) {
      rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
      rndFile.readFully(content);
      long pointer=directMemory.allocate(content);
      try {
        OWALPage page=new OWALPage(pointer,false);
        int pageOffset=findLastRecord(page,false);
        if (pageOffset >= 0) {
          if (page.mergeWithNextPage(pageOffset)) {
            page.truncateTill(pageOffset);
            rndFile.seek(currentPage * OWALPage.PAGE_SIZE);
            content=directMemory.get(pointer,OWALPage.PAGE_SIZE);
            rndFile.write(content);
            if (page.isEmpty()) {
              OLogManager.instance().error(this,"%d WAL page has been broken and will be truncated.",currentPage);
              currentPage--;
              pagesCount=currentPage + 1;
              rndFile.setLength(pagesCount * OWALPage.PAGE_SIZE);
            }
 else             break;
          }
 else           break;
        }
 else         break;
      }
  finally {
        directMemory.free(pointer);
      }
    }
    rndFile.getFD().sync();
  }
}
