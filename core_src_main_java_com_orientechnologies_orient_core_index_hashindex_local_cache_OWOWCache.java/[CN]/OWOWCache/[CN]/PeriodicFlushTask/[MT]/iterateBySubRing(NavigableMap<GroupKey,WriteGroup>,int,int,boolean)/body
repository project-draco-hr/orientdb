{
  Iterator<Map.Entry<GroupKey,WriteGroup>> entriesIterator=subMap.entrySet().iterator();
  long currentTime=System.currentTimeMillis();
  groupsLoop:   while (entriesIterator.hasNext() && flushedWriteGroups < writeGroupsToFlush) {
    Map.Entry<GroupKey,WriteGroup> entry=entriesIterator.next();
    final WriteGroup group=entry.getValue();
    final GroupKey groupKey=entry.getKey();
    if (group.recencyBit && group.creationTime - currentTime < groupTTL && !forceFlush) {
      group.recencyBit=false;
      continue;
    }
    if (group.creationTime - currentTime < groupTTL && !forceFlush) {
      if (!lockManager.tryAcquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE))       continue;
    }
 else     lockManager.acquireLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    try {
      if (group.recencyBit && group.creationTime - currentTime < groupTTL && !forceFlush)       group.recencyBit=false;
 else {
        group.recencyBit=false;
        List<PageKey> lockedPages=new ArrayList<PageKey>();
        for (int i=0; i < 16; i++) {
          final PageKey pageKey=new PageKey(groupKey.fileId,(groupKey.groupIndex << 4) + i);
          if (pageFlushLockManger.tryAcquireLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED))           lockedPages.add(pageKey);
 else           continue groupsLoop;
        }
        try {
          for (          OCachePointer pagePointer : group.pages) {
            if (pagePointer != null && pagePointer.getUsagesCount() > 0)             continue groupsLoop;
          }
          for (int i=0; i < 16; i++) {
            final OCachePointer pagePointer=group.pages[i];
            if (pagePointer != null) {
              flushPage(groupKey.fileId,(groupKey.groupIndex << 4) + i,pagePointer.getDataPointer());
              final OLogSequenceNumber flushedLSN=OLocalPage.getLogSequenceNumberFromPage(directMemory,pagePointer.getDataPointer());
              pagePointer.setLastFlushedLsn(flushedLSN);
              pagePointer.decrementReferrer();
              cacheSize.decrementAndGet();
            }
          }
          lastGroupKey=entry.getKey();
          entriesIterator.remove();
          flushedWriteGroups++;
        }
  finally {
          for (          PageKey pageKey : lockedPages)           pageFlushLockManger.releaseLock(Thread.currentThread(),pageKey,OLockManager.LOCK.SHARED);
        }
      }
    }
  finally {
      lockManager.releaseLock(Thread.currentThread(),entry.getKey(),OLockManager.LOCK.EXCLUSIVE);
    }
  }
  return flushedWriteGroups;
}
