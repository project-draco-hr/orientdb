{
  final long[] pos=getRelativePosition(iSourcePosition);
  final OFile file=files[(int)pos[0]];
  final int recordSize=file.readInt(pos[1]);
  if (recordSize < 0)   return -1;
  final long timer=Orient.instance().getProfiler().startChrono();
  final int clusterId=file.readShort(pos[1] + OBinaryProtocol.SIZE_INT);
  final byte[] clusterPositionContent=new byte[CLUSTER_POS_SIZE];
  file.read(pos[1] + OBinaryProtocol.SIZE_INT + OBinaryProtocol.SIZE_SHORT,clusterPositionContent,CLUSTER_POS_SIZE);
  final OClusterPosition clusterPosition=OClusterPositionFactory.INSTANCE.fromStream(clusterPositionContent);
  final byte[] content=new byte[recordSize];
  file.read(pos[1] + RECORD_FIX_SIZE,content,recordSize);
  if (clusterId > -1) {
    final OCluster cluster=storage.getClusterById(clusterId);
    final OPhysicalPosition ppos=cluster.getPhysicalPosition(new OPhysicalPosition(clusterPosition));
    if (ppos.dataSegmentPos != iSourcePosition)     OLogManager.instance().warn(this,"Found corrupted record hole for rid %d:%d: data position is wrong: %d <-> %d. Auto fixed by writing position %d",clusterId,clusterPosition,ppos.dataSegmentPos,iSourcePosition,iDestinationPosition);
    cluster.updateDataSegmentPosition(clusterPosition,id,iDestinationPosition);
  }
  writeRecord(getRelativePosition(iDestinationPosition),clusterId,clusterPosition,content);
  Orient.instance().getProfiler().stopChrono(PROFILER_MOVE_RECORD,"Time to move a chunk in data segment",timer);
  return recordSize + RECORD_FIX_SIZE;
}
