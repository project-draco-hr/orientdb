{
  if (classes.contains(iClass))   return;
  if (ODatabaseRecordThreadLocal.INSTANCE.isDefined() && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed() && !ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().existsClass(iClass.getSimpleName()))   ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().createClass(iClass.getSimpleName());
  for (Class<?> currentClass=iClass; currentClass != Object.class; ) {
    classes.add(currentClass);
    Class<?> fieldType;
    int fieldModifier;
    for (    Field f : currentClass.getDeclaredFields()) {
      fieldModifier=f.getModifiers();
      if (Modifier.isStatic(fieldModifier) || Modifier.isNative(fieldModifier) || Modifier.isTransient(fieldModifier))       continue;
      if (f.getName().equals("this$0")) {
        if (transientFields.get(iClass) == null)         transientFields.put(iClass,new ArrayList<String>());
        transientFields.get(iClass).add(f.getName());
      }
      if (OObjectSerializerHelper.jpaTransientClass != null) {
        Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaTransientClass);
        if (ann != null) {
          if (transientFields.get(iClass) == null)           transientFields.put(iClass,new ArrayList<String>());
          transientFields.get(iClass).add(f.getName());
        }
      }
      fieldType=f.getType();
      if (Collection.class.isAssignableFrom(fieldType) || fieldType.isArray() || Map.class.isAssignableFrom(fieldType)) {
        fieldType=OReflectionHelper.getGenericMultivalueType(f);
      }
      if (isToSerialize(fieldType)) {
        Map<Field,Class<?>> serializeClass=serializedFields.get(currentClass);
        if (serializeClass == null)         serializeClass=new HashMap<Field,Class<?>>();
        serializeClass.put(f,fieldType);
        serializedFields.put(currentClass,serializeClass);
      }
      boolean directBinding=true;
      if (f.getAnnotation(OAccess.class) == null || f.getAnnotation(OAccess.class).value() == OAccess.OAccessType.PROPERTY)       directBinding=true;
 else       if (OObjectSerializerHelper.jpaAccessClass != null) {
        Annotation ann=f.getAnnotation(OObjectSerializerHelper.jpaAccessClass);
        if (ann != null) {
          directBinding=true;
        }
      }
      if (directBinding) {
        if (directAccessFields.get(iClass) == null)         directAccessFields.put(iClass,new ArrayList<String>());
        directAccessFields.get(iClass).add(f.getName());
      }
      if (f.getAnnotation(ODocumentInstance.class) != null)       boundDocumentFields.put(iClass,f);
      boolean idFound=false;
      if (f.getAnnotation(OId.class) != null) {
        fieldIds.put(iClass,f);
        idFound=true;
      }
 else       if (OObjectSerializerHelper.jpaIdClass != null && f.getAnnotation(OObjectSerializerHelper.jpaIdClass) != null) {
        fieldIds.put(iClass,f);
        idFound=true;
      }
      if (idFound) {
        if (fieldType.isPrimitive())         OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be a literal to manage the Record Id",f.toString());
 else         if (!ORID.class.isAssignableFrom(fieldType) && fieldType != String.class && fieldType != Object.class && !Number.class.isAssignableFrom(fieldType))         OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be managed as type: %s",f.toString(),fieldType);
      }
      boolean vFound=false;
      if (f.getAnnotation(OVersion.class) != null) {
        fieldVersions.put(iClass,f);
        vFound=true;
      }
 else       if (OObjectSerializerHelper.jpaVersionClass != null && f.getAnnotation(OObjectSerializerHelper.jpaVersionClass) != null) {
        fieldVersions.put(iClass,f);
        vFound=true;
      }
      if (vFound) {
        if (fieldType.isPrimitive())         OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be a literal to manage the Version",f.toString());
 else         if (fieldType != String.class && fieldType != Object.class && !Number.class.isAssignableFrom(fieldType))         OLogManager.instance().warn(OObjectSerializerHelper.class,"Field '%s' cannot be managed as type: %s",f.toString(),fieldType);
      }
      if (OObjectSerializerHelper.jpaEmbeddedClass != null && f.getAnnotation(OObjectSerializerHelper.jpaEmbeddedClass) != null) {
        if (embeddedFields.get(iClass) == null)         embeddedFields.put(iClass,new ArrayList<String>());
        embeddedFields.get(iClass).add(f.getName());
      }
    }
    registerCallbacks(iClass);
    String iClassName=iClass.getSimpleName();
    currentClass=currentClass.getSuperclass();
    if (currentClass.equals(ODocument.class))     currentClass=Object.class;
    if (ODatabaseRecordThreadLocal.INSTANCE.get() != null && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed() && !currentClass.equals(Object.class)) {
      OClass oSuperClass;
      OClass currentOClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().getClass(iClassName);
      if (!ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().existsClass(currentClass.getSimpleName()))       oSuperClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().createClass(currentClass.getSimpleName());
 else       oSuperClass=ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().getClass(currentClass.getSimpleName());
      if (currentOClass.getSuperClass() == null || !currentOClass.getSuperClass().equals(oSuperClass))       currentOClass.setSuperClass(oSuperClass);
    }
  }
  if (ODatabaseRecordThreadLocal.INSTANCE.get() != null && !ODatabaseRecordThreadLocal.INSTANCE.get().isClosed())   ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema().save();
}
