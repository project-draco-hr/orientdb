{
  filesLock.acquireWriteLock();
  try {
    this.id=id;
    this.files=new ConcurrentHashMap<Integer,OFileClassic>();
    this.syncOnPageFlush=syncOnPageFlush;
    this.pageSize=pageSize;
    this.groupTTL=groupTTL;
    this.writeAheadLog=writeAheadLog;
    int writeNormalizedSize=normalizeMemory(writeCacheMaxSize,pageSize);
    if (checkMinSize && writeNormalizedSize < MIN_CACHE_SIZE)     writeNormalizedSize=MIN_CACHE_SIZE;
    int normalizedSize=normalizeMemory(cacheMaxSize,pageSize);
    if (checkMinSize && normalizedSize < MIN_CACHE_SIZE)     normalizedSize=MIN_CACHE_SIZE;
    this.writeCacheMaxSize=writeNormalizedSize;
    this.cacheMaxSize=normalizedSize;
    this.storageLocal=storageLocal;
    this.storagePath=storageLocal.getVariableParser().resolveVariables(storageLocal.getStoragePath());
    final OBinarySerializerFactory binarySerializerFactory=storageLocal.getComponentsFactory().binarySerializerFactory;
    this.stringSerializer=binarySerializerFactory.getObjectSerializer(OType.STRING);
    commitExecutor=Executors.newSingleThreadScheduledExecutor(new FlushThreadFactory(storageLocal.getName()));
    lowSpaceEventsPublisher=Executors.newCachedThreadPool(new LowSpaceEventsPublisherFactory(storageLocal.getName()));
    if (pageFlushInterval > 0)     commitExecutor.scheduleWithFixedDelay(new PeriodicFlushTask(),pageFlushInterval,pageFlushInterval,TimeUnit.NANOSECONDS);
  }
  finally {
    filesLock.releaseWriteLock();
  }
}
