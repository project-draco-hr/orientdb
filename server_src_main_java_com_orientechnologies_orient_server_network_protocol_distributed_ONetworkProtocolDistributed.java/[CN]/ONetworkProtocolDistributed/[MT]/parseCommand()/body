{
  if (clientId == null && connection != null && connection.data.clientId != null && connection.data.clientId.startsWith(ODistributedStorage.DNODE_PREFIX))   clientId=connection.data.clientId.substring(ODistributedStorage.DNODE_PREFIX.length());
switch (lastRequestType) {
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_SYNCHRONIZE:
{
      connection.data.commandInfo="Synchronization between nodes";
      final ODocument cfg=new ODocument(channel.readBytes());
      sendOk(lastClientTxId);
      final ORecordOperation op=new ORecordOperation();
      Collection<ODocument> nodes=cfg.field("nodes");
      for (      ODocument nodeCfg : nodes) {
        final String node=nodeCfg.field("node");
        final long lastLog=(Long)nodeCfg.field("lastLog");
        final String dbName=connection.database.getName();
        OLogManager.instance().info(this,"<-> DB %s: received synchronization request from node %s reading operation logs after %d",dbName,clientId,lastLog);
        final OOperationLog opLog=manager.getReplicator().getOperationLog(node,dbName);
        if (opLog != null) {
          channel.writeByte((byte)1);
          channel.writeString(node);
          int position=opLog.findOperationId(lastLog);
          int sent=0;
          sendOk(lastClientTxId);
          for (int i=position - 1; i >= 0; --i) {
            channel.writeByte((byte)1);
            opLog.getEntry(i,op);
            channel.writeBytes(op.toStream());
            sent++;
            OLogManager.instance().info(this,">> %s: (%d) operation %d with RID %s",dbName,sent,op.serial,op.record.getIdentity());
          }
          channel.writeByte((byte)0);
        }
      }
      channel.writeByte((byte)0);
      break;
    }
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_LEADER_CONNECT:
{
    connection.data.commandInfo="Clustered connection from leader";
    final ODocument doc=new ODocument().fromStream(channel.readBytes());
    final String clusterName=doc.field("clusterName");
    final byte[] encodedSecurityKey=doc.field("clusterKey");
    final String leaderAddress=doc.field("leaderNodeAddress");
    if (!clusterName.equals(manager.getName()) || !Arrays.equals(encodedSecurityKey,manager.getConfig().getSecurityKey()))     throw new OSecurityException("Invalid combination of cluster name and key received");
    boolean remainTheLeader=false;
    channel.acquireExclusiveLock();
    try {
      sendOk(lastClientTxId);
      channel.writeInt(connection.id);
      if (manager.isLeader()) {
        OLogManager.instance().warn(this,"Received remote connection from the leader node %s, but current node is itself leader: split network problem or high network latency?",leaderAddress);
        final String myUid=InetAddress.getLocalHost().getHostAddress() + ":" + channel.socket.getLocalPort();
        if (leaderAddress.compareTo(myUid) > 0) {
          remainTheLeader=true;
          OLogManager.instance().warn(this,"Current node remains the Leader of the cluster because it has lower network address",leaderAddress);
        }
      }
      channel.writeByte((byte)(remainTheLeader ? 0 : 1));
      if (!remainTheLeader) {
        final ODocument localCfg=manager.getReplicator().getLocalDatabaseConfiguration();
        channel.writeBytes(localCfg.toStream());
      }
    }
  finally {
      channel.releaseExclusiveLock();
      channel.flush();
    }
    manager.getReplicator().updateConfiguration(new ODocument(channel.readBytes()));
    manager.becomePeer(this);
    if (remainTheLeader)     shutdown();
    break;
  }
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_HEARTBEAT:
checkConnected();
connection.data.commandInfo="Cluster Heartbeat";
manager.updateHeartBeatTime();
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_RECORD_CHANGE:
{
connection.data.commandInfo="Distributed record change";
final byte operationType=channel.readByte();
final long operationId=channel.readLong();
final ORecordId rid=channel.readRID();
final byte[] buffer=channel.readBytes();
final int version=channel.readInt();
final byte recordType=channel.readByte();
final long result;
ODistributedRequesterThreadLocal.INSTANCE.set(true);
try {
switch (operationType) {
case ORecordOperation.CREATED:
result=createRecord(rid,buffer,recordType);
break;
case ORecordOperation.UPDATED:
result=updateRecord(rid,buffer,version,recordType);
break;
case ORecordOperation.DELETED:
result=deleteRecord(rid,version);
break;
default :
throw new IllegalArgumentException("Received invalid distributed record change operation type: " + operationType);
}
}
  finally {
ODistributedRequesterThreadLocal.INSTANCE.set(false);
}
final ODistributedNode node=manager.getReplicator().getNode(clientId);
final ODistributedDatabaseInfo db=node.getDatabase(connection.database.getName());
db.log.appendLog(operationId,operationType,rid);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
channel.writeLong(result);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_DB_SHARE_SENDER:
{
connection.data.commandInfo="Share the database to a remote server";
final String dbUrl=channel.readString();
final String dbUser=channel.readString();
final String dbPassword=channel.readString();
final String remoteServerName=channel.readString();
final String remoteServerEngine=channel.readString();
checkServerAccess("database.share");
openDatabase(dbUrl,dbUser,dbPassword);
final ODistributedNode node=manager.getReplicator().getOrCreateDistributedNode(remoteServerName);
final ODistributedDatabaseInfo db=node.shareDatabase(connection.database,remoteServerEngine,manager.getReplicator().getReplicatorUser().name,manager.getReplicator().getReplicatorUser().password);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
manager.getPeer().updateConfigurationToLeader();
break;
}
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_DB_SHARE_RECEIVER:
{
checkConnected();
connection.data.commandInfo="Received a shared database from a remote server to install";
final String dbName=channel.readString();
final String dbUser=channel.readString();
final String dbPasswd=channel.readString();
final String engineName=channel.readString();
try {
OLogManager.instance().info(this,"<-> DB %s: importing database...",dbName);
connection.database=getDatabaseInstance(dbName,engineName);
if (connection.database.exists()) {
OLogManager.instance().info(this,"<-> DB %s: deleting existent database...",connection.database.getName());
connection.database.delete();
}
createDatabase(connection.database,dbUser,dbPasswd);
if (connection.database.isClosed()) connection.database.open(dbUser,dbPasswd);
OLogManager.instance().info(this,"<-> DB %s: reading database content via streaming from remote server node...",dbName);
channel.acquireExclusiveLock();
try {
new ODatabaseImport(connection.database,new OChannelBinaryInputStream(channel),this).importDatabase();
OLogManager.instance().info(this,"<-> DB %s: database imported correctly",dbName);
sendOk(lastClientTxId);
channel.writeInt(connection.id);
channel.flush();
}
  finally {
channel.releaseExclusiveLock();
}
}
  finally {
manager.getPeer().updateHeartBeatTime();
}
manager.getPeer().updateConfigurationToLeader();
break;
}
case OChannelDistributedProtocol.REQUEST_DISTRIBUTED_DB_CONFIG:
{
checkConnected();
connection.data.commandInfo="Update db configuration from server node leader";
final ODocument cfg=new ODocument().fromStream(channel.readBytes());
manager.getReplicator().updateConfiguration(cfg);
OLogManager.instance().warn(this,"Cluster <%s>: changed distributed server configuration:\n%s",manager.getConfig().name,cfg.toJSON(""));
for (String dbName : cfg.fieldNames()) manager.sendClusterConfigurationToClients(dbName,cfg);
channel.acquireExclusiveLock();
try {
sendOk(lastClientTxId);
}
  finally {
channel.releaseExclusiveLock();
}
break;
}
default :
super.parseCommand();
return;
}
try {
channel.flush();
}
 catch (Throwable t) {
OLogManager.instance().debug(this,"Error on send data over the network",t);
}
}
